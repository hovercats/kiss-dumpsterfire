From 680e0bbbbf7aea3e79b26108f11e32be9e5d59f7 Mon Sep 17 00:00:00 2001
From: hovercats <hovercatswithlasereyes@protonmail.com>
Date: Thu, 14 Sep 2023 14:07:01 +0200
Subject: [PATCH] bump to 7.3 using oasis patches

---
 bin/pax/Makefile                |  36 ++++--
 bin/pax/ar_subs.c               |   6 +-
 bin/pax/options.c               |   6 +-
 bin/pax/pat_rep.c               |   8 +-
 bin/pax/pax.1                   |   6 +-
 bin/pax/tar.1                   |   6 +-
 bin/pax/tar.c                   |  67 ++++++++--
 include/blf.h                   |   7 +-
 include/dlfcn.h                 |   4 +-
 include/inttypes.h              |   5 +-
 include/libgen.h                |   6 +-
 include/link_elf.h              |   4 +-
 include/login_cap.h             |   7 +-
 include/netgroup.h              |   7 +-
 include/resolv.h                |   3 +-
 include/sha2.h                  |   4 +-
 include/siphash.h               |   4 +-
 include/sndio.h                 |   3 +-
 include/stdio.h                 |   4 +-
 include/tib.h                   |   4 +-
 include/time.h                  |  17 +--
 include/unistd.h                |   4 +-
 lib/libc/crypt/arc4random.c     |  12 +-
 lib/libc/crypt/blowfish.c       |  14 +--
 lib/libc/crypt/chacha_private.h |   4 +-
 lib/libc/gen/fts.c              |   4 +-
 lib/libc/gen/pwcache.c          |   4 +-
 lib/libc/gen/vis.c              |  75 +++++++----
 lib/libc/net/base64.c           |  32 ++---
 lib/libcrypto/md32_common.h     |   4 +-
 lib/libutil/bcrypt_pbkdf.c      |   5 +-
 lib/libutil/ohash.h             |   4 -
 lib/libutil/pidfile.c           |   1 -
 lib/libutil/util.h              |  20 +--
 sys/sys/_time.h                 |  35 ++++--
 sys/sys/_types.h                |   3 +-
 sys/sys/acct.h                  |  43 ++++---
 sys/sys/atomic.h                |  37 +++++-
 sys/sys/buf.h                   |  10 +-
 sys/sys/chio.h                  |   7 +-
 sys/sys/conf.h                  | 168 +++++++++++++------------
 sys/sys/core.h                  |   4 +-
 sys/sys/device.h                |  23 +++-
 sys/sys/disk.h                  |   3 +-
 sys/sys/disklabel.h             |  47 +++----
 sys/sys/domain.h                |  23 ++--
 sys/sys/evcount.h               |   8 +-
 sys/sys/event.h                 | 188 ++++++++++++++++++++++++----
 sys/sys/eventvar.h              |  34 +++--
 sys/sys/exec.h                  |  33 ++---
 sys/sys/exec_elf.h              |  49 +++++++-
 sys/sys/file.h                  |  17 +--
 sys/sys/filedesc.h              |   6 +-
 sys/sys/gmon.h                  |   4 +-
 sys/sys/hibernate.h             |  18 +--
 sys/sys/kcore.h                 |   7 +-
 sys/sys/kcov.h                  |   3 +-
 sys/sys/kernel.h                |  11 +-
 sys/sys/kstat.h                 |  10 +-
 sys/sys/ktrace.h                |  15 ++-
 sys/sys/malloc.h                |  34 ++---
 sys/sys/mbuf.h                  |  11 +-
 sys/sys/mman.h                  |   3 +-
 sys/sys/mount.h                 |   6 +-
 sys/sys/msg.h                   |   5 +-
 sys/sys/msgbuf.h                |  20 +--
 sys/sys/namei.h                 |  15 +--
 sys/sys/param.h                 |  10 +-
 sys/sys/pipe.h                  |   7 +-
 sys/sys/pledge.h                |  46 ++++---
 sys/sys/pool.h                  |   6 +-
 sys/sys/proc.h                  | 113 +++++++----------
 sys/sys/protosw.h               | 213 +++++++++++++++++++++++++++++---
 sys/sys/queue.h                 |  99 ++++++++++++++-
 sys/sys/reboot.h                |   3 +-
 sys/sys/refcnt.h                |  21 +++-
 sys/sys/resourcevar.h           |   5 +-
 sys/sys/rwlock.h                |  47 ++++++-
 sys/sys/sched.h                 |   3 +-
 sys/sys/selinfo.h               |   8 +-
 sys/sys/sem.h                   |   6 +-
 sys/sys/shm.h                   |   4 +-
 sys/sys/siginfo.h               |   6 +-
 sys/sys/signalvar.h             |  70 +++++------
 sys/sys/smr.h                   |   8 +-
 sys/sys/socket.h                |  48 ++++++-
 sys/sys/socketvar.h             | 204 +++++++++++++++++-------------
 sys/sys/sockio.h                |   9 +-
 sys/sys/specdev.h               |   4 +-
 sys/sys/stat.h                  |   4 +-
 sys/sys/statvfs.h               |   4 +-
 sys/sys/syscall.h               | 109 +++++++++-------
 sys/sys/syscall_mi.h            |  24 ++--
 sys/sys/syscallargs.h           | 179 +++++++++++++++++----------
 sys/sys/sysctl.h                |  89 +++++++++----
 sys/sys/syslimits.h             |   4 +-
 sys/sys/systm.h                 |  65 +++++-----
 sys/sys/termios.h               |   9 +-
 sys/sys/time.h                  |  37 +++++-
 sys/sys/timeout.h               |  55 ++++-----
 sys/sys/timetc.h                |  11 +-
 sys/sys/tracepoint.h            |   8 +-
 sys/sys/tree.h                  |  12 +-
 sys/sys/tty.h                   |   8 +-
 sys/sys/types.h                 |   3 +-
 sys/sys/ucred.h                 |   5 +-
 sys/sys/unpcb.h                 |  80 ++++++++----
 sys/sys/videoio.h               |   4 +-
 sys/sys/vnode.h                 |  72 +++++------
 sys/sys/wait.h                  |  29 ++++-
 usr.bin/diff/Makefile           |  26 +++-
 usr.bin/diff/diff.1             |  14 +--
 usr.bin/diff/diff.c             |   4 +-
 usr.bin/diff/diffreg.c          |   8 +-
 usr.bin/patch/Makefile          |  25 +++-
 usr.bin/patch/patch.1           |  15 +--
 usr.bin/patch/patch.c           |  11 +-
 usr.bin/patch/pch.c             |   4 +-
 usr.bin/patch/util.c            |   4 +-
 119 files changed, 2035 insertions(+), 1124 deletions(-)

diff --git a/bin/pax/Makefile b/bin/pax/Makefile
index 5dd36e2..4994158 100644
--- a/bin/pax/Makefile
+++ b/bin/pax/Makefile
@@ -1,11 +1,29 @@
-#	$OpenBSD: Makefile,v 1.13 2018/09/13 12:33:43 millert Exp $
+# baseutils pax Makefile
 
-WARNINGS=Yes
-PROG=   pax
-SRCS=	ar_io.c ar_subs.c buf_subs.c cpio.c file_subs.c ftree.c\
-	gen_subs.c getoldopt.c options.c pat_rep.c pax.c sel_subs.c tables.c\
-	tar.c tty_subs.c
-MAN=	pax.1 tar.1 cpio.1
-LINKS=	${BINDIR}/pax ${BINDIR}/tar ${BINDIR}/pax ${BINDIR}/cpio
+CC ?=		cc
+CFLAGS ?=	-O2 -pipe
+CFLAGS +=	-I../libopenbsd -include openbsd.h
 
-.include <bsd.prog.mk>
+LIBS =	../libopenbsd/libopenbsd.a
+
+PREFIX ?=	/usr/local
+MANDIR ?=	/usr/local/share/man
+
+PROG =	pax
+OBJS =	ar_io.o ar_subs.o buf_subs.o cpio.o file_subs.o ftree.o \
+	gen_subs.o getoldopt.o options.o pat_rep.o pax.o sel_subs.o \
+	tables.o tar.o tty_subs.o
+
+all: ${OBJS}
+	${CC} ${LDFLAGS} -o ${PROG} ${OBJS} ${LIBS}
+
+install:
+	install -c -s -m 555 ${PROG} ${PREFIX}/bin/${PROG}
+	install -c -s -m 555 ${PROG} ${PREFIX}/bin/tar
+	install -c -s -m 555 ${PROG} ${PREFIX}/bin/cpio
+	install -c -m 444 ${PROG}.1 ${MANDIR}/man1
+	install -c -m 444 tar.1 ${MANDIR}/man1
+	install -c -m 444 cpio.1 ${MANDIR}/man1
+
+clean:
+	rm -f ${PROG} ${OBJS}
diff --git a/bin/pax/ar_subs.c b/bin/pax/ar_subs.c
index f0a55ab..b66c8e7 100644
--- a/bin/pax/ar_subs.c
+++ b/bin/pax/ar_subs.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: ar_subs.c,v 1.49 2019/06/28 13:34:59 deraadt Exp $	*/
+/*	$OpenBSD: ar_subs.c,v 1.50 2021/10/24 21:24:21 deraadt Exp $	*/
 /*	$NetBSD: ar_subs.c,v 1.5 1995/03/21 09:07:06 cgd Exp $	*/
 
 /*-
@@ -436,7 +436,7 @@ wr_archive(ARCHD *arcn, int is_app)
 			 * we were later unable to read (we also purge it from
 			 * the link table).
 			 */
-			if ((fd = open(arcn->org_name, O_RDONLY, 0)) < 0) {
+			if ((fd = open(arcn->org_name, O_RDONLY)) < 0) {
 				syswarn(1,errno, "Unable to open %s to read",
 					arcn->org_name);
 				purg_lnk(arcn);
@@ -906,7 +906,7 @@ copy(void)
 		 * have to copy a regular file to the destination directory.
 		 * first open source file and then create the destination file
 		 */
-		if ((fdsrc = open(arcn->org_name, O_RDONLY, 0)) < 0) {
+		if ((fdsrc = open(arcn->org_name, O_RDONLY)) < 0) {
 			syswarn(1, errno, "Unable to open %s to read",
 			    arcn->org_name);
 			purg_lnk(arcn);
diff --git a/bin/pax/options.c b/bin/pax/options.c
index 917414c..27de25d 100644
--- a/bin/pax/options.c
+++ b/bin/pax/options.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: options.c,v 1.103 2019/11/15 20:34:17 naddy Exp $	*/
+/*	$OpenBSD: options.c,v 1.105 2023/01/17 16:20:28 tb Exp $	*/
 /*	$NetBSD: options.c,v 1.6 1996/03/26 23:54:18 mrg Exp $	*/
 
 /*-
@@ -1120,8 +1120,7 @@ tar_options(int argc, char **argv)
 int mkpath(char *);
 
 int
-mkpath(path)
-	char *path;
+mkpath(char *path)
 {
 	struct stat sb;
 	char *slash;
@@ -1390,7 +1389,6 @@ cpio_options(int argc, char **argv)
 				 */
 				frmt = &(fsub[F_OCPIO]);
 				break;
-			case '?':
 			default:
 				cpio_usage();
 				break;
diff --git a/bin/pax/pat_rep.c b/bin/pax/pat_rep.c
index 23f9b04..e5aa6af 100644
--- a/bin/pax/pat_rep.c
+++ b/bin/pax/pat_rep.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pat_rep.c,v 1.43 2017/09/16 07:42:34 otto Exp $	*/
+/*	$OpenBSD: pat_rep.c,v 1.44 2022/01/28 05:15:05 guenther Exp $	*/
 /*	$NetBSD: pat_rep.c,v 1.4 1995/03/21 09:07:33 cgd Exp $	*/
 
 /*-
@@ -79,7 +79,7 @@ static int resub(regex_t *, regmatch_t *, char *, char *, char *, char *);
 /*
  * rep_add()
  *	parses the -s replacement string; compiles the regular expression
- *	and stores the compiled value and it's replacement string together in
+ *	and stores the compiled value and its replacement string together in
  *	replacement string list. Input to this function is of the form:
  *		/old/new/pg
  *	The first char in the string specifies the delimiter used by this
@@ -715,7 +715,7 @@ mod_name(ARCHD *arcn)
 		if ((res = rep_name(arcn->name, sizeof(arcn->name), &(arcn->nlen), 1)) != 0)
 			return(res);
 
-		if (PAX_IS_HARDLINK(arcn->type)) {
+		if (PAX_IS_LINK(arcn->type)) {
 			if ((res = rep_name(arcn->ln_name,
 			    sizeof(arcn->ln_name), &(arcn->ln_nlen), 0)) != 0)
 				return(res);
@@ -728,7 +728,7 @@ mod_name(ARCHD *arcn)
 		 */
 		if ((res = tty_rename(arcn)) != 0)
 			return(res);
-		if (PAX_IS_HARDLINK(arcn->type))
+		if (PAX_IS_LINK(arcn->type))
 			sub_name(arcn->ln_name, &(arcn->ln_nlen),
 			    sizeof(arcn->ln_name));
 	}
diff --git a/bin/pax/pax.1 b/bin/pax/pax.1
index d146a96..dda8e2a 100644
--- a/bin/pax/pax.1
+++ b/bin/pax/pax.1
@@ -1,4 +1,4 @@
-.\"	$OpenBSD: pax.1,v 1.75 2020/01/16 16:46:46 schwarze Exp $
+.\"	$OpenBSD: pax.1,v 1.76 2022/03/31 17:27:14 naddy Exp $
 .\"	$NetBSD: pax.1,v 1.3 1995/03/21 09:07:37 cgd Exp $
 .\"
 .\" Copyright (c) 1992 Keith Muller.
@@ -34,7 +34,7 @@
 .\"
 .\"	@(#)pax.1	8.4 (Berkeley) 4/18/94
 .\"
-.Dd $Mdocdate: January 16 2020 $
+.Dd $Mdocdate: March 31 2022 $
 .Dt PAX 1
 .Os
 .Sh NAME
@@ -160,7 +160,7 @@ operands are specified, a list of files to copy with one per line is read from
 the standard input.
 When a
 .Ar file
-operand is also a directory the entire file
+operand is also a directory, the entire file
 hierarchy rooted at that directory will be included.
 The effect of the
 .Em copy
diff --git a/bin/pax/tar.1 b/bin/pax/tar.1
index c4346a5..0bdb0e2 100644
--- a/bin/pax/tar.1
+++ b/bin/pax/tar.1
@@ -1,4 +1,4 @@
-.\"	$OpenBSD: tar.1,v 1.63 2020/10/05 05:52:19 jmc Exp $
+.\"	$OpenBSD: tar.1,v 1.64 2022/03/31 17:27:14 naddy Exp $
 .\"
 .\" Copyright (c) 1996 SigmaSoft, Th. Lockert
 .\" All rights reserved.
@@ -23,7 +23,7 @@
 .\" (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 .\" THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 .\"
-.Dd $Mdocdate: October 5 2020 $
+.Dd $Mdocdate: March 31 2022 $
 .Dt TAR 1
 .Os
 .Sh NAME
@@ -304,7 +304,7 @@ Path in which to store temporary files.
 Default tape device to use instead of
 .Pa /dev/rst0 .
 If set to hyphen
-.Pq Sq -
+.Pq Sq - ,
 standard output is used.
 .El
 .Sh FILES
diff --git a/bin/pax/tar.c b/bin/pax/tar.c
index 898fddd..7ede793 100644
--- a/bin/pax/tar.c
+++ b/bin/pax/tar.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: tar.c,v 1.69 2021/06/14 00:36:13 deraadt Exp $	*/
+/*	$OpenBSD: tar.c,v 1.70 2022/03/01 21:19:11 sthen Exp $	*/
 /*	$NetBSD: tar.c,v 1.5 1995/03/21 09:07:49 cgd Exp $	*/
 
 /*-
@@ -417,7 +417,7 @@ tar_rd(ARCHD *arcn, char *buf)
 		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
 	else
 		arcn->sb.st_mtime = val;
-	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
+	arcn->sb.st_ctim = arcn->sb.st_atim = arcn->sb.st_mtim;
 
 	/*
 	 * have to look at the last character, it may be a '/' and that is used
@@ -787,12 +787,17 @@ reset:
 	arcn->sb.st_mode = (mode_t)(asc_ul(hd->mode, sizeof(hd->mode), OCT) &
 	    0xfff);
 	arcn->sb.st_size = (off_t)asc_ull(hd->size, sizeof(hd->size), OCT);
-	val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
-	if (val > MAX_TIME_T)
-		arcn->sb.st_mtime = INT_MAX;                    /* XXX 2038 */
-	else
-		arcn->sb.st_mtime = val;
-	arcn->sb.st_ctime = arcn->sb.st_atime = arcn->sb.st_mtime;
+	if (arcn->sb.st_mtime == 0) {
+		val = asc_ull(hd->mtime, sizeof(hd->mtime), OCT);
+		if (val > MAX_TIME_T)
+			arcn->sb.st_mtime = INT_MAX;		/* XXX 2038 */
+		else
+			arcn->sb.st_mtime = val;
+	}
+	if (arcn->sb.st_ctime == 0)
+		arcn->sb.st_ctim = arcn->sb.st_mtim;
+	if (arcn->sb.st_atime == 0)
+		arcn->sb.st_atim = arcn->sb.st_mtim;
 
 	/*
 	 * If we can find the ascii names for gname and uname in the password
@@ -1194,6 +1199,40 @@ expandname(char *buf, size_t len, char **gnu_name, const char *name,
 /* longest record we'll accept */
 #define MAXXHDRSZ	BLKMULT
 
+static int
+rd_time(struct timespec *ts, const char *keyword, char *p)
+{
+	const char *errstr;
+	char *q;
+	int multiplier;
+
+	if ((q = strchr(p, '.')) != NULL)
+		*q = '\0';
+
+	ts->tv_sec = strtonum(p, 0, MAX_TIME_T, &errstr);
+	if (errstr != NULL) {
+		paxwarn(1, "%s is %s: %s", keyword, errstr, p);
+		return -1;
+	}
+
+	ts->tv_nsec = 0;
+
+	if (q == NULL)
+		return 0;
+
+	multiplier = 100000000;
+	for (q++; *q != '\0'; q++) {
+		if (!isdigit((unsigned char)*q)) {
+			paxwarn(1, "%s contains non-digit", keyword);
+			return -1;
+		}
+		ts->tv_nsec += (*q - '0') * multiplier;
+		multiplier /= 10;
+	}
+
+	return 0;
+}
+
 static int
 rd_xheader(ARCHD *arcn, int global, off_t size)
 {
@@ -1272,6 +1311,18 @@ rd_xheader(ARCHD *arcn, int global, off_t size)
 			} else if (!strcmp(keyword, "linkpath")) {
 				arcn->ln_nlen = strlcpy(arcn->ln_name, p,
 				    sizeof(arcn->ln_name));
+			} else if (!strcmp(keyword, "mtime")) {
+				ret = rd_time(&arcn->sb.st_mtim, keyword, p);
+				if (ret < 0)
+					break;
+			} else if (!strcmp(keyword, "atime")) {
+				ret = rd_time(&arcn->sb.st_atim, keyword, p);
+				if (ret < 0)
+					break;
+			} else if (!strcmp(keyword, "ctime")) {
+				ret = rd_time(&arcn->sb.st_ctim, keyword, p);
+				if (ret < 0)
+					break;
 			}
 		}
 		p = nextp;
diff --git a/include/blf.h b/include/blf.h
index ec42b41..87d390c 100644
--- a/include/blf.h
+++ b/include/blf.h
@@ -1,4 +1,4 @@
-/* $OpenBSD: blf.h,v 1.7 2007/03/14 17:59:41 grunk Exp $ */
+/* $OpenBSD: blf.h,v 1.8 2021/11/29 01:04:45 djm Exp $ */
 /*
  * Blowfish - a fast block cipher designed by Bruce Schneier
  *
@@ -13,10 +13,7 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *      This product includes software developed by Niels Provos.
- * 4. The name of the author may not be used to endorse or promote products
+ * 3. The name of the author may not be used to endorse or promote products
  *    derived from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
diff --git a/include/dlfcn.h b/include/dlfcn.h
index 431065f..5423bb2 100644
--- a/include/dlfcn.h
+++ b/include/dlfcn.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: dlfcn.h,v 1.14 2017/11/28 17:19:47 kettenis Exp $	*/
+/*	$OpenBSD: dlfcn.h,v 1.16 2022/08/20 17:39:22 tb Exp $	*/
 /*	$NetBSD: dlfcn.h,v 1.2 1995/06/05 19:38:00 pk Exp $	*/
 
 /*
@@ -42,6 +42,8 @@
 #define RTLD_GLOBAL	0x100
 #define RTLD_LOCAL	0x000
 #define RTLD_TRACE	0x200
+#define RTLD_NODELETE	0x400
+#define RTLD_NOLOAD	0x800
 
 /*
  * Special handle arguments for dlsym().
diff --git a/include/inttypes.h b/include/inttypes.h
index b8f4507..4f604e9 100644
--- a/include/inttypes.h
+++ b/include/inttypes.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: inttypes.h,v 1.13 2019/01/25 00:19:25 millert Exp $	*/
+/*	$OpenBSD: inttypes.h,v 1.14 2022/07/31 01:27:31 guenther Exp $	*/
 
 /*
  * Copyright (c) 1997, 2005 Todd C. Miller <millert@openbsd.org>
@@ -23,6 +23,9 @@
 
 #ifdef __cplusplus
 #define __wchar_t	wchar_t
+#elif __POSIX_VISIBLE >= 200809 && !defined(_WCHAR_T_DEFINED_)
+#define _WCHAR_T_DEFINED_
+typedef	__wchar_t	wchar_t;
 #endif
 
 /*
diff --git a/include/libgen.h b/include/libgen.h
index 4312373..45e87e0 100644
--- a/include/libgen.h
+++ b/include/libgen.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: libgen.h,v 1.9 2019/01/25 00:19:25 millert Exp $	*/
+/*	$OpenBSD: libgen.h,v 1.10 2020/10/20 19:30:14 naddy Exp $	*/
 
 /*
  * Copyright (c) 1997 Todd C. Miller <millert@openbsd.org>
@@ -22,8 +22,8 @@
 #include <sys/cdefs.h>
 
 __BEGIN_DECLS
-char	*basename(const char *);
-char	*dirname(const char *);
+char	*basename(char *);
+char	*dirname(char *);
 __END_DECLS
 
 #endif /* _LIBGEN_H_ */
diff --git a/include/link_elf.h b/include/link_elf.h
index 45fc1b9..dbe0d36 100644
--- a/include/link_elf.h
+++ b/include/link_elf.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: link_elf.h,v 1.7 2016/09/20 18:24:55 kettenis Exp $	*/
+/*	$OpenBSD: link_elf.h,v 1.8 2022/01/28 04:59:15 guenther Exp $	*/
 
 /*
  * Public domain.
@@ -15,7 +15,7 @@
 
 /*
  * struct link_map is a part of the protocol between the debugger and
- * ld.so. ld.so may have additional fields in it's version of this
+ * ld.so. ld.so may have additional fields in its version of this
  * structure but those are ld.so private fields.
  */
 struct link_map {
diff --git a/include/login_cap.h b/include/login_cap.h
index 46a8bb6..7c8cc19 100644
--- a/include/login_cap.h
+++ b/include/login_cap.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: login_cap.h,v 1.16 2018/07/29 19:40:41 deraadt Exp $	*/
+/*	$OpenBSD: login_cap.h,v 1.19 2022/03/01 01:22:11 tedu Exp $	*/
 
 /*-
  * Copyright (c) 1995,1997 Berkeley Software Design, Inc. All rights reserved.
@@ -42,6 +42,7 @@
 #define	LOGIN_DEFSERVICE	"login"
 #define	LOGIN_DEFUMASK		022
 #define	_PATH_LOGIN_CONF	"/etc/login.conf"
+#define	_PATH_LOGIN_CONF_D	"/etc/login.conf.d"
 #define	_PATH_AUTHPROGDIR	"/usr/libexec/auth"
 #define	_PATH_AUTHPROG		"/usr/libexec/auth/login_"
 
@@ -53,7 +54,8 @@
 #define	LOGIN_SETUMASK		0x0020	/* Set umask */
 #define	LOGIN_SETUSER		0x0040	/* Set user */
 #define	LOGIN_SETENV		0x0080	/* Set environment */
-#define	LOGIN_SETALL 		0x00ff	/* Set all. */
+#define	LOGIN_SETRTABLE		0x0100	/* Set rtable */
+#define	LOGIN_SETALL 		0x01ff	/* Set all. */
 
 #define	BI_AUTH		"authorize"		/* Accepted authentication */
 #define	BI_REJECT	"reject"		/* Rejected authentication */
@@ -101,7 +103,6 @@ char	*login_getcapstr(login_cap_t *, char *, char *, char *);
 quad_t	 login_getcaptime(login_cap_t *, char *, quad_t, quad_t);
 char	*login_getstyle(login_cap_t *, char *, char *);
 
-int	secure_path(char *);
 int	setclasscontext(char *, unsigned int);
 int	setusercontext(login_cap_t *, struct passwd *, uid_t, unsigned int);
 
diff --git a/include/netgroup.h b/include/netgroup.h
index ce29367..9f1cf39 100644
--- a/include/netgroup.h
+++ b/include/netgroup.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: netgroup.h,v 1.8 2015/09/10 18:59:34 deraadt Exp $ */
+/*	$OpenBSD: netgroup.h,v 1.9 2023/01/04 13:00:11 jsg Exp $ */
 /*
  * Copyright (c) 1994 Christos Zoulas
  * All rights reserved.
@@ -11,11 +11,6 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *	This product includes software developed by Christos Zoulas.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
  * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
diff --git a/include/resolv.h b/include/resolv.h
index fb02483..449779e 100644
--- a/include/resolv.h
+++ b/include/resolv.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: resolv.h,v 1.22 2019/01/14 06:23:06 otto Exp $	*/
+/*	$OpenBSD: resolv.h,v 1.23 2021/11/22 20:18:27 jca Exp $	*/
 
 /*
  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
@@ -191,6 +191,7 @@ struct __res_state_ext {
 /* DNSSEC extensions: use higher bit to avoid conflict with ISC use */
 #define	RES_USE_DNSSEC	0x20000000	/* use DNSSEC using OK bit in OPT */
 #define	RES_USE_CD	0x10000000	/* set Checking Disabled flag */
+#define	RES_TRUSTAD	0x80000000	/* Request AD, keep it in responses. */
 
 #define RES_DEFAULT	(RES_RECURSE | RES_DEFNAMES | RES_DNSRCH)
 
diff --git a/include/sha2.h b/include/sha2.h
index 52ddb3f..1526923 100644
--- a/include/sha2.h
+++ b/include/sha2.h
@@ -66,7 +66,7 @@ typedef struct _SHA2_CTX {
 	u_int8_t	buffer[SHA512_BLOCK_LENGTH];
 } SHA2_CTX;
 
-__BEGIN_DECLS
+__BEGIN_DECLS;
 void SHA224Init(SHA2_CTX *);
 void SHA224Transform(u_int32_t state[8], const u_int8_t [SHA224_BLOCK_LENGTH]);
 void SHA224Update(SHA2_CTX *, const u_int8_t *, size_t)
@@ -151,6 +151,6 @@ char *SHA512_256FileChunk(const char *, char *, off_t, off_t)
 char *SHA512_256Data(const u_int8_t *, size_t, char *)
 	__attribute__((__bounded__(__string__,1,2)))
 	__attribute__((__bounded__(__minbytes__,3,SHA512_256_DIGEST_STRING_LENGTH)));
-__END_DECLS
+__END_DECLS;
 
 #endif /* _SHA2_H */
diff --git a/include/siphash.h b/include/siphash.h
index 7a5990c..471c965 100644
--- a/include/siphash.h
+++ b/include/siphash.h
@@ -26,7 +26,7 @@
  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  * SUCH DAMAGE.
  *
- * $OpenBSD: siphash.h,v 1.3 2015/02/20 11:51:03 tedu Exp $
+ * $OpenBSD: siphash.h,v 1.4 2022/12/27 07:44:56 jmc Exp $
  */
 
 /*
@@ -34,7 +34,7 @@
  * optimized for speed on short messages returning a 64bit hash/digest value.
  *
  * The number of rounds is defined during the initialization:
- *  SipHash24_Init() for the fast and resonable strong version
+ *  SipHash24_Init() for the fast and reasonable strong version
  *  SipHash48_Init() for the strong version (half as fast)
  *
  * struct SIPHASH_CTX ctx;
diff --git a/include/sndio.h b/include/sndio.h
index 03550a0..04c7336 100644
--- a/include/sndio.h
+++ b/include/sndio.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: sndio.h,v 1.13 2020/06/28 05:21:38 ratchov Exp $	*/
+/*	$OpenBSD: sndio.h,v 1.14 2022/04/29 08:30:48 ratchov Exp $	*/
 /*
  * Copyright (c) 2008 Alexandre Ratchov <alex@caoua.org>
  *
@@ -164,6 +164,7 @@ size_t sio_write(struct sio_hdl *, const void *, size_t);
 size_t sio_read(struct sio_hdl *, void *, size_t);
 int sio_start(struct sio_hdl *);
 int sio_stop(struct sio_hdl *);
+int sio_flush(struct sio_hdl *);
 int sio_nfds(struct sio_hdl *);
 int sio_pollfd(struct sio_hdl *, struct pollfd *, int);
 int sio_revents(struct sio_hdl *, struct pollfd *);
diff --git a/include/stdio.h b/include/stdio.h
index ffb49fb..0db964f 100644
--- a/include/stdio.h
+++ b/include/stdio.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: stdio.h,v 1.54 2020/09/11 17:56:41 naddy Exp $	*/
+/*	$OpenBSD: stdio.h,v 1.55 2022/01/05 20:57:27 millert Exp $	*/
 /*	$NetBSD: stdio.h,v 1.18 1996/04/25 18:29:21 jtc Exp $	*/
 
 /*-
@@ -368,7 +368,7 @@ __BEGIN_DECLS
 FILE	*funopen(const void *,
 		int (*)(void *, char *, int),
 		int (*)(void *, const char *, int),
-		fpos_t (*)(void *, fpos_t, int),
+		off_t (*)(void *, off_t, int),
 		int (*)(void *));
 __END_DECLS
 #define	fropen(cookie, fn) funopen(cookie, fn, 0, 0, 0)
diff --git a/include/tib.h b/include/tib.h
index d901b54..97dc08c 100644
--- a/include/tib.h
+++ b/include/tib.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: tib.h,v 1.8 2020/07/14 16:48:13 kettenis Exp $	*/
+/*	$OpenBSD: tib.h,v 1.9 2022/12/27 07:44:56 jmc Exp $	*/
 /*
  * Copyright (c) 2011,2014 Philip Guenther <guenther@openbsd.org>
  *
@@ -54,7 +54,7 @@
  *		Short-hand for TCB_TO_TIB(TCB_GET())
  *
  *	TIB_EXTRA_ALIGN
- *		On TLS varaint 2 archs, what alignment is sufficient
+ *		On TLS variant 2 archs, what alignment is sufficient
  *		for the extra space that will be used for struct pthread?
  *
  * The following functions are provided by either ld.so (dynamic) or
diff --git a/include/time.h b/include/time.h
index 51bee8f..3e1e2b4 100644
--- a/include/time.h
+++ b/include/time.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: time.h,v 1.31 2018/10/30 16:28:42 guenther Exp $	*/
+/*	$OpenBSD: time.h,v 1.32 2022/10/25 16:30:30 millert Exp $	*/
 /*	$NetBSD: time.h,v 1.9 1994/10/26 00:56:35 cgd Exp $	*/
 
 /*
@@ -44,6 +44,7 @@
 #include <sys/cdefs.h>
 #include <sys/_null.h>
 #include <sys/_types.h>
+#include <sys/_time.h>
 
 #ifndef	_CLOCK_T_DEFINED_
 #define	_CLOCK_T_DEFINED_
@@ -68,21 +69,7 @@ typedef	__size_t	size_t;
 #define CLK_TCK		100
 #endif
 
-#define CLOCKS_PER_SEC	100	/* frequency of ticks reported by clock().  */
-
-#if __POSIX_VISIBLE >= 199309 || __ISO_C_VISIBLE >= 2011
-#ifndef _TIMESPEC_DECLARED
-#define _TIMESPEC_DECLARED
-struct timespec {
-	time_t	tv_sec;		/* seconds */
-	long	tv_nsec;	/* and nanoseconds */
-};
-#endif
-#endif
-
 #if __POSIX_VISIBLE >= 199309
-#include <sys/_time.h>
-
 #ifndef	_CLOCKID_T_DEFINED_
 #define	_CLOCKID_T_DEFINED_
 typedef	__clockid_t	clockid_t;
diff --git a/include/unistd.h b/include/unistd.h
index c9432ea..7713470 100644
--- a/include/unistd.h
+++ b/include/unistd.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: unistd.h,v 1.106 2018/07/13 09:25:22 beck Exp $ */
+/*	$OpenBSD: unistd.h,v 1.107 2023/01/07 05:24:58 guenther Exp $ */
 /*	$NetBSD: unistd.h,v 1.26.4.1 1996/05/28 02:31:51 mrg Exp $	*/
 
 /*-
@@ -488,6 +488,7 @@ mode_t	 getmode(const void *, mode_t);
 int	 getresgid(gid_t *, gid_t *, gid_t *);
 int	 getresuid(uid_t *, uid_t *, uid_t *);
 pid_t	 getthrid(void);
+int	 getthrname(pid_t, char *, size_t);
 char	*getusershell(void);
 int	 initgroups(const char *, gid_t);
 int	 issetugid(void);
@@ -517,6 +518,7 @@ void	*setmode(const char *);
 int	 setpgrp(pid_t _pid, pid_t _pgrp);	/* BSD compat version */
 int	 setresgid(gid_t, gid_t, gid_t);
 int	 setresuid(uid_t, uid_t, uid_t);
+int	 setthrname(pid_t, const char *);
 void	 setusershell(void);
 int	 strtofflags(char **, u_int32_t *, u_int32_t *);
 int	 swapctl(int cmd, const void *arg, int misc);
diff --git a/lib/libc/crypt/arc4random.c b/lib/libc/crypt/arc4random.c
index 1a16bd3..2da8e01 100644
--- a/lib/libc/crypt/arc4random.c
+++ b/lib/libc/crypt/arc4random.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: arc4random.c,v 1.55 2019/03/24 17:56:54 deraadt Exp $	*/
+/*	$OpenBSD: arc4random.c,v 1.58 2022/07/31 13:41:45 tb Exp $	*/
 
 /*
  * Copyright (c) 1996, David Mazieres <dm@uun.org>
@@ -49,6 +49,8 @@
 #define BLOCKSZ	64
 #define RSBUFSZ	(16*BLOCKSZ)
 
+#define REKEY_BASE	(1024*1024) /* NB. should be a power of 2 */
+
 /* Marked MAP_INHERIT_ZERO, so zero'd out in fork children. */
 static struct _rs {
 	size_t		rs_have;	/* valid bytes at end of rs_buf */
@@ -78,7 +80,7 @@ _rs_init(u_char *buf, size_t n)
 			_exit(1);
 	}
 
-	chacha_keysetup(&rsx->rs_chacha, buf, KEYSZ * 8, 0);
+	chacha_keysetup(&rsx->rs_chacha, buf, KEYSZ * 8);
 	chacha_ivsetup(&rsx->rs_chacha, buf + KEYSZ);
 }
 
@@ -86,6 +88,7 @@ static void
 _rs_stir(void)
 {
 	u_char rnd[KEYSZ + IVSZ];
+	uint32_t rekey_fuzz = 0;
 
 	if (getentropy(rnd, sizeof rnd) == -1)
 		_getentropy_fail();
@@ -100,7 +103,10 @@ _rs_stir(void)
 	rs->rs_have = 0;
 	memset(rsx->rs_buf, 0, sizeof(rsx->rs_buf));
 
-	rs->rs_count = 1600000;
+	/* rekey interval should not be predictable */
+	chacha_encrypt_bytes(&rsx->rs_chacha, (uint8_t *)&rekey_fuzz,
+	    (uint8_t *)&rekey_fuzz, sizeof(rekey_fuzz));
+	rs->rs_count = REKEY_BASE + (rekey_fuzz % REKEY_BASE);
 }
 
 static inline void
diff --git a/lib/libc/crypt/blowfish.c b/lib/libc/crypt/blowfish.c
index a658e60..05ad00d 100644
--- a/lib/libc/crypt/blowfish.c
+++ b/lib/libc/crypt/blowfish.c
@@ -1,4 +1,4 @@
-/* $OpenBSD: blowfish.c,v 1.19 2015/09/11 09:18:27 guenther Exp $ */
+/* $OpenBSD: blowfish.c,v 1.21 2022/08/28 11:11:25 jsg Exp $ */
 /*
  * Blowfish block cipher for OpenBSD
  * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>
@@ -14,10 +14,7 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *      This product includes software developed by Niels Provos.
- * 4. The name of the author may not be used to endorse or promote products
+ * 3. The name of the author may not be used to endorse or promote products
  *    derived from this software without specific prior written permission.
  *
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
@@ -47,13 +44,6 @@
 #include <sys/types.h>
 #include <blf.h>
 
-#undef inline
-#ifdef __GNUC__
-#define inline __inline
-#else				/* !__GNUC__ */
-#define inline
-#endif				/* !__GNUC__ */
-
 /* Function for Feistel Networks */
 
 #define F(s, x) ((((s)[        (((x)>>24)&0xFF)]  \
diff --git a/lib/libc/crypt/chacha_private.h b/lib/libc/crypt/chacha_private.h
index 7c3680f..b0427b6 100644
--- a/lib/libc/crypt/chacha_private.h
+++ b/lib/libc/crypt/chacha_private.h
@@ -4,7 +4,7 @@ D. J. Bernstein
 Public domain.
 */
 
-/* $OpenBSD: chacha_private.h,v 1.2 2013/10/04 07:02:27 djm Exp $ */
+/* $OpenBSD: chacha_private.h,v 1.3 2022/02/28 21:56:29 dtucker Exp $ */
 
 typedef unsigned char u8;
 typedef unsigned int u32;
@@ -52,7 +52,7 @@ static const char sigma[16] = "expand 32-byte k";
 static const char tau[16] = "expand 16-byte k";
 
 static void
-chacha_keysetup(chacha_ctx *x,const u8 *k,u32 kbits,u32 ivbits)
+chacha_keysetup(chacha_ctx *x,const u8 *k,u32 kbits)
 {
   const char *constants;
 
diff --git a/lib/libc/gen/fts.c b/lib/libc/gen/fts.c
index eb332c6..8658519 100644
--- a/lib/libc/gen/fts.c
+++ b/lib/libc/gen/fts.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: fts.c,v 1.60 2021/01/08 16:06:30 tb Exp $	*/
+/*	$OpenBSD: fts.c,v 1.61 2021/11/29 03:20:37 deraadt Exp $	*/
 
 /*-
  * Copyright (c) 1990, 1993, 1994
@@ -29,7 +29,7 @@
  * SUCH DAMAGE.
  */
 
-#include <sys/param.h>	/* ALIGN */
+#include <sys/param.h>	/* ALIGN ALIGNBYTES */
 #include <sys/stat.h>
 #include <sys/types.h>
 
diff --git a/lib/libc/gen/pwcache.c b/lib/libc/gen/pwcache.c
index 2f30f4b..3e2f89b 100644
--- a/lib/libc/gen/pwcache.c
+++ b/lib/libc/gen/pwcache.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pwcache.c,v 1.15 2018/09/22 02:47:23 millert Exp $	*/
+/*	$OpenBSD: pwcache.c,v 1.16 2022/12/27 17:10:06 jmc Exp $	*/
 
 /*-
  * Copyright (c) 1992 Keith Muller.
@@ -79,7 +79,7 @@ typedef struct gidc {
  * Traditional passwd/group cache routines perform quite poorly with
  * archives. The chances of hitting a valid lookup with an archive is quite a
  * bit worse than with files already resident on the file system. These misses
- * create a MAJOR performance cost. To adress this problem, these routines
+ * create a MAJOR performance cost. To address this problem, these routines
  * cache both hits and misses.
  */
 
diff --git a/lib/libc/gen/vis.c b/lib/libc/gen/vis.c
index 4400c7b..6f7b501 100644
--- a/lib/libc/gen/vis.c
+++ b/lib/libc/gen/vis.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: vis.c,v 1.25 2015/09/13 11:32:51 guenther Exp $ */
+/*	$OpenBSD: vis.c,v 1.26 2022/05/04 18:57:50 deraadt Exp $ */
 /*-
  * Copyright (c) 1989, 1993
  *	The Regents of the University of California.  All rights reserved.
@@ -36,18 +36,41 @@
 #include <stdlib.h>
 #include <vis.h>
 
-#define	isoctal(c)	(((u_char)(c)) >= '0' && ((u_char)(c)) <= '7')
-#define	isvisible(c,flag)						\
-	(((c) == '\\' || (flag & VIS_ALL) == 0) &&			\
-	(((u_int)(c) <= UCHAR_MAX && isascii((u_char)(c)) &&		\
-	(((c) != '*' && (c) != '?' && (c) != '[' && (c) != '#') ||	\
-		(flag & VIS_GLOB) == 0) && isgraph((u_char)(c))) ||	\
-	((flag & VIS_SP) == 0 && (c) == ' ') ||				\
-	((flag & VIS_TAB) == 0 && (c) == '\t') ||			\
-	((flag & VIS_NL) == 0 && (c) == '\n') ||			\
-	((flag & VIS_SAFE) && ((c) == '\b' ||				\
-		(c) == '\007' || (c) == '\r' ||				\
-		isgraph((u_char)(c))))))
+static int
+isoctal(int c)
+{
+	u_char uc = c;
+
+	return uc >= '0' && uc <= '7';
+}
+
+static int
+isvisible(int c, int flag)
+{
+	int vis_sp = flag & VIS_SP;
+	int vis_tab = flag & VIS_TAB;
+	int vis_nl = flag & VIS_NL;
+	int vis_safe = flag & VIS_SAFE;
+	int vis_glob = flag & VIS_GLOB;
+	int vis_all = flag & VIS_ALL;
+	u_char uc = c;
+
+	if (c == '\\' || !vis_all) {
+		if ((u_int)c <= UCHAR_MAX && isascii(uc) &&
+		    ((c != '*' && c != '?' && c != '[' && c != '#') || !vis_glob) &&
+		    isgraph(uc))
+			return 1;
+		if (!vis_sp && c == ' ')
+			return 1;
+		if (!vis_tab && c == '\t')
+			return 1;
+		if (!vis_nl && c == '\n')
+			return 1;
+		if (vis_safe && (c == '\b' || c == '\007' || c == '\r' || isgraph(uc)))
+			return 1;
+	}
+	return 0;
+}
 
 /*
  * vis - visually encode characters
@@ -55,17 +78,23 @@
 char *
 vis(char *dst, int c, int flag, int nextc)
 {
+	int vis_dq = flag & VIS_DQ;
+	int vis_noslash = flag & VIS_NOSLASH;
+	int vis_cstyle = flag & VIS_CSTYLE;
+	int vis_octal = flag & VIS_OCTAL;
+	int vis_glob = flag & VIS_GLOB;
+
 	if (isvisible(c, flag)) {
-		if ((c == '"' && (flag & VIS_DQ) != 0) ||
-		    (c == '\\' && (flag & VIS_NOSLASH) == 0))
+		if ((c == '"' && vis_dq) ||
+		    (c == '\\' && !vis_noslash))
 			*dst++ = '\\';
 		*dst++ = c;
 		*dst = '\0';
 		return (dst);
 	}
 
-	if (flag & VIS_CSTYLE) {
-		switch(c) {
+	if (vis_cstyle) {
+		switch (c) {
 		case '\n':
 			*dst++ = '\\';
 			*dst++ = 'n';
@@ -108,15 +137,15 @@ vis(char *dst, int c, int flag, int nextc)
 			goto done;
 		}
 	}
-	if (((c & 0177) == ' ') || (flag & VIS_OCTAL) ||
-	    ((flag & VIS_GLOB) && (c == '*' || c == '?' || c == '[' || c == '#'))) {
+	if (((c & 0177) == ' ') || vis_octal ||
+	    (vis_glob && (c == '*' || c == '?' || c == '[' || c == '#'))) {
 		*dst++ = '\\';
 		*dst++ = ((u_char)c >> 6 & 07) + '0';
 		*dst++ = ((u_char)c >> 3 & 07) + '0';
 		*dst++ = ((u_char)c & 07) + '0';
 		goto done;
 	}
-	if ((flag & VIS_NOSLASH) == 0)
+	if (!vis_noslash)
 		*dst++ = '\\';
 	if (c & 0200) {
 		c &= 0177;
@@ -167,6 +196,8 @@ DEF_WEAK(strvis);
 int
 strnvis(char *dst, const char *src, size_t siz, int flag)
 {
+	int vis_dq = flag & VIS_DQ;
+	int vis_noslash = flag & VIS_NOSLASH;
 	char *start, *end;
 	char tbuf[5];
 	int c, i;
@@ -174,8 +205,8 @@ strnvis(char *dst, const char *src, size_t siz, int flag)
 	i = 0;
 	for (start = dst, end = start + siz - 1; (c = *src) && dst < end; ) {
 		if (isvisible(c, flag)) {
-			if ((c == '"' && (flag & VIS_DQ) != 0) ||
-			    (c == '\\' && (flag & VIS_NOSLASH) == 0)) {
+			if ((c == '"' && vis_dq) ||
+			    (c == '\\' && !vis_noslash)) {
 				/* need space for the extra '\\' */
 				if (dst + 1 >= end) {
 					i = 2;
diff --git a/lib/libc/net/base64.c b/lib/libc/net/base64.c
index e90696d..f36c11a 100644
--- a/lib/libc/net/base64.c
+++ b/lib/libc/net/base64.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: base64.c,v 1.8 2015/01/16 16:48:51 deraadt Exp $	*/
+/*	$OpenBSD: base64.c,v 1.15 2021/10/25 14:41:09 jca Exp $	*/
 
 /*
  * Copyright (c) 1996 by Internet Software Consortium.
@@ -46,11 +46,9 @@
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>
-#include <arpa/nameser.h>
 
 #include <ctype.h>
 #include <resolv.h>
-#include <stdio.h>
 
 #include <stdlib.h>
 #include <string.h>
@@ -107,9 +105,9 @@ static const char Pad64 = '=';
    end of the data is performed using the '=' character.
 
    Since all base64 input is an integral number of octets, only the
-         -------------------------------------------------                       
+         -------------------------------------------------
    following cases can arise:
-   
+
        (1) the final quantum of encoding input is an integral
            multiple of 24 bits; here, the final unit of encoded
 	   output will be an integral multiple of 4 characters
@@ -123,15 +121,12 @@ static const char Pad64 = '=';
    */
 
 int
-b64_ntop(src, srclength, target, targsize)
-	u_char const *src;
-	size_t srclength;
-	char *target;
-	size_t targsize;
+b64_ntop(unsigned char const *src, size_t srclength, char *target,
+    size_t targsize)
 {
 	size_t datalength = 0;
-	u_char input[3];
-	u_char output[4];
+	unsigned char input[3];
+	unsigned char output[4];
 	int i;
 
 	while (2 < srclength) {
@@ -152,14 +147,14 @@ b64_ntop(src, srclength, target, targsize)
 		target[datalength++] = Base64[output[2]];
 		target[datalength++] = Base64[output[3]];
 	}
-    
+
 	/* Now we worry about padding. */
 	if (0 != srclength) {
 		/* Get what's left. */
 		input[0] = input[1] = input[2] = '\0';
 		for (i = 0; i < srclength; i++)
 			input[i] = *src++;
-	
+
 		output[0] = input[0] >> 2;
 		output[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);
 		output[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);
@@ -187,13 +182,10 @@ b64_ntop(src, srclength, target, targsize)
  */
 
 int
-b64_pton(src, target, targsize)
-	char const *src;
-	u_char *target;
-	size_t targsize;
+b64_pton(char const *src, unsigned char *target, size_t targsize)
 {
 	int tarindex, state, ch;
-	u_char nextbyte;
+	unsigned char nextbyte;
 	char *pos;
 
 	state = 0;
@@ -207,7 +199,7 @@ b64_pton(src, target, targsize)
 			break;
 
 		pos = strchr(Base64, ch);
-		if (pos == 0) 		/* A non-base64 character. */
+		if (pos == 0)		/* A non-base64 character. */
 			return (-1);
 
 		switch (state) {
diff --git a/lib/libcrypto/md32_common.h b/lib/libcrypto/md32_common.h
index 0dca617..a8b0d9a 100644
--- a/lib/libcrypto/md32_common.h
+++ b/lib/libcrypto/md32_common.h
@@ -1,4 +1,4 @@
-/* $OpenBSD: md32_common.h,v 1.22 2016/11/04 13:56:04 miod Exp $ */
+/* $OpenBSD: md32_common.h,v 1.23 2022/12/26 07:18:50 jmc Exp $ */
 /* ====================================================================
  * Copyright (c) 1999-2007 The OpenSSL Project.  All rights reserved.
  *
@@ -316,7 +316,7 @@ int HASH_FINAL (unsigned char *md, HASH_CTX *c)
 #if defined(__alpha) || defined(__sparcv9) || defined(__mips)
 #define MD32_REG_T long
 /*
- * This comment was originaly written for MD5, which is why it
+ * This comment was originally written for MD5, which is why it
  * discusses A-D. But it basically applies to all 32-bit digests,
  * which is why it was moved to common header file.
  *
diff --git a/lib/libutil/bcrypt_pbkdf.c b/lib/libutil/bcrypt_pbkdf.c
index 1b04645..950dda8 100644
--- a/lib/libutil/bcrypt_pbkdf.c
+++ b/lib/libutil/bcrypt_pbkdf.c
@@ -1,4 +1,4 @@
-/* $OpenBSD: bcrypt_pbkdf.c,v 1.16 2020/08/02 18:35:48 tb Exp $ */
+/* $OpenBSD: bcrypt_pbkdf.c,v 1.17 2022/12/27 17:10:08 jmc Exp $ */
 /*
  * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>
  *
@@ -16,7 +16,6 @@
  */
 
 #include <sys/types.h>
-#include <sys/cdefs.h>
 
 #include <stdint.h>
 #include <stdlib.h>
@@ -34,7 +33,7 @@
  * function with the following modifications:
  * 1. The input password and salt are preprocessed with SHA512.
  * 2. The output length is expanded to 256 bits.
- * 3. Subsequently the magic string to be encrypted is lengthened and modifed
+ * 3. Subsequently the magic string to be encrypted is lengthened and modified
  *    to "OxychromaticBlowfishSwatDynamite"
  * 4. The hash function is defined to perform 64 rounds of initial state
  *    expansion. (More rounds are performed by iterating the hash.)
diff --git a/lib/libutil/ohash.h b/lib/libutil/ohash.h
index 3bc24b6..c5f81ec 100644
--- a/lib/libutil/ohash.h
+++ b/lib/libutil/ohash.h
@@ -18,10 +18,6 @@
 #ifndef OHASH_H
 #define OHASH_H
 
-#ifdef HAVE_FTS
-  #include <sys/cdefs.h>
-#endif
-
 /* Open hashing support. 
  * Open hashing was chosen because it is much lighter than other hash
  * techniques, and more efficient in most cases.
diff --git a/lib/libutil/pidfile.c b/lib/libutil/pidfile.c
index 7c07a20..e2d3018 100644
--- a/lib/libutil/pidfile.c
+++ b/lib/libutil/pidfile.c
@@ -30,7 +30,6 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <sys/cdefs.h>
 #include <sys/types.h>
 #include <errno.h>
 #include <paths.h>
diff --git a/lib/libutil/util.h b/lib/libutil/util.h
index d7aa8fa..5aebbb3 100644
--- a/lib/libutil/util.h
+++ b/lib/libutil/util.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: util.h,v 1.36 2019/08/30 03:57:56 deraadt Exp $	*/
+/*	$OpenBSD: util.h,v 1.38 2022/05/11 17:23:56 millert Exp $	*/
 /*	$NetBSD: util.h,v 1.2 1996/05/16 07:00:22 thorpej Exp $	*/
 
 /*-
@@ -79,7 +79,7 @@ struct termios;
 struct utmp;
 struct winsize;
 
-__BEGIN_DECLS
+__BEGIN_DECLS;
 char   *fparseln(struct __sFILE *, size_t *, size_t *, const char[3], int);
 void	login(struct utmp *);
 int	login_tty(int);
@@ -97,14 +97,16 @@ void	pw_edit(int, const char *);
 void	pw_prompt(void);
 void	pw_copy(int, int, const struct passwd *, const struct passwd *);
 int	pw_scan(char *, struct passwd *, int *);
-void	pw_error(const char *, int, int);
+void 	pw_error(const char *, int, int);
 int	getptmfd(void);
-int	openpty(int *, int *, char *, struct termios *, struct winsize *);
-int	fdopenpty(int, int *, int *, char *, struct termios *,
-	    struct winsize *);
+int	openpty(int *, int *, char *, const struct termios *,
+	    const struct winsize *);
+int	fdopenpty(int, int *, int *, char *, const struct termios *,
+	    const struct winsize *);
 int	opendisk(const char *, int, char *, size_t, int);
-pid_t	forkpty(int *, char *, struct termios *, struct winsize *);
-pid_t	fdforkpty(int, int *, char *, struct termios *, struct winsize *);
+pid_t	forkpty(int *, char *, const struct termios *, const struct winsize *);
+pid_t	fdforkpty(int, int *, char *, const struct termios *,
+	    const struct winsize *);
 int	getmaxpartitions(void);
 int	getrawpartition(void);
 void	login_fbtab(const char *, uid_t, gid_t);
@@ -122,6 +124,6 @@ int	pkcs5_pbkdf2(const char *, size_t, const uint8_t *, size_t,
 int	bcrypt_pbkdf(const char *, size_t, const uint8_t *, size_t,
     uint8_t *, size_t, unsigned int);
 
-__END_DECLS
+__END_DECLS;
 
 #endif /* !_UTIL_H_ */
diff --git a/sys/sys/_time.h b/sys/sys/_time.h
index a8ac94e..ce82222 100644
--- a/sys/sys/_time.h
+++ b/sys/sys/_time.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: _time.h,v 1.9 2017/12/18 05:51:53 cheloha Exp $	*/
+/*	$OpenBSD: _time.h,v 1.10 2022/10/25 16:30:30 millert Exp $	*/
 
 /*
  * Copyright (c) 1982, 1986, 1993
@@ -32,12 +32,8 @@
 #ifndef _SYS__TIME_H_
 #define _SYS__TIME_H_
 
-#define CLOCK_REALTIME			0
-#define CLOCK_PROCESS_CPUTIME_ID	2
-#define CLOCK_MONOTONIC			3
-#define CLOCK_THREAD_CPUTIME_ID		4
-#define CLOCK_UPTIME			5
-#define CLOCK_BOOTTIME			6
+/* Frequency of ticks reported by clock().  */
+#define CLOCKS_PER_SEC  100
 
 #if __BSD_VISIBLE
 /*
@@ -49,6 +45,29 @@
 #define __CLOCK_PTID(c)			(((c) >> 12) & 0xfffff)
 #endif
 
+#if __POSIX_VISIBLE >= 199309 || __ISO_C_VISIBLE >= 2011
+#ifndef _TIME_T_DEFINED_
+#define _TIME_T_DEFINED_
+typedef __time_t	time_t;
+#endif
+
+#ifndef _TIMESPEC_DECLARED
+#define _TIMESPEC_DECLARED
+struct timespec {
+	time_t	tv_sec;		/* seconds */
+	long	tv_nsec;	/* and nanoseconds */
+};
+#endif
+#endif
+
+#if __POSIX_VISIBLE >= 199309
+#define CLOCK_REALTIME			0
+#define CLOCK_PROCESS_CPUTIME_ID	2
+#define CLOCK_MONOTONIC			3
+#define CLOCK_THREAD_CPUTIME_ID		4
+#define CLOCK_UPTIME			5
+#define CLOCK_BOOTTIME			6
+
 /*
  * Structure defined by POSIX 1003.1b to be like a itimerval,
  * but with timespecs. Used in the timer_*() system calls.
@@ -61,4 +80,6 @@ struct  itimerspec {
 #define TIMER_RELTIME	0x0	/* relative timer */
 #define TIMER_ABSTIME	0x1	/* absolute timer */
 
+#endif
+
 #endif /* !_SYS__TIME_H_ */
diff --git a/sys/sys/_types.h b/sys/sys/_types.h
index e058674..33fa2d8 100644
--- a/sys/sys/_types.h
+++ b/sys/sys/_types.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: _types.h,v 1.9 2014/08/22 23:05:15 krw Exp $	*/
+/*	$OpenBSD: _types.h,v 1.10 2022/08/06 13:31:13 semarie Exp $	*/
 
 /*-
  * Copyright (c) 1990, 1993
@@ -60,7 +60,6 @@ typedef	__uint8_t	__sa_family_t;	/* sockaddr address family type */
 typedef	__int32_t	__segsz_t;	/* segment size */
 typedef	__uint32_t	__socklen_t;	/* length type for network syscalls */
 typedef	long		__suseconds_t;	/* microseconds (signed) */
-typedef	__int32_t	__swblk_t;	/* swap offset */
 typedef	__int64_t	__time_t;	/* epoch time */
 typedef	__int32_t	__timer_t;	/* POSIX timer identifiers */
 typedef	__uint32_t	__uid_t;	/* user id */
diff --git a/sys/sys/acct.h b/sys/sys/acct.h
index db7c846..6a7f51d 100644
--- a/sys/sys/acct.h
+++ b/sys/sys/acct.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: acct.h,v 1.9 2019/09/09 20:02:26 bluhm Exp $	*/
+/*	$OpenBSD: acct.h,v 1.13 2023/02/21 14:31:07 deraadt Exp $	*/
 /*	$NetBSD: acct.h,v 1.16 1995/03/26 20:23:52 jtc Exp $	*/
 
 /*-
@@ -37,6 +37,8 @@
  *	@(#)acct.h	8.3 (Berkeley) 7/10/94
  */
 
+#include <sys/syslimits.h>
+
 /*
  * Accounting structures; these use a comp_t type which is a 3 bits base 8
  * exponent, 13 bit fraction ``floating point'' number.  Units are 1/AHZ
@@ -45,26 +47,27 @@
 typedef u_int16_t comp_t;
 
 struct acct {
-	char	  ac_comm[10];	/* command name */
-	comp_t	  ac_utime;	/* user time */
-	comp_t	  ac_stime;	/* system time */
-	comp_t	  ac_etime;	/* elapsed time */
-	time_t	  ac_btime;	/* starting time */
-	uid_t	  ac_uid;	/* user id */
-	gid_t	  ac_gid;	/* group id */
-	u_int16_t ac_mem;	/* average memory usage */
-	comp_t	  ac_io;	/* count of IO blocks */
-	dev_t	  ac_tty;	/* controlling tty */
+	char	  ac_comm[_MAXCOMLEN];	/* command name, incl NUL */
+	comp_t	  ac_utime;		/* user time */
+	comp_t	  ac_stime;		/* system time */
+	comp_t	  ac_etime;		/* elapsed time */
+	comp_t	  ac_io;		/* count of IO blocks */
+	time_t	  ac_btime;		/* starting time */
+	uid_t	  ac_uid;		/* user id */
+	gid_t	  ac_gid;		/* group id */
+	u_int32_t ac_mem;		/* average memory usage */
+	dev_t	  ac_tty;		/* controlling tty, or -1 */
+	pid_t	  ac_pid;		/* process id */
 
-#define	AFORK	0x01		/* fork'd but not exec'd */
-#define	ASU	0x02		/* used super-user permissions */
-#define	AMAP	0x04		/* system call or stack mapping violation */
-#define	ACORE	0x08		/* dumped core */
-#define	AXSIG	0x10		/* killed by a signal */
-#define	APLEDGE	0x20		/* killed due to pledge violation */
-#define	ATRAP	0x40		/* memory access violation */
-#define	AUNVEIL	0x80		/* unveil access violation */
-	u_int8_t  ac_flag;	/* accounting flags */
+#define	AFORK	0x00000001		/* fork'd but not exec'd */
+#define	AMAP	0x00000004		/* system call or stack mapping violation */
+#define	ACORE	0x00000008		/* dumped core */
+#define	AXSIG	0x00000010		/* killed by a signal */
+#define	APLEDGE	0x00000020		/* killed due to pledge violation */
+#define	ATRAP	0x00000040		/* memory access violation */
+#define	AUNVEIL	0x00000080		/* unveil access violation */
+#define	AEXECVE	0x00000100		/* execve from wrong libc stub */
+	u_int32_t ac_flag;		/* accounting flags */
 };
 
 /*
diff --git a/sys/sys/atomic.h b/sys/sys/atomic.h
index 22b92b6..f648047 100644
--- a/sys/sys/atomic.h
+++ b/sys/sys/atomic.h
@@ -1,6 +1,7 @@
-/*	$OpenBSD: atomic.h,v 1.6 2019/03/09 06:14:21 visa Exp $ */
+/*	$OpenBSD: atomic.h,v 1.9 2022/03/21 05:45:52 visa Exp $ */
 /*
  * Copyright (c) 2014 David Gwynne <dlg@openbsd.org>
+ * Copyright (c) 2022 Alexander Bluhm <bluhm@openbsd.org>
  *
  * Permission to use, copy, modify, and distribute this software for any
  * purpose with or without fee is hereby granted, provided that the above
@@ -195,6 +196,40 @@ atomic_sub_long_nv(volatile unsigned long *p, unsigned long v)
 #define atomic_dec_long(_p) ((void)atomic_dec_long_nv(_p))
 #endif
 
+#ifdef _KERNEL
+/*
+ * atomic_load_* - read from memory
+ */
+
+static inline unsigned int
+atomic_load_int(volatile unsigned int *p)
+{
+	return *p;
+}
+
+static inline unsigned long
+atomic_load_long(volatile unsigned long *p)
+{
+	return *p;
+}
+
+/*
+ * atomic_store_* - write to memory
+ */
+
+static inline void
+atomic_store_int(volatile unsigned int *p, unsigned int v)
+{
+	*p = v;
+}
+
+static inline void
+atomic_store_long(volatile unsigned long *p, unsigned long v)
+{
+	*p = v;
+}
+#endif /* _KERNEL */
+
 /*
  * memory barriers
  */
diff --git a/sys/sys/buf.h b/sys/sys/buf.h
index ea01ac0..b8d887a 100644
--- a/sys/sys/buf.h
+++ b/sys/sys/buf.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: buf.h,v 1.112 2019/11/29 01:04:08 beck Exp $	*/
+/*	$OpenBSD: buf.h,v 1.113 2022/09/01 05:24:51 jsg Exp $	*/
 /*	$NetBSD: buf.h,v 1.25 1997/04/09 21:12:17 mycroft Exp $	*/
 
 /*
@@ -292,7 +292,6 @@ void bufcache_release(struct buf *);
 int buf_flip_high(struct buf *);
 void buf_flip_dma(struct buf *);
 struct buf *bufcache_getcleanbuf(int, int);
-struct buf *bufcache_getanycleanbuf(void);
 struct buf *bufcache_getdirtybuf(void);
 
 /*
@@ -305,7 +304,6 @@ struct buf *bufcache_getdirtybuf(void);
  */
 void	buf_mem_init(vsize_t);
 void	buf_acquire(struct buf *);
-void	buf_acquire_unmapped(struct buf *);
 void	buf_acquire_nomap(struct buf *);
 void	buf_map(struct buf *);
 void	buf_release(struct buf *);
@@ -326,10 +324,6 @@ void  buf_daemon(void *);
 void  buf_replacevnode(struct buf *, struct vnode *);
 int bread_cluster(struct vnode *, daddr_t, int, struct buf **);
 
-#ifdef DEBUG
-void buf_print(struct buf *);
-#endif
-
 static __inline void
 buf_start(struct buf *bp)
 {
@@ -367,8 +361,6 @@ buf_countdeps(struct buf *bp, int i, int islocked)
 		return (0);
 }
 
-void	cluster_write(struct buf *, struct cluster_info *, u_quad_t);
-
 __END_DECLS
 #endif /* _KERNEL */
 #endif /* !_SYS_BUF_H_ */
diff --git a/sys/sys/chio.h b/sys/sys/chio.h
index 88afaa9..a6cb8b1 100644
--- a/sys/sys/chio.h
+++ b/sys/sys/chio.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: chio.h,v 1.7 2006/05/31 03:01:44 beck Exp $	*/
+/*	$OpenBSD: chio.h,v 1.8 2021/08/31 05:29:55 robert Exp $	*/
 /*	$NetBSD: chio.h,v 1.8 1996/04/03 00:25:21 thorpej Exp $	*/
 
 /*
@@ -127,6 +127,11 @@ struct changer_voltag {
 struct changer_element_status {
 	int	 		ces_type;		/* element type */
 	u_int8_t 		ces_flags;		/* flags */
+	u_int16_t		ces_addr;		/* logical element address */
+	u_int8_t		ces_sensecode;	  	/* additional sense code for element */
+	u_int8_t		ces_sensequal;	  	/* additional sense code qualifier */
+	u_int8_t		ces_source_type;  	/*  element type of source address */
+	u_int16_t		ces_source_addr;	/*  source address of medium */
   	struct changer_voltag	ces_pvoltag;		/* primary voltag */
 	struct changer_voltag	ces_avoltag;		/* alternate voltag */
 };
diff --git a/sys/sys/conf.h b/sys/sys/conf.h
index 7478aa7..798ded6 100644
--- a/sys/sys/conf.h
+++ b/sys/sys/conf.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: conf.h,v 1.155 2020/07/06 04:11:26 dlg Exp $	*/
+/*	$OpenBSD: conf.h,v 1.161 2023/01/14 12:11:11 kettenis Exp $	*/
 /*	$NetBSD: conf.h,v 1.33 1996/05/03 20:03:32 christos Exp $	*/
 
 /*-
@@ -142,7 +142,6 @@ struct cdevsw {
 	int	(*d_stop)(struct tty *tp, int rw);
 	struct tty *
 		(*d_tty)(dev_t dev);
-	int	(*d_poll)(dev_t dev, int events, struct proc *p);
 	paddr_t	(*d_mmap)(dev_t, off_t, int);
 	u_int	d_type;
 	u_int	d_flags;
@@ -158,89 +157,88 @@ extern struct cdevsw cdevsw[];
 #define	dev_type_write(n)	int n(dev_t, struct uio *, int)
 #define	dev_type_stop(n)	int n(struct tty *, int)
 #define	dev_type_tty(n)		struct tty *n(dev_t)
-#define	dev_type_poll(n)	int n(dev_t, int, struct proc *)
 #define	dev_type_mmap(n)	paddr_t n(dev_t, off_t, int)
 #define dev_type_kqfilter(n)	int n(dev_t, struct knote *)
 
 #define	cdev_decl(n) \
 	dev_decl(n,open); dev_decl(n,close); dev_decl(n,read); \
 	dev_decl(n,write); dev_decl(n,ioctl); dev_decl(n,stop); \
-	dev_decl(n,tty); dev_decl(n,poll); dev_decl(n,mmap); \
+	dev_decl(n,tty); dev_decl(n,mmap); \
 	dev_decl(n,kqfilter)
 
 /* open, close, read, write, ioctl */
 #define	cdev_disk_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	D_DISK, 0, seltrue_kqfilter }
 
 /* open, close, read, write, ioctl */
 #define	cdev_tape_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	0, 0, seltrue_kqfilter }
 
 /* open, close, read, write, ioctl, stop, tty */
 #define	cdev_tty_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
-	dev_init(c,n,tty), ttpoll, (dev_type_mmap((*))) enodev, \
+	dev_init(c,n,tty), (dev_type_mmap((*))) enodev, \
 	D_TTY, 0, ttkqfilter }
 
-/* open, close, read, ioctl, poll, kqfilter */
+/* open, close, read, ioctl, kqfilter */
 #define	cdev_mouse_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev , 0, 0, dev_init(c,n,kqfilter) }
 
 #define	cdev_notdef() { \
 	(dev_type_open((*))) enodev, (dev_type_close((*))) enodev, \
 	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
 	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev, 0, 0, seltrue_kqfilter }
+	0, (dev_type_mmap((*))) enodev, 0, 0, seltrue_kqfilter }
 
-/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be a tty */
+/* open, close, read, write, ioctl, kqfilter -- XXX should be a tty */
 #define	cdev_cn_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	D_TTY, 0, dev_init(c,n,kqfilter) }
 
-/* open, read, write, ioctl, poll, kqfilter -- XXX should be a tty */
+/* open, read, write, ioctl, kqfilter -- XXX should be a tty */
 #define cdev_ctty_init(c,n) { \
 	dev_init(c,n,open), (dev_type_close((*))) nullop, dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	D_TTY, 0, dev_init(c,n,kqfilter) }
 
 /* open, close, read, write, ioctl, mmap */
 #define cdev_mm_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, seltrue, dev_init(c,n,mmap), \
+	(dev_type_stop((*))) enodev, 0, dev_init(c,n,mmap), \
 	0, 0, seltrue_kqfilter }
 
-/* open, close, read, write, ioctl, tty, poll, kqfilter */
+/* open, close, read, write, ioctl, tty, kqfilter */
 #define cdev_ptc_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) nullop, \
-	dev_init(c,n,tty), dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
+	dev_init(c,n,tty), (dev_type_mmap((*))) enodev, \
 	D_TTY, 0, dev_init(c,n,kqfilter) }
 
 /* open, close, read, write, ioctl, mmap */
 #define cdev_ptm_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, (dev_type_mmap((*))) enodev }
+	(dev_type_stop((*))) enodev, 0, (dev_type_mmap((*))) enodev }
 
-/* open, close, read, ioctl, poll, kqfilter XXX should be a generic device */
+/* open, close, read, ioctl, kqfilter XXX should be a generic device */
 #define cdev_log_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }
 
 /* open */
@@ -248,223 +246,223 @@ extern struct cdevsw cdevsw[];
 	dev_init(c,n,open), (dev_type_close((*))) enodev, \
 	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
 	(dev_type_ioctl((*))) enodev, (dev_type_stop((*))) enodev, \
-	0, selfalse, (dev_type_mmap((*))) enodev }
+	0, (dev_type_mmap((*))) enodev }
 
-/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be generic device */
+/* open, close, read, write, ioctl, kqfilter -- XXX should be generic device */
 #define cdev_tun_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	0, 0, dev_init(c,n,kqfilter) }
 
-/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be generic device */
-#define cdev_switch_init(c,n) {						\
-	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read),	\
-	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev,		\
-	0, 0, dev_init(c,n,kqfilter) }
-
-/* open, close, ioctl, poll, kqfilter -- XXX should be generic device */
+/* open, close, ioctl, kqfilter -- XXX should be generic device */
 #define cdev_vscsi_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), \
 	(dev_type_read((*))) enodev, (dev_type_write((*))) enodev, \
 	dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	0, 0, dev_init(c,n,kqfilter) }
 
-/* open, close, read, write, ioctl, poll, kqfilter -- XXX should be generic device */
+/* open, close, read, write, ioctl, kqfilter -- XXX should be generic device */
 #define cdev_pppx_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	0, 0, dev_init(c,n,kqfilter) }
 
-/* open, close, read, write, ioctl, poll, kqfilter, cloning -- XXX should be generic device */
+/* open, close, read, write, ioctl, kqfilter, cloning -- XXX should be generic device */
 #define cdev_bpf_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	0, D_CLONE, dev_init(c,n,kqfilter) }
 
 /* open, close, ioctl */
 #define	cdev_ch_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
 /* open, close, ioctl */
 #define       cdev_uk_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
 /* open, close, ioctl, mmap */
 #define	cdev_fb_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	dev_init(c,n,mmap) }
 
-/* open, close, read, write, ioctl, poll, kqfilter */
+/* open, close, read, write, ioctl, kqfilter */
 #define cdev_audio_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }
 
-/* open, close, read, write, ioctl, poll, kqfilter */
+/* open, close, read, write, ioctl, kqfilter */
 #define cdev_midi_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }
 
 /* open, close, read */
 #define cdev_ksyms_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	(dev_type_write((*))) enodev, (dev_type_ioctl((*))) enodev, \
-	(dev_type_stop((*))) enodev, 0, seltrue, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, 0, seltrue_kqfilter }
 
 /* open, close, ioctl */
 #define cdev_kstat_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
-/* open, close, read, write, ioctl, stop, tty, poll, mmap, kqfilter */
+/* open, close, read, write, ioctl, stop, tty, mmap, kqfilter */
 #define	cdev_wsdisplay_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), dev_init(c,n,stop), \
-	dev_init(c,n,tty), dev_init(c,n,poll), dev_init(c,n,mmap), \
+	dev_init(c,n,tty), dev_init(c,n,mmap), \
 	D_TTY, 0, dev_init(c,n,kqfilter) }
 
-/* open, close, read, write, ioctl, poll, kqfilter */
+/* open, close, read, write, ioctl, kqfilter */
 #define	cdev_random_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	0, 0, dev_init(c,n,kqfilter) }
 
-/* open, close, ioctl, poll, nokqfilter */
+/* open, close, ioctl, nokqfilter */
 #define	cdev_usb_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
 /* open, close, write */
 #define cdev_ulpt_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
-	(dev_type_stop((*))) enodev, 0, selfalse, (dev_type_mmap((*))) enodev }
+	(dev_type_stop((*))) enodev, 0, (dev_type_mmap((*))) enodev }
 
 /* open, close, ioctl */
 #define cdev_pf_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
-	(dev_type_mmap((*))) enodev }
+	(dev_type_stop((*))) enodev, 0, \
+	(dev_type_mmap((*))) enodev, 0, D_CLONE }
 
-/* open, close, read, write, ioctl, poll, kqfilter */
+/* open, close, read, write, ioctl, kqfilter */
 #define	cdev_usbdev_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, dev_init(c,n,poll), (dev_type_mmap((*))) enodev, 0, 0, \
+	0, (dev_type_mmap((*))) enodev, 0, 0, \
 	dev_init(c,n,kqfilter) }
 
-/* open, close, read, write, ioctl, poll, kqfilter */
+/* open, close, read, write, ioctl, kqfilter */
 #define	cdev_fido_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,uhid,close), dev_init(c,uhid,read), \
 	dev_init(c,uhid,write), dev_init(c,fido,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,uhid,poll), \
+	(dev_type_stop((*))) enodev, 0, \
+	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,uhid,kqfilter) }
+
+/* open, close, read, write, ioctl, kqfilter */
+#define	cdev_ujoy_init(c,n) { \
+	dev_init(c,n,open), dev_init(c,uhid,close), dev_init(c,uhid,read), \
+	dev_init(c,uhid,write), dev_init(c,ujoy,ioctl), \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,uhid,kqfilter) }
 
 /* open, close, init */
 #define cdev_pci_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
 /* open, close, ioctl */
 #define cdev_radio_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
-/* open, close, ioctl, read, mmap, poll, kqfilter */
+/* open, close, ioctl, read, mmap, kqfilter */
 #define cdev_video_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	dev_init(c,n,mmap), 0, 0, dev_init(c,n,kqfilter) }
 
 /* open, close, write, ioctl */
 #define cdev_spkr_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	dev_init(c,n,write), dev_init(c,n,ioctl), (dev_type_stop((*))) enodev, \
-	0, seltrue, (dev_type_mmap((*))) enodev, \
+	0, (dev_type_mmap((*))) enodev, \
 	0, 0, seltrue_kqfilter }
 
 /* open, close, write */
 #define cdev_lpt_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	dev_init(c,n,write), (dev_type_ioctl((*))) enodev, \
-	(dev_type_stop((*))) enodev, 0, seltrue, (dev_type_mmap((*))) enodev, \
+	(dev_type_stop((*))) enodev, 0, (dev_type_mmap((*))) enodev, \
 	0, 0, seltrue_kqfilter }
 
 /* open, close, read, ioctl, mmap */
 #define cdev_bktr_init(c, n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, seltrue, dev_init(c,n,mmap), \
+	(dev_type_stop((*))) enodev, 0, dev_init(c,n,mmap), \
 	0, 0, seltrue_kqfilter }
 
-/* open, close, read, ioctl, poll, kqfilter */
+/* open, close, read, ioctl, kqfilter */
 #define cdev_hotplug_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, 0, dev_init(c,n,kqfilter) }
 
 /* open, close, ioctl */
 #define cdev_gpio_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
 /* open, close, ioctl */
 #define       cdev_bio_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
-/* open, close, read, ioctl, poll, mmap, nokqfilter */
+/* open, close, read, ioctl, mmap, nokqfilter */
 #define      cdev_drm_init(c,n)        { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c, n, read), \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0,  dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	dev_init(c,n,mmap), 0, D_CLONE, dev_init(c,n,kqfilter) }
 
 /* open, close, ioctl */
 #define cdev_amdmsr_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
-/* open, close, read, write, poll, ioctl */
+/* open, close, read, write, ioctl */
 #define cdev_fuse_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	dev_init(c,n,write), dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, dev_init(c,n,poll), \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, D_CLONE, dev_init(c,n,kqfilter) }
 
 /* open, close, ioctl */
@@ -473,28 +471,35 @@ extern struct cdevsw cdevsw[];
 	(dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, \
 	 dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev }
 
 /* open, close, ioctl */
 #define cdev_ipmi_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, seltrue, (dev_type_mmap((*))) enodev, \
+	(dev_type_stop((*))) enodev, 0, (dev_type_mmap((*))) enodev, \
 	0, 0, seltrue_kqfilter }
 
+/* open, close, ioctl */
+#define cdev_efi_init(c,n) { \
+	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
+	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
+	(dev_type_stop((*))) enodev, 0, \
+	(dev_type_mmap((*))) enodev }
+
 /* open, close, ioctl, mmap */
 #define cdev_kcov_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), (dev_type_read((*))) enodev, \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_init(c,n,mmap)), 0, D_CLONE }
 
 /* open, close, read, ioctl */
 #define cdev_dt_init(c,n) { \
 	dev_init(c,n,open), dev_init(c,n,close), dev_init(c,n,read), \
 	(dev_type_write((*))) enodev, dev_init(c,n,ioctl), \
-	(dev_type_stop((*))) enodev, 0, selfalse, \
+	(dev_type_stop((*))) enodev, 0, \
 	(dev_type_mmap((*))) enodev, 0, D_CLONE }
 
 #endif
@@ -533,8 +538,8 @@ struct swdevt {
 
 #ifdef _KERNEL
 extern struct swdevt swdevt[];
-extern int chrtoblktbl[];
-extern int nchrtoblktbl;
+extern const int chrtoblktbl[];
+extern const int nchrtoblktbl;
 
 struct bdevsw *bdevsw_lookup(dev_t);
 struct cdevsw *cdevsw_lookup(dev_t);
@@ -600,7 +605,6 @@ cdev_decl(pf);
 
 cdev_decl(tun);
 cdev_decl(tap);
-cdev_decl(switch);
 cdev_decl(pppx);
 cdev_decl(pppac);
 
@@ -624,6 +628,7 @@ cdev_decl(usb);
 cdev_decl(ugen);
 cdev_decl(uhid);
 cdev_decl(fido);
+cdev_decl(ujoy);
 cdev_decl(ucom);
 cdev_decl(ulpt);
 cdev_decl(urio);
@@ -634,6 +639,7 @@ cdev_decl(amdmsr);
 cdev_decl(fuse);
 cdev_decl(pvbus);
 cdev_decl(ipmi);
+cdev_decl(efi);
 cdev_decl(kcov);
 
 #endif
diff --git a/sys/sys/core.h b/sys/sys/core.h
index cd69b41..284ef50 100644
--- a/sys/sys/core.h
+++ b/sys/sys/core.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: core.h,v 1.7 2016/09/17 06:09:08 guenther Exp $	*/
+/*	$OpenBSD: core.h,v 1.8 2022/02/22 17:14:13 deraadt Exp $	*/
 /*	$NetBSD: core.h,v 1.4 1994/10/29 08:20:14 cgd Exp $	*/
 
 /*
@@ -78,7 +78,7 @@ struct core {
 	u_int16_t c_hdrsize;		/* Size of this header (machdep algn) */
 	u_int16_t c_seghdrsize;		/* Size of a segment header */
 	u_int32_t c_nseg;		/* # of core segments */
-	char	c_name[MAXCOMLEN+1];	/* Copy of p->p_comm */
+	char	c_name[_MAXCOMLEN];	/* Copy of p->p_comm, incl NUL */
 	u_int32_t c_signo;		/* Killing signal */
 	u_long	c_ucode;		/* Hmm ? */
 	u_long	c_cpusize;		/* Size of machine dependent segment */
diff --git a/sys/sys/device.h b/sys/sys/device.h
index 1faa019..564cc14 100644
--- a/sys/sys/device.h
+++ b/sys/sys/device.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: device.h,v 1.55 2018/09/10 16:18:34 sashan Exp $	*/
+/*	$OpenBSD: device.h,v 1.64 2022/09/03 18:05:10 kettenis Exp $	*/
 /*	$NetBSD: device.h,v 1.15 1996/04/09 20:55:24 cgd Exp $	*/
 
 /*
@@ -89,7 +89,7 @@ TAILQ_HEAD(devicelist, device);
  * Configuration data (i.e., data placed in ioconf.c).
  */
 struct cfdata {
-	struct	cfattach *cf_attach;	/* config attachment */
+	const struct	cfattach *cf_attach;	/* config attachment */
 	struct	cfdriver *cf_driver;	/* config driver */
 	short	cf_unit;		/* unit number */
 	short	cf_fstate;		/* finding state (below) */
@@ -136,11 +136,15 @@ struct cfattach {
 #define	DETACH_FORCE	0x01		/* force detachment; hardware gone */
 #define	DETACH_QUIET	0x02		/* don't print a notice */
 
+/* For cd_mode, below */
+#define CD_INDIRECT		1
+#define CD_SKIPHIBERNATE	2
+
 struct cfdriver {
 	void	**cd_devs;		/* devices found */
 	char	*cd_name;		/* device name */
 	enum	devclass cd_class;	/* device classification */
-	int	cd_indirect;		/* indirectly configure subdevices */
+	int	cd_mode;		/* device type subclassification */
 	int	cd_ndevs;		/* size of cd_devs array */
 };
 
@@ -195,6 +199,18 @@ void config_pending_decr(void);
 void config_mountroot(struct device *, void (*)(struct device *));
 void config_process_deferred_mountroot(void);
 
+int	sleep_state(void *, int);
+#define SLEEP_SUSPEND	0x01
+#define SLEEP_HIBERNATE	0x02
+void	sleep_mp(void);
+void	resume_mp(void);
+int	sleep_showstate(void *v, int sleepmode);
+int	sleep_setstate(void *v);
+int	sleep_resume(void *v);
+void	sleep_abort(void *v);
+int	gosleep(void *v);
+int	suspend_finish(void *v);
+
 struct device *device_mainbus(void);
 struct device *device_mpath(void);
 struct device *device_lookup(struct cfdriver *, int unit);
@@ -212,6 +228,7 @@ void	setroot(struct device *, int, int);
 struct	device *getdisk(char *str, int len, int defpart, dev_t *devp);
 struct	device *parsedisk(char *str, int len, int defpart, dev_t *devp);
 void	device_register(struct device *, void *);
+void	device_register_wakeup(struct device *);
 
 int loadfirmware(const char *name, u_char **bufp, size_t *buflen);
 #define FIRMWARE_MAX	5*1024*1024
diff --git a/sys/sys/disk.h b/sys/sys/disk.h
index 4dcd488..a024bb1 100644
--- a/sys/sys/disk.h
+++ b/sys/sys/disk.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: disk.h,v 1.36 2017/05/04 22:47:27 deraadt Exp $	*/
+/*	$OpenBSD: disk.h,v 1.37 2022/09/11 19:34:40 miod Exp $	*/
 /*	$NetBSD: disk.h,v 1.11 1996/04/28 20:22:50 thorpej Exp $	*/
 
 /*
@@ -83,7 +83,6 @@ struct disk {
 #define DKF_CONSTRUCTED	0x0001
 #define DKF_OPENED	0x0002
 #define DKF_NOLABELREAD	0x0004
-#define DKF_LABELVALID	0x0008
 
 	/*
 	 * Metrics data; note that some metrics may have no meaning
diff --git a/sys/sys/disklabel.h b/sys/sys/disklabel.h
index 0d13a3f..b8fe2b9 100644
--- a/sys/sys/disklabel.h
+++ b/sys/sys/disklabel.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: disklabel.h,v 1.76 2020/05/10 00:56:06 guenther Exp $	*/
+/*	$OpenBSD: disklabel.h,v 1.86 2022/11/07 10:33:22 krw Exp $	*/
 /*	$NetBSD: disklabel.h,v 1.41 1996/05/10 23:07:37 mark Exp $	*/
 
 /*
@@ -107,7 +107,7 @@ struct disklabel {
 	u_int32_t d_bend;		/* end of useable region */
 	u_int32_t d_flags;		/* generic flags */
 #define NDDATA 5
-	u_int32_t d_drivedata[NDDATA];	/* drive-type specific information */
+	u_int32_t d_spare4[NDDATA];
 	u_int16_t d_secperunith;	/* # of data sectors (high part) */
 	u_int16_t d_version;		/* version # (1=48 bit addressing) */
 #define NSPARE 4
@@ -117,8 +117,8 @@ struct disklabel {
 
 			/* filesystem and partition information: */
 	u_int16_t d_npartitions;	/* number of partitions in following */
-	u_int32_t d_bbsize;		/* size of boot area at sn0, bytes */
-	u_int32_t d_sbsize;		/* max size of fs superblock, bytes */
+	u_int32_t d_spare2;
+	u_int32_t d_spare3;
 	struct	partition {		/* the partition table */
 		u_int32_t p_size;	/* number of sectors (low part) */
 		u_int32_t p_offset;	/* starting sector (low part) */
@@ -211,7 +211,7 @@ struct	__partitionv0 {		/* old (v0) partition table entry */
 #define DTYPE_RDROOT		15		/* ram disk root */
 
 #ifdef DKTYPENAMES
-static char *dktypenames[] = {
+static const char * const dktypenames[] = {
 	"unknown",
 	"SMD",
 	"MSCP",
@@ -262,7 +262,7 @@ static char *dktypenames[] = {
 #define FS_UDF		21		/* UDF (DVD) filesystem */
 
 #ifdef DKTYPENAMES
-static char *fstypenames[] = {
+static const char * const fstypenames[] = {
 	"unused",
 	"swap",
 	"Version6",
@@ -321,29 +321,8 @@ static char *fstypesnames[] = {
 /*
  * flags shared by various drives:
  */
-#define		D_BADSECT	0x04		/* supports bad sector forw. */
 #define		D_VENDOR	0x08		/* vendor disklabel */
 
-/*
- * Drive data for SMD.
- */
-#define	d_smdflags	d_drivedata[0]
-#define		D_SSE		0x1		/* supports skip sectoring */
-#define	d_mindist	d_drivedata[1]
-#define	d_maxdist	d_drivedata[2]
-#define	d_sdist		d_drivedata[3]
-
-/*
- * Drive data for ST506.
- */
-#define d_precompcyl	d_drivedata[0]
-#define d_gap3		d_drivedata[1]		/* used only when formatting */
-
-/*
- * Drive data for SCSI.
- */
-#define	d_blind		d_drivedata[0]
-
 #ifndef _LOCORE
 /*
  * Structure used internally to retrieve information about a partition
@@ -360,7 +339,14 @@ struct partinfo {
 				/* ASCII string "EFI PART" encoded as 64-bit */
 #define	GPTREVISION		0x10000		/* GPT header version 1.0 */
 #define	NGPTPARTITIONS		128
-#define	GPTDOSACTIVE		0x2
+#define	GPTPARTATTR_REQUIRED		(1ULL << 0)
+#define	GPTPARTATTR_IGNORE		(1ULL << 1)
+#define	GPTPARTATTR_BOOTABLE		(1ULL << 2)
+#define	GPTPARTATTR_MS_READONLY		(1ULL << 60)
+#define	GPTPARTATTR_MS_SHADOW		(1ULL << 61)
+#define	GPTPARTATTR_MS_HIDDEN		(1ULL << 62)
+#define	GPTPARTATTR_MS_NOAUTOMOUNT	(1ULL << 63)
+
 #define	GPTMINHDRSIZE		92
 #define	GPTMINPARTSIZE		128
 #define	GPTPARTNAMESIZE		36
@@ -441,6 +427,9 @@ struct gpt_partition {
 #define GPT_UUID_APPLE_UFS \
     { 0x55, 0x46, 0x53, 0x00, 0x00, 0x00, 0x11, 0xaa, \
       0xaa, 0x11, 0x00, 0x30, 0x65, 0x43, 0xec, 0xac }
+#define GPT_UUID_BIOS_BOOT \
+    { 0x21, 0x68, 0x61, 0x48, 0x64, 0x49, 0x6e, 0x6f, \
+      0x74, 0x4e, 0x65, 0x65, 0x64, 0x45, 0x46, 0x49 }
 
 /* DOS partition table -- located at start of some disks. */
 #define	DOS_LABELSECTOR 1
@@ -502,7 +491,7 @@ struct dos_mbr {
 void	 diskerr(struct buf *, char *, char *, int, int, struct disklabel *);
 u_int	 dkcksum(struct disklabel *);
 int	 initdisklabel(struct disklabel *);
-int	 checkdisklabel(void *, struct disklabel *, u_int64_t, u_int64_t);
+int	 checkdisklabel(dev_t, void *, struct disklabel *, u_int64_t, u_int64_t);
 int	 setdisklabel(struct disklabel *, struct disklabel *, u_int);
 int	 readdisklabel(dev_t, void (*)(struct buf *), struct disklabel *, int);
 int	 writedisklabel(dev_t, void (*)(struct buf *), struct disklabel *);
diff --git a/sys/sys/domain.h b/sys/sys/domain.h
index 7614cfa..478bc19 100644
--- a/sys/sys/domain.h
+++ b/sys/sys/domain.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: domain.h,v 1.20 2019/06/13 08:12:11 claudio Exp $	*/
+/*	$OpenBSD: domain.h,v 1.23 2022/11/23 14:50:59 kn Exp $	*/
 /*	$NetBSD: domain.h,v 1.10 1996/02/09 18:25:07 christos Exp $	*/
 
 /*
@@ -47,7 +47,7 @@ typedef	__socklen_t	socklen_t;	/* length type for network syscalls */
 struct	mbuf;
 struct	ifnet;
 
-struct	domain {
+struct domain {
 	int	dom_family;		/* AF_xxx */
 	char	*dom_name;
 	void	(*dom_init)(void);	/* initialize domain data structures */
@@ -59,20 +59,17 @@ struct	domain {
 					/* initialize routing table */
 	unsigned int	dom_sasize;	/* size of sockaddr structure */
 	unsigned int	dom_rtoffset;	/* offset of the key, in bytes */
-	unsigned int	dom_maxplen;	/* maxium prefix length, in bits */
-	void	*(*dom_ifattach)(struct ifnet *);
-	void	(*dom_ifdetach)(struct ifnet *, void *);
-					/* af-dependent data on ifnet */
+	unsigned int	dom_maxplen;	/* maximum prefix length, in bits */
 };
 
 #ifdef _KERNEL
-extern struct domain *domains[];
 void domaininit(void);
 
-extern struct domain inetdomain;
-
-#ifdef INET6
-extern struct domain inet6domain;
-#endif
-
+extern const struct domain *const domains[];
+extern const struct domain inet6domain;
+extern const struct domain inetdomain;
+extern const struct domain mplsdomain;
+extern const struct domain pfkeydomain;
+extern const struct domain routedomain;
+extern const struct domain unixdomain;
 #endif /* _KERNEL */
diff --git a/sys/sys/evcount.h b/sys/sys/evcount.h
index 9124e94..36968fc 100644
--- a/sys/sys/evcount.h
+++ b/sys/sys/evcount.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: evcount.h,v 1.3 2010/09/20 06:33:46 matthew Exp $ */
+/*	$OpenBSD: evcount.h,v 1.4 2022/11/10 07:05:41 jmatthew Exp $ */
 /*
  * Copyright (c) 2004 Artur Grabowski <art@openbsd.org>
  * Copyright (c) 2004 Aaron Campbell <aaron@openbsd.org>
@@ -32,17 +32,23 @@
 
 #include <sys/queue.h>
 
+struct cpumem;
+
 struct evcount {
 	u_int64_t		ec_count;	/* main counter */
 	int			ec_id;		/* counter ID */
 	const char		*ec_name;	/* counter name */
 	void			*ec_data;	/* user data */
+	struct cpumem		*ec_percpu;	/* per-cpu counter */
 
 	TAILQ_ENTRY(evcount)	next;
 };
 
 void evcount_attach(struct evcount *, const char *, void *);
 void evcount_detach(struct evcount *);
+void evcount_inc(struct evcount *);
+void evcount_init_percpu(void);
+void evcount_percpu(struct evcount *);
 int evcount_sysctl(int *, u_int, void *, size_t *, void *, size_t);
 
 #endif /* _KERNEL */
diff --git a/sys/sys/event.h b/sys/sys/event.h
index fefbfcc..05139cf 100644
--- a/sys/sys/event.h
+++ b/sys/sys/event.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: event.h,v 1.45 2020/08/23 07:05:29 mpi Exp $	*/
+/*	$OpenBSD: event.h,v 1.69 2023/02/10 14:34:17 visa Exp $	*/
 
 /*-
  * Copyright (c) 1999,2000,2001 Jonathan Lemon <jlemon@FreeBSD.org>
@@ -74,7 +74,7 @@ struct kevent {
 #define EV_RECEIPT	0x0040          /* force EV_ERROR on success, data=0 */
 #define EV_DISPATCH	0x0080          /* disable event after reporting */
 
-#define EV_SYSFLAGS	0xF000		/* reserved by system */
+#define EV_SYSFLAGS	0xf800		/* reserved by system */
 #define EV_FLAG1	0x2000		/* filter-specific flag */
 
 /* returned values */
@@ -127,17 +127,22 @@ struct kevent {
  * programs which pull in <sys/proc.h> or <sys/selinfo.h>.
  */
 #include <sys/queue.h>
+
+struct klistops;
 struct knote;
 SLIST_HEAD(knlist, knote);
 
 struct klist {
 	struct knlist		 kl_list;
+	const struct klistops	*kl_ops;
+	void			*kl_arg;
 };
 
 #ifdef _KERNEL
 
 /* kernel-only flags */
-#define __EV_POLL	0x1000		/* match behavior of poll & select */
+#define __EV_SELECT	0x0800		/* match behavior of select */
+#define __EV_POLL	0x1000		/* match behavior of poll */
 #define __EV_HUP	EV_FLAG1	/* device or socket disconnected */
 
 #define EVFILT_MARKER	0xf			/* placemarker for tailq */
@@ -147,12 +152,6 @@ struct klist {
  */
 #define NOTE_SUBMIT	0x01000000		/* initial knote submission */
 
-#define KNOTE(list, hint)	do { \
-					struct klist *__list = (list); \
-					if (__list != NULL) \
-						knote(__list, hint); \
-				} while (0)
-
 #define	KN_HASHSIZE		64		/* XXX should be tunable */
 
 /*
@@ -161,30 +160,88 @@ struct klist {
  */
 #define NOTE_SIGNAL	0x08000000
 
+/*
+ * = Event filter interface
+ *
+ * == .f_flags
+ *
+ * Defines properties of the event filter:
+ *
+ * - FILTEROP_ISFD      Each knote of this filter is associated
+ *                      with a file descriptor.
+ *
+ * - FILTEROP_MPSAFE    The kqueue subsystem can invoke .f_attach(),
+ *                      .f_detach(), .f_modify() and .f_process() without
+ *                      the kernel lock.
+ *
+ * == .f_attach()
+ *
+ * Attaches the knote to the object.
+ *
+ * == .f_detach()
+ *
+ * Detaches the knote from the object. The object must not use this knote
+ * for delivering events after this callback has returned.
+ *
+ * == .f_event()
+ *
+ * Notifies the filter about an event. Called through knote().
+ *
+ * == .f_modify()
+ *
+ * Modifies the knote with new state from the user.
+ *
+ * Returns non-zero if the knote has become active.
+ *
+ * == .f_process()
+ *
+ * Checks if the event is active and returns non-zero if the event should be
+ * returned to the user.
+ *
+ * If kev is non-NULL and the event is active, the callback should store
+ * the event's state in kev for delivery to the user.
+ *
+ * == Concurrency control
+ *
+ * The kqueue subsystem serializes calls of .f_attach(), .f_detach(),
+ * .f_modify() and .f_process().
+ */
+
 #define FILTEROP_ISFD		0x00000001	/* ident == filedescriptor */
+#define FILTEROP_MPSAFE		0x00000002	/* safe without kernel lock */
 
 struct filterops {
 	int	f_flags;
 	int	(*f_attach)(struct knote *kn);
 	void	(*f_detach)(struct knote *kn);
 	int	(*f_event)(struct knote *kn, long hint);
+	int	(*f_modify)(struct kevent *kev, struct knote *kn);
+	int	(*f_process)(struct knote *kn, struct kevent *kev);
 };
 
+/*
+ * Locking:
+ *	I	immutable after creation
+ *	o	object lock
+ *	q	kn_kq->kq_lock
+ */
 struct knote {
 	SLIST_ENTRY(knote)	kn_link;	/* for fd */
 	SLIST_ENTRY(knote)	kn_selnext;	/* for struct selinfo */
 	TAILQ_ENTRY(knote)	kn_tqe;
-	struct			kqueue *kn_kq;	/* which queue we are on */
+	struct			kqueue *kn_kq;	/* [I] which queue we are on */
 	struct			kevent kn_kevent;
-	int			kn_status;
-	int			kn_sfflags;	/* saved filter flags */
-	__int64_t		kn_sdata;	/* saved data field */
+	int			kn_status;	/* [q] */
+	int			kn_sfflags;	/* [o] saved filter flags */
+	__int64_t		kn_sdata;	/* [o] saved data field */
 	union {
 		struct		file *p_fp;	/* file data pointer */
 		struct		process *p_process;	/* process pointer */
 	} kn_ptr;
 	const struct		filterops *kn_fop;
-	void			*kn_hook;
+	void			*kn_hook;	/* [o] */
+	unsigned int		kn_pollid;	/* [I] */
+
 #define KN_ACTIVE	0x0001			/* event has been triggered */
 #define KN_QUEUED	0x0002			/* event is on queue */
 #define KN_DISABLED	0x0004			/* event is disabled */
@@ -192,33 +249,112 @@ struct knote {
 #define KN_PROCESSING	0x0010			/* knote is being processed */
 #define KN_WAITING	0x0020			/* waiting on processing */
 
-#define kn_id		kn_kevent.ident
-#define kn_filter	kn_kevent.filter
-#define kn_flags	kn_kevent.flags
-#define kn_fflags	kn_kevent.fflags
-#define kn_data		kn_kevent.data
-#define kn_fp		kn_ptr.p_fp
+#define kn_id		kn_kevent.ident		/* [I] */
+#define kn_filter	kn_kevent.filter	/* [I] */
+#define kn_flags	kn_kevent.flags		/* [o] */
+#define kn_fflags	kn_kevent.fflags	/* [o] */
+#define kn_data		kn_kevent.data		/* [o] */
+#define kn_udata	kn_kevent.udata		/* [o] */
+#define kn_fp		kn_ptr.p_fp		/* [o] */
+};
+
+struct klistops {
+	void	(*klo_assertlk)(void *);
+	int	(*klo_lock)(void *);
+	void	(*klo_unlock)(void *, int);
 };
 
+struct kqueue_scan_state {
+	struct kqueue	*kqs_kq;		/* kqueue of this scan */
+	struct knote	 kqs_start;		/* start marker */
+	struct knote	 kqs_end;		/* end marker */
+	int		 kqs_nevent;		/* number of events collected */
+	int		 kqs_queued;		/* if set, end marker is
+						 * in queue */
+};
+
+struct mutex;
 struct proc;
+struct rwlock;
+struct timespec;
 
 extern const struct filterops sig_filtops;
 extern const struct filterops dead_filtops;
 
+extern void	kqpoll_init(unsigned int);
+extern void	kqpoll_done(unsigned int);
+extern void	kqpoll_exit(void);
 extern void	knote(struct klist *list, long hint);
-extern void	knote_activate(struct knote *);
-extern void	knote_remove(struct proc *p, struct knlist *list);
+extern void	knote_locked(struct klist *list, long hint);
 extern void	knote_fdclose(struct proc *p, int fd);
-extern void	knote_processexit(struct proc *);
-extern int	kqueue_register(struct kqueue *kq,
-		    struct kevent *kev, struct proc *p);
+extern void	knote_processexit(struct process *);
+extern void	knote_assign(const struct kevent *, struct knote *);
+extern void	knote_submit(struct knote *, struct kevent *);
+extern void	kqueue_init(void);
+extern void	kqueue_init_percpu(void);
+extern int	kqueue_register(struct kqueue *kq, struct kevent *kev,
+		    unsigned int pollid, struct proc *p);
+extern int	kqueue_scan(struct kqueue_scan_state *, int, struct kevent *,
+		    struct timespec *, struct proc *, int *);
+extern void	kqueue_scan_setup(struct kqueue_scan_state *, struct kqueue *);
+extern void	kqueue_scan_finish(struct kqueue_scan_state *);
 extern int	filt_seltrue(struct knote *kn, long hint);
 extern int	seltrue_kqfilter(dev_t, struct knote *);
+extern void	klist_init(struct klist *, const struct klistops *, void *);
+extern void	klist_init_mutex(struct klist *, struct mutex *);
+extern void	klist_init_rwlock(struct klist *, struct rwlock *);
+extern void	klist_free(struct klist *);
 extern void	klist_insert(struct klist *, struct knote *);
+extern void	klist_insert_locked(struct klist *, struct knote *);
 extern void	klist_remove(struct klist *, struct knote *);
-extern int	klist_empty(struct klist *);
+extern void	klist_remove_locked(struct klist *, struct knote *);
 extern void	klist_invalidate(struct klist *);
 
+static inline int
+knote_modify_fn(const struct kevent *kev, struct knote *kn,
+    int (*f_event)(struct knote *, long))
+{
+	knote_assign(kev, kn);
+	return ((*f_event)(kn, 0));
+}
+
+static inline int
+knote_modify(const struct kevent *kev, struct knote *kn)
+{
+	return (knote_modify_fn(kev, kn, kn->kn_fop->f_event));
+}
+
+static inline int
+knote_process_fn(struct knote *kn, struct kevent *kev,
+    int (*f_event)(struct knote *, long))
+{
+	int active;
+
+	/*
+	 * If called from kqueue_scan(), skip f_event
+	 * when EV_ONESHOT is set, to preserve old behaviour.
+	 */
+	if (kev != NULL && (kn->kn_flags & EV_ONESHOT))
+		active = 1;
+	else
+		active = (*f_event)(kn, 0);
+	if (active)
+		knote_submit(kn, kev);
+	return (active);
+}
+
+static inline int
+knote_process(struct knote *kn, struct kevent *kev)
+{
+	return (knote_process_fn(kn, kev, kn->kn_fop->f_event));
+}
+
+static inline int
+klist_empty(struct klist *klist)
+{
+	return (SLIST_EMPTY(&klist->kl_list));
+}
+
 #else	/* !_KERNEL */
 
 #include <sys/cdefs.h>
diff --git a/sys/sys/eventvar.h b/sys/sys/eventvar.h
index 44338c5..0617ae1 100644
--- a/sys/sys/eventvar.h
+++ b/sys/sys/eventvar.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: eventvar.h,v 1.9 2020/04/07 13:27:52 visa Exp $	*/
+/*	$OpenBSD: eventvar.h,v 1.17 2022/07/09 12:48:21 visa Exp $	*/
 
 /*-
  * Copyright (c) 1999,2000 Jonathan Lemon <jlemon@FreeBSD.org>
@@ -31,6 +31,8 @@
 #ifndef _SYS_EVENTVAR_H_
 #define _SYS_EVENTVAR_H_
 
+#include <sys/mutex.h>
+#include <sys/refcnt.h>
 #include <sys/task.h>
 
 #define KQ_NEVENTS	8		/* minimize copy{in,out} calls */
@@ -38,27 +40,35 @@
 
 /*
  * Locking:
+ *	I	immutable after creation
+ *	L	kqueue_klist_lock
  *	a	atomic operations
+ *	q	kq_lock
  */
 struct kqueue {
-	TAILQ_HEAD(, knote) kq_head;		/* list of pending event */
-	int		kq_count;		/* number of pending events */
-	u_int		kq_refs;		/* [a] number of references */
-	struct		selinfo kq_sel;
-	struct		filedesc *kq_fdp;
+	struct		mutex kq_lock;		/* lock for queue access */
+	TAILQ_HEAD(, knote) kq_head;		/* [q] list of pending event */
+	int		kq_count;		/* [q] # of pending events */
+	struct		refcnt kq_refcnt;	/* [a] # of references */
+	struct		klist kq_klist;		/* [L] knotes of other kqs */
+	struct		filedesc *kq_fdp;	/* [I] fd table of this kq */
 
 	LIST_ENTRY(kqueue) kq_next;
 
-	int		kq_knlistsize;		/* size of kq_knlist */
-	struct		knlist *kq_knlist;	/* list of attached knotes */
-	u_long		kq_knhashmask;		/* size of kq_knhash */
-	struct		knlist *kq_knhash;	/* hash table for attached knotes */
+	u_int		kq_nknotes;		/* [q] # of registered knotes */
+
+	int		kq_knlistsize;		/* [q] size of kq_knlist */
+	struct		knlist *kq_knlist;	/* [q] list of
+						 *     attached knotes */
+	u_long		kq_knhashmask;		/* [q] size of kq_knhash */
+	struct		knlist *kq_knhash;	/* [q] hash table for
+						 *     attached knotes */
 	struct		task kq_task;		/* deferring of activation */
 
-	int		kq_state;
-#define KQ_SEL		0x01
+	int		kq_state;		/* [q] */
 #define KQ_SLEEP	0x02
 #define KQ_DYING	0x04
+#define KQ_TASK		0x08
 };
 
 #endif /* !_SYS_EVENTVAR_H_ */
diff --git a/sys/sys/exec.h b/sys/sys/exec.h
index 5158eb2..d083c6d 100644
--- a/sys/sys/exec.h
+++ b/sys/sys/exec.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: exec.h,v 1.42 2020/06/28 09:29:57 kettenis Exp $	*/
+/*	$OpenBSD: exec.h,v 1.51 2022/10/30 17:43:40 guenther Exp $	*/
 /*	$NetBSD: exec.h,v 1.59 1996/02/09 18:25:09 christos Exp $	*/
 
 /*-
@@ -57,12 +57,6 @@ struct ps_strings {
 	int	ps_nenvstr;	/* the number of environment strings */
 };
 
-/*
- * Below the PS_STRINGS and sigtramp, we may require a gap on the stack
- * (used to copyin/copyout various emulation data structures).
- */
-#define	STACKGAPLEN	(2*1024)	/* plenty enough for now */
-
 /*
  * the following structures allow execve() to put together processes
  * in a more extensible and cleaner way.
@@ -99,9 +93,11 @@ struct exec_vmcmd {
 #define VMCMD_BASE      0x0002  /* marks a base entry */
 #define VMCMD_STACK     0x0004  /* create with UVM_FLAG_STACK */
 #define VMCMD_SYSCALL   0x0008  /* create with UVM_FLAG_SYSCALL */
+#define VMCMD_IMMUTABLE	0x0010  /* create with UVM_ET_IMMUTABLE */
+#define VMCMD_TEXTREL	0x0020  /* terrible binary contains terrible textrel */
 };
 
-#define	EXEC_DEFAULT_VMCMD_SETSIZE	8	/* # of cmds in set to start */
+#define	EXEC_DEFAULT_VMCMD_SETSIZE	12	/* # of cmds in set to start */
 
 /* exec vmspace-creation command set; see below */
 struct exec_vmcmd_set {
@@ -111,6 +107,7 @@ struct exec_vmcmd_set {
 	struct	exec_vmcmd evs_start[EXEC_DEFAULT_VMCMD_SETSIZE];
 };
 
+struct elf_args;
 struct exec_package {
 	char	*ep_name;		/* file's name */
 	void	*ep_hdr;		/* file's exec header */
@@ -131,10 +128,8 @@ struct exec_package {
 	u_int	ep_flags;		/* flags; see below. */
 	char	**ep_fa;		/* a fake args vector for scripts */
 	int	ep_fd;			/* a file descriptor we're holding */
-	struct  emul *ep_emul;		/* os emulation */
-	void	*ep_emul_arg;		/* emulation argument */
-	size_t	ep_emul_argsize;	/* emulation argument size */
-	void	*ep_emul_argp;		/* emulation argument pointer */
+	struct	elf_args *ep_args;	/* ELF info */
+	void	*ep_auxinfo;		/* userspace auxinfo address */
 	char	*ep_interp;		/* name of interpreter if any */
 };
 #define	EXEC_INDIR	0x0001		/* script handling already done */
@@ -149,19 +144,16 @@ struct exec_package {
  * functions used either by execve() or the various cpu-dependent execve()
  * hooks.
  */
-int	exec_makecmds(struct proc *, struct exec_package *);
-int	exec_runcmds(struct proc *, struct exec_package *);
 void	vmcmdset_extend(struct exec_vmcmd_set *);
 void	kill_vmcmds(struct exec_vmcmd_set *evsp);
 int	vmcmd_map_pagedvn(struct proc *, struct exec_vmcmd *);
 int	vmcmd_map_readvn(struct proc *, struct exec_vmcmd *);
 int	vmcmd_map_zero(struct proc *, struct exec_vmcmd *);
+int	vmcmd_mutable(struct proc *, struct exec_vmcmd *);
 int	vmcmd_randomize(struct proc *, struct exec_vmcmd *);
-void	*copyargs(struct exec_package *,
-				    struct ps_strings *,
-				    void *, void *);
-void	setregs(struct proc *, struct exec_package *,
-				    u_long, register_t *);
+int	copyargs(struct exec_package *, struct ps_strings *, void *, void *);
+void	setregs(struct proc *, struct exec_package *, u_long,
+	    struct ps_strings *);
 int	check_exec(struct proc *, struct exec_package *);
 int	exec_setup_stack(struct proc *, struct exec_package *);
 int	exec_process_vmcmds(struct proc *, struct exec_package *);
@@ -212,7 +204,7 @@ void	new_vmcmd(struct exec_vmcmd_set *evsp,
  * Functions for specific exec types should be defined in their own
  * header file.
  */
-extern struct	execsw execsw[];
+extern const struct	execsw execsw[];
 extern int	nexecs;
 extern int	exec_maxhdrsz;
 
@@ -289,6 +281,7 @@ struct exec {
 #define	MID_MIPS64	158	/* big-endian MIPS64 */
 #define	MID_ARM64	159	/* ARM64 */
 #define	MID_POWERPC64	160	/* big-endian 64-bit PowerPC */
+#define	MID_RISCV64	161	/* Little-endian 64-bit RISC-V */
 #define	MID_HP200	200	/* hp200 (68010) BSD binary */
 #define	MID_HP300	300	/* hp300 (68020+68881) BSD binary */
 #define	MID_HPUX	0x20C	/* hp200/300 HP-UX binary */
diff --git a/sys/sys/exec_elf.h b/sys/sys/exec_elf.h
index 9a1dec6..13ccc82 100644
--- a/sys/sys/exec_elf.h
+++ b/sys/sys/exec_elf.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: exec_elf.h,v 1.88 2020/07/06 13:33:09 pirofti Exp $	*/
+/*	$OpenBSD: exec_elf.h,v 1.97 2022/10/27 23:17:18 deraadt Exp $	*/
 /*
  * Copyright (c) 1995, 1996 Erik Theisen.  All rights reserved.
  *
@@ -191,6 +191,7 @@ typedef struct {
 #define EM_X86_64	EM_AMD64
 #define EM_VAX		75		/* DEC VAX */
 #define EM_AARCH64	183		/* ARM 64-bit architecture (AArch64) */
+#define EM_RISCV	243		/* RISC-V */
 
 /* Non-standard */
 #define EM_ALPHA_EXP	0x9026		/* DEC ALPHA */
@@ -254,7 +255,7 @@ typedef struct {
 #define SHT_DYNAMIC		6	/* dynamic section */
 #define SHT_NOTE		7	/* note section */
 #define SHT_NOBITS		8	/* no space section */
-#define SHT_REL			9	/* relation section without addends */
+#define SHT_REL			9	/* relocation section without addends */
 #define SHT_SHLIB		10	/* reserved - purpose unknown */
 #define SHT_DYNSYM		11	/* dynamic symbol table section */
 #define SHT_NUM			12	/* number of section types */
@@ -263,6 +264,7 @@ typedef struct {
 #define SHT_PREINIT_ARRAY	16	/* ptrs to funcs called before init */
 #define SHT_GROUP		17	/* defines a section group */
 #define SHT_SYMTAB_SHNDX	18	/* Section indexes (see SHN_XINDEX). */
+#define SHT_RELR		19	/* relative-only relocation section */
 #define SHT_LOOS	0x60000000	/* reserved range for OS specific */
 #define SHT_SUNW_dof	0x6ffffff4	/* used by dtrace */
 #define SHT_GNU_LIBLIST	0x6ffffff7	/* libraries to be prelinked */
@@ -303,6 +305,7 @@ typedef struct {
 #define ELF_SYMTAB      ".symtab"	/* symbol table */
 #define ELF_TEXT        ".text"		/* code */
 #define ELF_OPENBSDRANDOMDATA ".openbsd.randomdata" /* constant randomdata */
+#define ELF_OPENBSDMUTABLE ".openbsd.mutable" /* mutable bss */
 
 
 /* Section Attribute Flags - sh_flags */
@@ -427,6 +430,13 @@ typedef struct {
 #define	ELF64_R_INFO(s,t)	(((__uint64_t)swap32(t) << 32) + (__uint32_t)(s))
 #endif	/* __mips64__ && __MIPSEL__ */
 
+/*
+ * Relative Relocation info.
+ * c.f. decode_relrs() in gnu/llvm/llvm/lib/Object/ELF.cpp
+ */
+typedef Elf32_Word	Elf32_Relr;
+typedef Elf64_Xword	Elf64_Relr;
+
 /* Program Header */
 typedef struct {
 	Elf32_Word	p_type;		/* segment type */
@@ -467,6 +477,7 @@ typedef struct {
 #define PT_GNU_EH_FRAME		0x6474e550	/* Exception handling info */
 #define PT_GNU_RELRO		0x6474e552	/* Read-only after relocation */
 
+#define PT_OPENBSD_MUTABLE	0x65a3dbe5	/* like bss, but not immutable */
 #define PT_OPENBSD_RANDOMIZE	0x65a3dbe6	/* fill with random data */
 #define PT_OPENBSD_WXNEEDED	0x65a3dbe7	/* program performs W^X violations */
 #define PT_OPENBSD_BOOTDATA	0x65a41be6	/* section for boot arguments */
@@ -475,9 +486,13 @@ typedef struct {
 #define PF_X		0x1		/* Executable */
 #define PF_W		0x2		/* Writable */
 #define PF_R		0x4		/* Readable */
+#define PF_MASKOS	0x0ff00000	/* reserved bits for OS */
+					/*  specific segment flags */
 #define PF_MASKPROC	0xf0000000	/* reserved bits for processor */
 					/*  specific segment flags */
 
+#define PF_OPENBSD_MUTABLE	0x08000000	/* Mutable */
+
 /* Dynamic structure */
 typedef struct {
 	Elf32_Sword	d_tag;		/* controls meaning of d_val */
@@ -531,6 +546,9 @@ typedef struct {
 #define DT_ENCODING	31		/* further DT_* follow encoding rules */
 #define DT_PREINIT_ARRAY	32	/* address of array of preinit func */
 #define DT_PREINIT_ARRAYSZ	33	/* size of array of preinit func */
+#define DT_RELRSZ	35		/* size of DT_RELR relocation table */
+#define DT_RELR		36		/* addr of DT_RELR relocation table */
+#define DT_RELRENT	37		/* size of DT_RELR relocation entry */
 #define DT_LOOS		0x6000000d	/* reserved range for OS */
 #define DT_HIOS		0x6ffff000	/*  specific dynamic array tags */
 #define DT_LOPROC	0x70000000	/* reserved range for processor */
@@ -564,6 +582,19 @@ typedef struct {
 #define DF_1_NODEFLIB	0x00000800
 #define DF_1_NODUMP	0x00001000
 #define DF_1_CONLFAT	0x00002000
+#define DF_1_ENDFILTEE	0x00004000
+#define DF_1_DISPRELDNE	0x00008000
+#define DF_1_DISPRELPND	0x00010000
+#define DF_1_NODIRECT	0x00020000
+#define DF_1_IGNMULDEF	0x00040000
+#define DF_1_NOKSYMS	0x00080000
+#define DF_1_NOHDR	0x00100000
+#define DF_1_EDITED	0x00200000
+#define DF_1_NORELOC	0x00400000
+#define DF_1_SYMINTPOSE	0x00800000
+#define DF_1_GLOBAUDIT	0x01000000
+#define DF_1_SINGLETON	0x02000000
+#define DF_1_PIE	0x08000000
 
 /*
  * Note header
@@ -614,7 +645,7 @@ typedef struct {
  *	NT_OPENBSD_PROCINFO
  *		Note is a "elfcore_procinfo" structure.
  *	NT_OPENBSD_AUXV
- *		Note is a a bunch of Auxilliary Vectors, terminated by
+ *		Note is a a bunch of Auxiliary Vectors, terminated by
  *		an AT_NULL entry.
  *	NT_OPENBSD_REGS
  *		Note is a "reg" structure.
@@ -685,7 +716,7 @@ enum AuxID {
 	AUX_phent = 4,			/* sizeof(phdr[0]) */
 	AUX_phnum = 5,			/* # phdr entries */
 	AUX_pagesz = 6,			/* PAGESIZE */
-	AUX_base = 7,			/* ld.so base addr */
+	AUX_base = 7,			/* base addr for ld.so or static PIE */
 	AUX_flags = 8,			/* processor flags */
 	AUX_entry = 9,			/* a.out entry */
 	AUX_sun_uid = 2000,		/* euid */
@@ -722,6 +753,7 @@ struct elf_args {
 #define Elf_Sym		Elf32_Sym
 #define Elf_Rel		Elf32_Rel
 #define Elf_RelA	Elf32_Rela
+#define Elf_Relr	Elf32_Relr
 #define Elf_Dyn		Elf32_Dyn
 #define Elf_Half	Elf32_Half
 #define Elf_Word	Elf32_Word
@@ -749,6 +781,7 @@ struct elf_args {
 #define Elf_Sym		Elf64_Sym
 #define Elf_Rel		Elf64_Rel
 #define Elf_RelA	Elf64_Rela
+#define Elf_Relr	Elf64_Relr
 #define Elf_Dyn		Elf64_Dyn
 #define Elf_Half	Elf64_Half
 #define Elf_Word	Elf64_Word
@@ -776,9 +809,17 @@ extern Elf_Dyn		_DYNAMIC[];
 #endif
 
 #ifdef	_KERNEL
+/*
+ * How many entries are in the AuxInfo array we pass to the process?
+ */
+#define	ELF_AUX_ENTRIES	9
+#define	ELF_AUX_WORDS	(sizeof(AuxInfo) * ELF_AUX_ENTRIES / sizeof(char *))
+
 struct exec_package;
 
 int	exec_elf_makecmds(struct proc *, struct exec_package *);
+int	exec_elf_fixup(struct proc *, struct exec_package *);
+int	coredump_elf(struct proc *, void *);
 #endif /* _KERNEL */
 
 #define ELF_TARG_VER	1	/* The ver for which this code is intended */
diff --git a/sys/sys/file.h b/sys/sys/file.h
index f638c15..b29b431 100644
--- a/sys/sys/file.h
+++ b/sys/sys/file.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: file.h,v 1.61 2020/03/13 10:07:01 anton Exp $	*/
+/*	$OpenBSD: file.h,v 1.66 2022/06/20 01:39:44 visa Exp $	*/
 /*	$NetBSD: file.h,v 1.11 1995/03/26 20:24:13 jtc Exp $	*/
 
 /*
@@ -38,7 +38,16 @@
 #else /* _KERNEL */
 #include <sys/queue.h>
 #include <sys/mutex.h>
+#endif /* _KERNEL */
+
+#define	DTYPE_VNODE	1	/* file */
+#define	DTYPE_SOCKET	2	/* communications endpoint */
+#define	DTYPE_PIPE	3	/* pipe */
+#define	DTYPE_KQUEUE	4	/* event queue */
+#define	DTYPE_DMABUF	5	/* DMA buffer (for DRM) */
+#define	DTYPE_SYNC	6	/* sync file (for DRM) */
 
+#ifdef _KERNEL
 struct proc;
 struct uio;
 struct knote;
@@ -57,7 +66,6 @@ struct	fileops {
 	int	(*fo_read)(struct file *, struct uio *, int);
 	int	(*fo_write)(struct file *, struct uio *, int);
 	int	(*fo_ioctl)(struct file *, u_long, caddr_t, struct proc *);
-	int	(*fo_poll)(struct file *, int, struct proc *);
 	int	(*fo_kqfilter)(struct file *, struct knote *);
 	int	(*fo_stat)(struct file *, struct stat *, struct proc *);
 	int	(*fo_close)(struct file *, struct proc *);
@@ -80,11 +88,6 @@ struct file {
 	LIST_ENTRY(file) f_list;/* [F] list of active files */
 	struct mutex f_mtx;
 	u_int	f_flag;		/* [a] see fcntl.h */
-#define	DTYPE_VNODE	1	/* file */
-#define	DTYPE_SOCKET	2	/* communications endpoint */
-#define	DTYPE_PIPE	3	/* pipe */
-#define	DTYPE_KQUEUE	4	/* event queue */
-#define	DTYPE_DMABUF	5	/* DMA buffer (for DRM) */
 	u_int	f_iflags;	/* [a] internal flags */
 	int	f_type;		/* [I] descriptor type */
 	u_int	f_count;	/* [a] reference count */
diff --git a/sys/sys/filedesc.h b/sys/sys/filedesc.h
index f332fb6..a8cb947 100644
--- a/sys/sys/filedesc.h
+++ b/sys/sys/filedesc.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: filedesc.h,v 1.45 2020/07/04 08:06:08 anton Exp $	*/
+/*	$OpenBSD: filedesc.h,v 1.46 2022/05/12 13:33:09 mvs Exp $	*/
 /*	$NetBSD: filedesc.h,v 1.14 1996/04/09 20:55:28 cgd Exp $	*/
 
 /*
@@ -79,8 +79,8 @@ struct filedesc {
 	u_int	*fd_lomap;		/* [f] bitmap of free fds */
 	int	fd_lastfile;		/* [f] high-water mark of fd_ofiles */
 	int	fd_freefile;		/* [f] approx. next free file */
-	u_short	fd_cmask;		/* [f/w] mask for file creation */
-	u_short	fd_refcnt;		/* [K] reference count */
+	mode_t	fd_cmask;		/* [f/w] mask for file creation */
+	u_int	fd_refcnt;		/* [K] reference count */
 	struct rwlock fd_lock;		/* lock for the file descs */
 	struct mutex fd_fplock;		/* lock for reading fd_ofiles without
 					 * fd_lock */
diff --git a/sys/sys/gmon.h b/sys/sys/gmon.h
index 1a63cb5..3e1e77c 100644
--- a/sys/sys/gmon.h
+++ b/sys/sys/gmon.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: gmon.h,v 1.8 2016/05/07 19:30:52 guenther Exp $	*/
+/*	$OpenBSD: gmon.h,v 1.9 2022/01/11 23:59:55 jsg Exp $	*/
 /*	$NetBSD: gmon.h,v 1.5 1996/04/09 20:55:30 cgd Exp $	*/
 
 /*-
@@ -156,7 +156,7 @@ struct gmonparam {
 #define	GPROF_GMONPARAM	4	/* struct: profiling parameters (see above) */
 
 #ifdef _KERNEL
-extern int gmoninit;		/* Is the kernel ready for beeing profiled? */
+extern int gmoninit;		/* Is the kernel ready for being profiled? */
 
 #else /* !_KERNEL */
 
diff --git a/sys/sys/hibernate.h b/sys/sys/hibernate.h
index be09102..75feaeb 100644
--- a/sys/sys/hibernate.h
+++ b/sys/sys/hibernate.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: hibernate.h,v 1.42 2018/06/21 07:33:30 mlarkin Exp $	*/
+/*	$OpenBSD: hibernate.h,v 1.45 2022/01/17 02:54:28 mlarkin Exp $	*/
 
 /*
  * Copyright (c) 2011 Ariane van der Steldt <ariane@stack.nl>
@@ -23,6 +23,9 @@
 #include <sys/tree.h>
 #include <lib/libz/zlib.h>
 #include <machine/vmparam.h>
+#include <crypto/sha2.h>
+
+#define HIB_PHYSSEG_MAX		22
 
 #define HIBERNATE_CHUNK_USED 1
 #define HIBERNATE_CHUNK_CONFLICT 2
@@ -66,7 +69,7 @@ struct hibernate_memory_range {
  */
 struct hibernate_disk_chunk {
 	paddr_t		base;		/* Base of chunk */
-	paddr_t		end;		/* End of chunk */		
+	paddr_t		end;		/* End of chunk */
 	daddr_t		offset;		/* Abs. disk block locating chunk */
 	size_t		compressed_size; /* Compressed size on disk */
 	short		flags;		/* Flags */
@@ -85,21 +88,20 @@ typedef	int (*hibio_fn)(dev_t, daddr_t, vaddr_t, size_t, int, void *);
  */
 union hibernate_info {
 	struct {
-		u_int32_t			magic;	
+		u_int32_t			magic;
+		dev_t				dev;
 		size_t				nranges;
-		struct hibernate_memory_range	ranges[VM_PHYSSEG_MAX];
+		struct hibernate_memory_range	ranges[HIB_PHYSSEG_MAX];
 		size_t				image_size;
 		size_t				chunk_ctr;
-		dev_t				dev;
 		daddr_t				sig_offset;
 		daddr_t				chunktable_offset;
 		daddr_t				image_offset;
 		paddr_t				piglet_pa;
 		vaddr_t				piglet_va;
-		char				kernel_version[128];
-		u_int32_t			kernel_sum;
 		hibio_fn			io_func;
 		void				*io_page;
+		u_int8_t			kern_hash[SHA256_DIGEST_LENGTH];
 #ifndef NO_PROPOLICE
 		long				guard;
 #endif /* ! NO_PROPOLICE */
@@ -138,7 +140,7 @@ int	hibernate_block_io(union hibernate_info *, daddr_t, size_t, vaddr_t, int);
 int	hibernate_write_signature(union hibernate_info *);
 int	hibernate_write_chunktable(union hibernate_info *);
 int	hibernate_write_chunks(union hibernate_info *);
-int	hibernate_clear_signature(void);
+int	hibernate_clear_signature(union hibernate_info *);
 int	hibernate_compare_signature(union hibernate_info *,
 	    union hibernate_info *);
 void	hibernate_resume(void);
diff --git a/sys/sys/kcore.h b/sys/sys/kcore.h
index 4c5662b..bca0459 100644
--- a/sys/sys/kcore.h
+++ b/sys/sys/kcore.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: kcore.h,v 1.1 1996/04/18 21:40:57 niklas Exp $	*/
+/*	$OpenBSD: kcore.h,v 1.2 2023/01/04 10:59:34 jsg Exp $	*/
 /*	$NetBSD: kcore.h,v 1.1 1996/03/10 21:56:00 leo Exp $	*/
 
 /*
@@ -13,11 +13,6 @@
  * 2. Redistributions in binary form must reproduce the above copyright
  *    notice, this list of conditions and the following disclaimer in the
  *    documentation and/or other materials provided with the distribution.
- * 3. All advertising materials mentioning features or use of this software
- *    must display the following acknowledgement:
- *      This product includes software developed by Leo Weppelman.
- * 4. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission
  *
  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
diff --git a/sys/sys/kcov.h b/sys/sys/kcov.h
index a499953..2c357f8 100644
--- a/sys/sys/kcov.h
+++ b/sys/sys/kcov.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: kcov.h,v 1.7 2020/09/26 11:59:59 anton Exp $	*/
+/*	$OpenBSD: kcov.h,v 1.8 2021/12/29 07:15:13 anton Exp $	*/
 
 /*
  * Copyright (c) 2018 Anton Lindqvist <anton@openbsd.org>
@@ -42,6 +42,7 @@ struct kio_remote_attach {
 struct proc;
 
 void kcov_exit(struct proc *);
+int kcov_vnode(struct vnode *);
 void kcov_remote_register(int, void *);
 void kcov_remote_unregister(int, void *);
 void kcov_remote_enter(int, void *);
diff --git a/sys/sys/kernel.h b/sys/sys/kernel.h
index 73aa8c3..0147fde 100644
--- a/sys/sys/kernel.h
+++ b/sys/sys/kernel.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: kernel.h,v 1.23 2020/05/20 17:24:17 cheloha Exp $	*/
+/*	$OpenBSD: kernel.h,v 1.26 2023/03/03 20:16:44 cheloha Exp $	*/
 /*	$NetBSD: kernel.h,v 1.11 1995/03/03 01:24:16 cgd Exp $	*/
 
 /*-
@@ -51,13 +51,12 @@ extern int utc_offset;		/* seconds east of UTC */
 
 extern int tick;		/* usec per tick (1000000 / hz) */
 extern int tick_nsec;		/* nsec per tick */
-extern int tickfix;		/* periodic tick adj. tick not integral */
-extern int tickfixinterval;	/* interval at which to apply adjustment */
-extern int tickadj;		/* "standard" clock skew, us./tick */
 extern int ticks;		/* # of hardclock ticks */
 extern int hz;			/* system clock's frequency */
 extern int stathz;		/* statistics clock's frequency */
 extern int profhz;		/* profiling clock's frequency */
 extern int lbolt;		/* once a second sleep address */
-extern int tickdelta;
-extern long timedelta;
+
+#ifndef HZ
+#define HZ 100
+#endif
diff --git a/sys/sys/kstat.h b/sys/sys/kstat.h
index 4564810..9e8baba 100644
--- a/sys/sys/kstat.h
+++ b/sys/sys/kstat.h
@@ -1,4 +1,4 @@
-/* $OpenBSD: kstat.h,v 1.1 2020/07/06 03:56:51 dlg Exp $ */
+/* $OpenBSD: kstat.h,v 1.3 2022/04/22 00:27:55 dlg Exp $ */
 
 /*
  * Copyright (c) 2020 David Gwynne <dlg@openbsd.org>
@@ -79,6 +79,9 @@ enum kstat_kv_type {
 	KSTAT_KV_T_STR,		/* trailing string */
 	KSTAT_KV_T_BYTES,	/* trailing bytes */
 	KSTAT_KV_T_TEMP,	/* temperature (uK) */
+	KSTAT_KV_T_COUNTER16,
+	KSTAT_KV_T_UINT16,
+	KSTAT_KV_T_INT16,
 };
 
 /* units only apply to integer types */
@@ -98,6 +101,8 @@ struct kstat_kv {
 		int64_t			v_s64;
 		uint32_t		v_u32;
 		int32_t			v_s32;
+		uint16_t		v_u16;
+		int16_t			v_s16;
 		size_t			v_len;
 	}			 kv_v;
 	enum kstat_kv_type	 kv_type;
@@ -110,6 +115,8 @@ struct kstat_kv {
 #define kstat_kv_s64(_kv)	(_kv)->kv_v.v_s64
 #define kstat_kv_u32(_kv)	(_kv)->kv_v.v_u32
 #define kstat_kv_s32(_kv)	(_kv)->kv_v.v_s32
+#define kstat_kv_u16(_kv)	(_kv)->kv_v.v_u16
+#define kstat_kv_s16(_kv)	(_kv)->kv_v.v_s16
 #define kstat_kv_len(_kv)	(_kv)->kv_v.v_len
 #define kstat_kv_temp(_kv)	(_kv)->kv_v.v_u64
 
@@ -169,6 +176,7 @@ void		 kstat_set_cpu(struct kstat *, struct cpu_info *);
 int		 kstat_read_nop(struct kstat *);
 
 void		 kstat_install(struct kstat *);
+void		 kstat_remove(struct kstat *);
 void		 kstat_destroy(struct kstat *);
 
 /*
diff --git a/sys/sys/ktrace.h b/sys/sys/ktrace.h
index 78bd64d..e76652e 100644
--- a/sys/sys/ktrace.h
+++ b/sys/sys/ktrace.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: ktrace.h,v 1.39 2020/09/14 07:15:25 mpi Exp $	*/
+/*	$OpenBSD: ktrace.h,v 1.46 2023/02/23 01:33:20 deraadt Exp $	*/
 /*	$NetBSD: ktrace.h,v 1.12 1996/02/04 02:12:29 christos Exp $	*/
 
 /*
@@ -33,6 +33,9 @@
  */
 
 #include <sys/uio.h>
+#include <sys/syslimits.h>
+#include <sys/signal.h>
+#include <sys/time.h>
 
 /*
  * operations to ktrace system call  (KTROP(op))
@@ -54,7 +57,7 @@ struct ktr_header {
 	pid_t	ktr_pid;		/* process id */
 	pid_t	ktr_tid;		/* thread id */
 	struct	timespec ktr_time;	/* timestamp */
-	char	ktr_comm[MAXCOMLEN+1];	/* command name */
+	char	ktr_comm[_MAXCOMLEN];	/* command name, incl NUL */
 	size_t	ktr_len;		/* length of buf */
 };
 
@@ -73,6 +76,8 @@ struct ktr_header {
 #define KTR_SYSCALL	1
 struct ktr_syscall {
 	int	ktr_code;		/* syscall number */
+#define KTRC_CODE_MASK			0x0000ffff
+#define KTRC_CODE_SYSCALL		0x20000000
 	int	ktr_argsize;		/* size of arguments */
 	/*
 	 * followed by ktr_argsize/sizeof(register_t) "register_t"s
@@ -147,7 +152,7 @@ struct ktr_user {
 };
 
 /*
- * KTR_EXECARGS and KTR_EXECENV - args and evironment records
+ * KTR_EXECARGS and KTR_EXECENV - args and environment records
  */
 #define KTR_EXECARGS	10
 #define KTR_EXECENV	11
@@ -238,6 +243,8 @@ void    ktrstruct(struct proc *, const char *, const void *, size_t);
 	ktrstruct((p), "quota", (s), sizeof(struct dqblk))
 #define ktrmsghdr(p, s) \
 	ktrstruct(p, "msghdr", s, sizeof(struct msghdr))
+#define ktrmmsghdr(p, s) \
+	ktrstruct(p, "mmsghdr", s, sizeof(struct mmsghdr))
 #define ktriovec(p, s, count) \
 	ktrstruct(p, "iovec", s, (count) * sizeof(struct iovec))
 #define ktrcmsghdr(p, c, len) \
@@ -250,5 +257,7 @@ void    ktrstruct(struct proc *, const char *, const void *, size_t);
 	ktrstruct(p, "fds", fds, (count) * sizeof(int))
 #define ktrflock(p, fl) \
 	ktrstruct(p, "flock", (fl), sizeof(struct flock))
+#define ktrsiginfo(p, si) \
+	ktrstruct(p, "siginfo", (si), sizeof(siginfo_t))
 
 #endif	/* !_KERNEL */
diff --git a/sys/sys/malloc.h b/sys/sys/malloc.h
index ff8e09b..97bf9ff 100644
--- a/sys/sys/malloc.h
+++ b/sys/sys/malloc.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: malloc.h,v 1.119 2019/11/28 16:23:11 guenther Exp $	*/
+/*	$OpenBSD: malloc.h,v 1.122 2022/02/03 17:18:22 guenther Exp $	*/
 /*	$NetBSD: malloc.h,v 1.39 1998/07/12 19:52:01 augustss Exp $	*/
 
 /*
@@ -72,7 +72,7 @@
 /* 7 - free */
 /* 8 - free */
 #define	M_IFADDR	9	/* interface address */
-#define	M_SOOPTS	10	/* socket options */
+/* 10 - free */
 #define	M_SYSCTL	11	/* sysctl buffers (persistent storage) */
 #define	M_COUNTERS	12	/* per CPU counters */
 /* 13 - free */
@@ -83,9 +83,9 @@
 /* 21 - free */
 #define	M_NFSREQ	22	/* NFS request header */
 #define	M_NFSMNT	23	/* NFS mount structure */
-/* 24 - free */
+#define	M_LOG		24	/* Messages in kernel log stash */
 #define	M_VNODE		25	/* Dynamically allocated vnodes */
-#define	M_CACHE		26	/* Dynamically allocated cache entries */
+/* 26 - free */
 #define	M_DQUOT		27	/* UFS quota entries */
 #define	M_UFSMNT	28	/* UFS mount structure */
 #define	M_SHM		29	/* SVID compatible shared memory segments */
@@ -94,14 +94,12 @@
 #define	M_DIRHASH	32	/* UFS dirhash */
 #define M_ACPI		33	/* ACPI */
 #define	M_VMPMAP	34	/* VM pmap */
-/* 35-37 - free */
-#define	M_FILE		38	/* Open file structure */
+/* 35-38 - free */
 #define	M_FILEDESC	39	/* Open file descriptor table */
 #define	M_SIGIO		40	/* Sigio structures */
 #define	M_PROC		41	/* Proc structures */
 #define	M_SUBPROC	42	/* Proc sub-structures */
-#define	M_VCLUSTER	43	/* Cluster for VFS */
-/* 45-46 - free */
+/* 43-45 - free */
 #define	M_MFSNODE	46	/* MFS vnode private part */
 /* 47-48 - free */
 #define	M_NETADDR	49	/* Export host address structure */
@@ -146,9 +144,7 @@
 #define M_CRYPTO_DATA	108	/* Crypto framework data buffers (keys etc.) */
 /* 109 - free */
 #define M_CREDENTIALS	110	/* IPsec-related credentials and ID info */
-/* 111-113 - free */
-#define	M_EMULDATA	114	/* Per-process emulation data */
-/* 115-122 - free */
+/* 111-122 - free */
 
 /* KAME IPv6 */
 #define	M_IP6OPT	123	/* IPv6 options */
@@ -194,7 +190,7 @@
 	NULL, \
 	NULL, \
 	"ifaddr",	/* 9 M_IFADDR */ \
-	"soopts",	/* 10 M_SOOPTS */ \
+	NULL, \
 	"sysctl",	/* 11 M_SYSCTL */ \
 	"counters",	/* 12 M_COUNTERS */ \
 	NULL, \
@@ -208,9 +204,9 @@
 	NULL, \
 	"NFS req",	/* 22 M_NFSREQ */ \
 	"NFS mount",	/* 23 M_NFSMNT */ \
-	NULL, \
+	"log",		/* 24 M_LOG */ \
 	"vnodes",	/* 25 M_VNODE */ \
-	"namecache",	/* 26 M_CACHE */ \
+	NULL, \
 	"UFS quota",	/* 27 M_DQUOT */ \
 	"UFS mount",	/* 28 M_UFSMNT */ \
 	"shm",		/* 29 M_SHM */ \
@@ -222,12 +218,12 @@
 	NULL,	/* 35 */ \
 	NULL,	/* 36 */ \
 	NULL,	/* 37 */ \
-	"file",		/* 38 M_FILE */ \
+	NULL, \
 	"file desc",	/* 39 M_FILEDESC */ \
 	"sigio",	/* 40 M_SIGIO */ \
 	"proc",		/* 41 M_PROC */ \
 	"subproc",	/* 42 M_SUBPROC */ \
-	"VFS cluster",	/* 43 M_VCLUSTER */ \
+	NULL, \
 	NULL, \
 	NULL, \
 	"MFS node",	/* 46 M_MFSNODE */ \
@@ -285,10 +281,7 @@
 	"crypto data",	/* 108 M_CRYPTO_DATA */ \
 	NULL, \
 	"IPsec creds",	/* 110 M_CREDENTIALS */ \
-	NULL, \
-	NULL, \
-	NULL, \
-	"emuldata",	/* 114 M_EMULDATA */ \
+	NULL, NULL, NULL, NULL, \
 	NULL, NULL, NULL, NULL, \
 	NULL, NULL, NULL, NULL, \
 	"ip6_options",	/* 123 M_IP6OPT */ \
@@ -395,7 +388,6 @@ void	free(void *, int, size_t);
 int	sysctl_malloc(int *, u_int, void *, size_t *, void *, size_t,
 	    struct proc *);
 
-size_t malloc_roundup(size_t);
 void	malloc_printit(int (*)(const char *, ...));
 
 void	poison_mem(void *, size_t);
diff --git a/sys/sys/mbuf.h b/sys/sys/mbuf.h
index 5b1c711..f8eae7a 100644
--- a/sys/sys/mbuf.h
+++ b/sys/sys/mbuf.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: mbuf.h,v 1.250 2020/08/08 19:53:02 florian Exp $	*/
+/*	$OpenBSD: mbuf.h,v 1.255 2022/08/15 16:15:37 bluhm Exp $	*/
 /*	$NetBSD: mbuf.h,v 1.19 1996/02/09 18:25:14 christos Exp $	*/
 
 /*
@@ -312,7 +312,7 @@ struct mbuf {
 } while (/* CONSTCOND */ 0)
 
 #define MCLGET(m, how) (void) m_clget((m), (how), MCLBYTES)
-#define MCLGETI(m, how, ifp, l) m_clget((m), (how), (l))
+#define MCLGETL(m, how, l) m_clget((m), (how), (l))
 
 u_int mextfree_register(void (*)(caddr_t, u_int, void *));
 #define	MEXTFREE_POOL 0
@@ -429,13 +429,14 @@ void	m_align(struct mbuf *, int);
 struct mbuf *m_clget(struct mbuf *, int, u_int);
 void	m_extref(struct mbuf *, struct mbuf *);
 void	m_pool_init(struct pool *, u_int, u_int, const char *);
+u_int	m_pool_used(void);
 void	m_extfree_pool(caddr_t, u_int, void *);
 void	m_adj(struct mbuf *, int);
 int	m_copyback(struct mbuf *, int, int, const void *, int);
 struct mbuf *m_freem(struct mbuf *);
 void	m_purge(struct mbuf *);
 void	m_reclaim(void *, int);
-void	m_copydata(struct mbuf *, int, int, caddr_t);
+void	m_copydata(struct mbuf *, int, int, void *);
 void	m_cat(struct mbuf *, struct mbuf *);
 struct mbuf *m_devget(char *, int, int);
 int	m_apply(struct mbuf *, int, int,
@@ -469,6 +470,7 @@ struct m_tag *m_tag_next(struct mbuf *, struct m_tag *);
 /* Packet tag types */
 #define PACKET_TAG_IPSEC_IN_DONE	0x0001  /* IPsec applied, in */
 #define PACKET_TAG_IPSEC_OUT_DONE	0x0002  /* IPsec applied, out */
+#define PACKET_TAG_IPSEC_FLOWINFO	0x0004	/* IPsec flowinfo */
 #define PACKET_TAG_WIREGUARD		0x0040  /* WireGuard data */
 #define PACKET_TAG_GRE			0x0080  /* GRE processing done */
 #define PACKET_TAG_DLT			0x0100 /* data link layer type */
@@ -477,9 +479,10 @@ struct m_tag *m_tag_next(struct mbuf *, struct m_tag *);
 #define PACKET_TAG_SRCROUTE		0x1000 /* IPv4 source routing options */
 #define PACKET_TAG_TUNNEL		0x2000	/* Tunnel endpoint address */
 #define PACKET_TAG_CARP_BAL_IP		0x4000  /* carp(4) ip balanced marker */
+#define PACKET_TAG_IP6_OFFNXT		0x8000  /* IPv6 offset and next proto */
 
 #define MTAG_BITS \
-    ("\20\1IPSEC_IN_DONE\2IPSEC_OUT_DONE\3IPSEC_IN_CRYPTO_DONE" \
+    ("\20\1IPSEC_IN_DONE\2IPSEC_OUT_DONE\3IPSEC_FLOWINFO" \
     "\4IPSEC_OUT_CRYPTO_NEEDED\5IPSEC_PENDING_TDB\6BRIDGE\7WG\10GRE\11DLT" \
     "\12PF_DIVERT\14PF_REASSEMBLED\15SRCROUTE\16TUNNEL\17CARP_BAL_IP")
 
diff --git a/sys/sys/mman.h b/sys/sys/mman.h
index 47972b5..c36687f 100644
--- a/sys/sys/mman.h
+++ b/sys/sys/mman.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: mman.h,v 1.34 2019/03/01 01:46:18 cheloha Exp $	*/
+/*	$OpenBSD: mman.h,v 1.35 2022/10/07 14:59:39 deraadt Exp $	*/
 /*	$NetBSD: mman.h,v 1.11 1995/03/26 20:24:23 jtc Exp $	*/
 
 /*-
@@ -154,6 +154,7 @@ int	munlockall(void);
 #if __BSD_VISIBLE
 int	madvise(void *, size_t, int);
 int	minherit(void *, size_t, int);
+int	mimmutable(void *, size_t);
 void *	mquery(void *, size_t, int, int, int, off_t);
 #endif
 int	posix_madvise(void *, size_t, int);
diff --git a/sys/sys/mount.h b/sys/sys/mount.h
index cdf31d3..40c12e9 100644
--- a/sys/sys/mount.h
+++ b/sys/sys/mount.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: mount.h,v 1.147 2020/01/18 08:40:19 visa Exp $	*/
+/*	$OpenBSD: mount.h,v 1.148 2021/04/06 14:17:35 kn Exp $	*/
 /*	$NetBSD: mount.h,v 1.48 1996/02/18 11:55:47 fvdl Exp $	*/
 
 /*
@@ -387,7 +387,9 @@ struct mount {
 #define	MNT_BITS \
     "\20\001RDONLY\002SYNCHRONOUS\003NOEXEC\004NOSUID\005NODEV\006NOPERM" \
     "\007ASYNC\010EXRDONLY\011EXPORTED\012DEFEXPORTED\013EXPORTANON" \
-    "\014WXALLOWED\015LOCAL\016QUOTA\017ROOTFS\020NOATIME"
+    "\014WXALLOWED\015LOCAL\016QUOTA\017ROOTFS\020NOATIME\021UPDATE" \
+    "\022DELEXPORT\023RELOAD\024FORCE\025STALLED\026SWAPPABLE\032WANTRDWR" \
+    "\033SOFTDEP\034DOOMED"
 
 /*
  * filesystem control flags.
diff --git a/sys/sys/msg.h b/sys/sys/msg.h
index 96a4a0c..d7ebe46 100644
--- a/sys/sys/msg.h
+++ b/sys/sys/msg.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: msg.h,v 1.19 2014/11/23 04:31:42 guenther Exp $	*/
+/*	$OpenBSD: msg.h,v 1.20 2022/09/16 15:57:23 mbuhl Exp $	*/
 /*	$NetBSD: msg.h,v 1.9 1996/02/09 18:25:18 christos Exp $	*/
 
 /*
@@ -169,9 +169,6 @@ __END_DECLS
 struct proc;
 
 void	msginit(void);
-int	msgctl1(struct proc *, int, int, caddr_t,
-	    int (*)(const void *, void *, size_t),
-	    int (*)(const void *, void *, size_t));
 #endif /* !_KERNEL */
 
 #endif /* !_SYS_MSG_H_ */
diff --git a/sys/sys/msgbuf.h b/sys/sys/msgbuf.h
index 398304a..62be72c 100644
--- a/sys/sys/msgbuf.h
+++ b/sys/sys/msgbuf.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: msgbuf.h,v 1.12 2020/08/18 13:38:24 visa Exp $	*/
+/*	$OpenBSD: msgbuf.h,v 1.13 2020/10/25 10:55:42 visa Exp $	*/
 /*	$NetBSD: msgbuf.h,v 1.8 1995/03/26 20:24:27 jtc Exp $	*/
 
 /*
@@ -32,14 +32,20 @@
  *	@(#)msgbuf.h	8.1 (Berkeley) 6/2/93
  */
 
+/*
+ * Locking:
+ *	I	immutable after creation
+ *	L	log_mtx
+ *	Lw	log_mtx for writing
+ */
 struct	msgbuf {
 #define	MSG_MAGIC	0x063061
-	long	msg_magic;
-	long	msg_bufx;		/* write pointer */
-	long	msg_bufr;		/* read pointer */
-	long	msg_bufs;		/* real msg_bufc size (bytes) */
-	long	msg_bufd;		/* number of dropped bytes */
-	char	msg_bufc[1];		/* buffer */
+	long	msg_magic;		/* [I] buffer magic value */
+	long	msg_bufx;		/* [L] write pointer */
+	long	msg_bufr;		/* [L] read pointer */
+	long	msg_bufs;		/* [I] real msg_bufc size (bytes) */
+	long	msg_bufd;		/* [L] number of dropped bytes */
+	char	msg_bufc[1];		/* [Lw] buffer */
 };
 #ifdef _KERNEL
 #define CONSBUFSIZE	(16 * 1024)	/* console message buffer size */
diff --git a/sys/sys/namei.h b/sys/sys/namei.h
index 975dfa9..98ec368 100644
--- a/sys/sys/namei.h
+++ b/sys/sys/namei.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: namei.h,v 1.45 2020/03/19 13:55:20 anton Exp $	*/
+/*	$OpenBSD: namei.h,v 1.50 2022/01/11 23:59:55 jsg Exp $	*/
 /*	$NetBSD: namei.h,v 1.11 1996/02/09 18:25:20 christos Exp $	*/
 
 /*
@@ -75,14 +75,10 @@ struct nameidata {
 	char	*ni_next;		/* next location in pathname */
 	u_long	ni_loopcnt;		/* count of symlinks encountered */
 	struct unveil *ni_unveil_match; /* last matching unveil component */
-	struct vnode **ni_tvp;		/* traversed vnodes */
-	size_t ni_tvpend;		/* end of traversed vnode list */
-	size_t ni_tvpsize;		/* size of traversed vnode list */
-	int ni_unveil_eacces;		/* indicates unveil flag mismatch */
 
 	/*
 	 * Lookup parameters: this structure describes the subset of
-	 * information from the nameidat satructure that is passed
+	 * information from the nameidata structure that is passed
 	 * through the VOP interface.
 	 */
 	struct componentname {
@@ -141,7 +137,7 @@ struct nameidata {
 #define	NOCROSSMOUNT	0x000100      /* do not cross mount points */
 #define	RDONLY		0x000200      /* lookup with read-only semantics */
 #define	HASBUF		0x000400      /* has allocated pathname buffer */
-#define	SAVENAME	0x000800      /* save pathanme buffer */
+#define	SAVENAME	0x000800      /* save pathname buffer */
 #define	SAVESTART	0x001000      /* save starting directory */
 #define ISDOTDOT	0x002000      /* current component name is .. */
 #define MAKEENTRY	0x004000      /* entry is to be added to name cache */
@@ -208,7 +204,6 @@ void cache_purgevfs(struct mount *);
 
 int unveil_add(struct proc *, struct nameidata *, const char *);
 void unveil_removevnode(struct vnode *);
-void unveil_free_traversed_vnodes(struct nameidata *);
 ssize_t unveil_find_cover(struct vnode *, struct proc *);
 struct unveil *unveil_lookup(struct vnode *, struct process *, ssize_t *);
 void unveil_start_relative(struct proc *, struct nameidata *, struct vnode *);
@@ -273,7 +268,7 @@ struct	nchstats {
 #define	UNVEIL_WRITE	0x02
 #define	UNVEIL_CREATE	0x04
 #define	UNVEIL_EXEC	0x08
-#define	UNVEIL_USERSET	0x0F
-#define	UNVEIL_INSPECT	0x80
+#define	UNVEIL_USERSET	0x10
+#define	UNVEIL_MASK	0x0F
 
 #endif /* !_SYS_NAMEI_H_ */
diff --git a/sys/sys/param.h b/sys/sys/param.h
index 579c4c9..f1d695b 100644
--- a/sys/sys/param.h
+++ b/sys/sys/param.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: param.h,v 1.131 2020/08/31 16:08:28 deraadt Exp $	*/
+/*	$OpenBSD: param.h,v 1.140 2023/03/04 14:49:37 deraadt Exp $	*/
 
 /*-
  * Copyright (c) 1982, 1986, 1989, 1993
@@ -41,8 +41,8 @@
 #define BSD4_3	1
 #define BSD4_4	1
 
-#define OpenBSD	202010		/* OpenBSD version (year & month). */
-#define OpenBSD6_8 1		/* OpenBSD 6.8 */
+#define OpenBSD	202304		/* OpenBSD version (year & month). */
+#define OpenBSD7_3 1		/* OpenBSD 7.3 */
 
 #include <sys/_null.h>
 
@@ -59,7 +59,7 @@
  */
 #include <sys/syslimits.h>
 
-#define	MAXCOMLEN	16		/* max command name remembered */
+#define	MAXCOMLEN	_MAXCOMLEN-1	/* max command name remembered, without NUL */
 #define	MAXINTERP	128		/* max interpreter file name length */
 #define	MAXLOGNAME	LOGIN_NAME_MAX	/* max login name length w/ NUL */
 #define	MAXUPRC		CHILD_MAX	/* max simultaneous processes */
@@ -109,7 +109,7 @@
 
 #define	PRIMASK		0x0ff
 #define	PCATCH		0x100	/* OR'd with pri for tsleep to check signals */
-#define PNORELOCK	0x200	/* OR'd with pri for msleep to not reaquire
+#define PNORELOCK	0x200	/* OR'd with pri for msleep to not reacquire
 				   the mutex */
 #endif /* _KERNEL */
 
diff --git a/sys/sys/pipe.h b/sys/sys/pipe.h
index 72822aa..06146f4 100644
--- a/sys/sys/pipe.h
+++ b/sys/sys/pipe.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pipe.h,v 1.27 2020/06/29 18:23:18 anton Exp $	*/
+/*	$OpenBSD: pipe.h,v 1.29 2022/07/09 12:48:21 visa Exp $	*/
 
 /*
  * Copyright (c) 1996 John S. Dyson
@@ -26,9 +26,9 @@
 
 #ifndef _KERNEL
 #include <sys/time.h>			/* for struct timespec */
-#include <sys/selinfo.h>		/* for struct selinfo */
 #endif /* _KERNEL */
 
+#include <sys/event.h>			/* for struct klist */
 #include <sys/sigio.h>			/* for struct sigio_ref */
 
 /*
@@ -62,7 +62,6 @@ struct pipebuf {
 #define PIPE_WANTR	0x008	/* Reader wants some characters. */
 #define PIPE_WANTW	0x010	/* Writer wants space to put characters. */
 #define PIPE_WANTD	0x020	/* Pipe is wanted to be run-down. */
-#define PIPE_SEL	0x040	/* Pipe has a select active. */
 #define PIPE_EOF	0x080	/* Pipe is in EOF condition. */
 #define PIPE_LOCK	0x100	/* Thread has exclusive I/O access. */
 #define PIPE_LWANT	0x200	/* Thread wants exclusive I/O access. */
@@ -81,7 +80,7 @@ struct pipe_pair;
 struct pipe {
 	struct	rwlock *pipe_lock;
 	struct	pipebuf pipe_buffer;	/* [p] data storage */
-	struct	selinfo pipe_sel;	/* [p] for compat with select */
+	struct	klist pipe_klist;	/* [p] list of knotes */
 	struct	timespec pipe_atime;	/* [p] time of last access */
 	struct	timespec pipe_mtime;	/* [p] time of last modify */
 	struct	timespec pipe_ctime;	/* [I] time of status change */
diff --git a/sys/sys/pledge.h b/sys/sys/pledge.h
index 6dce461..6098fb7 100644
--- a/sys/sys/pledge.h
+++ b/sys/sys/pledge.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pledge.h,v 1.41 2020/04/05 07:31:45 visa Exp $	*/
+/*	$OpenBSD: pledge.h,v 1.47 2022/09/01 05:40:46 jsg Exp $	*/
 
 /*
  * Copyright (c) 2015 Nicholas Marriott <nicm@openbsd.org>
@@ -69,49 +69,48 @@
  * to track program behaviours which have been observed.
  */
 #define PLEDGE_USERSET	0x0fffffffffffffffULL
-#define PLEDGE_YPACTIVE	0x8000000000000000ULL	/* YP use detected and allowed */
 
 #ifdef PLEDGENAMES
 static const struct {
 	uint64_t	bits;
 	const char	*name;
 } pledgenames[] = {
+	{ PLEDGE_STDIO,		"stdio" },
 	{ PLEDGE_RPATH,		"rpath" },
 	{ PLEDGE_WPATH,		"wpath" },
 	{ PLEDGE_CPATH,		"cpath" },
-	{ PLEDGE_STDIO,		"stdio" },
+	{ PLEDGE_DPATH,		"dpath" },
 	{ PLEDGE_TMPPATH,	"tmppath" },
-	{ PLEDGE_DNS,		"dns" },
 	{ PLEDGE_INET,		"inet" },
+	{ PLEDGE_MCAST,		"mcast" },
+	{ PLEDGE_FATTR,		"fattr" },
+	{ PLEDGE_CHOWNUID,	"chown" },
 	{ PLEDGE_FLOCK,		"flock" },
 	{ PLEDGE_UNIX,		"unix" },
-	{ PLEDGE_ID,		"id" },
-	{ PLEDGE_TAPE,		"tape" },
+	{ PLEDGE_DNS,		"dns" },
 	{ PLEDGE_GETPW,		"getpw" },
-	{ PLEDGE_PROC,		"proc" },
-	{ PLEDGE_SETTIME,	"settime" },
-	{ PLEDGE_FATTR,		"fattr" },
-	{ PLEDGE_PROTEXEC,	"prot_exec" },
-	{ PLEDGE_TTY,		"tty" },
 	{ PLEDGE_SENDFD,	"sendfd" },
 	{ PLEDGE_RECVFD,	"recvfd" },
+	{ PLEDGE_TAPE,		"tape" },
+	{ PLEDGE_TTY,		"tty" },
+	{ PLEDGE_PROC,		"proc" },
 	{ PLEDGE_EXEC,		"exec" },
-	{ PLEDGE_ROUTE,		"route" },
-	{ PLEDGE_MCAST,		"mcast" },
-	{ PLEDGE_VMINFO,	"vminfo" },
+	{ PLEDGE_PROTEXEC,	"prot_exec" },
+	{ PLEDGE_SETTIME,	"settime" },
 	{ PLEDGE_PS,		"ps" },
-	{ PLEDGE_DISKLABEL,	"disklabel" },
+	{ PLEDGE_VMINFO,	"vminfo" },
+	{ PLEDGE_ID,		"id" },
 	{ PLEDGE_PF,		"pf" },
+	{ PLEDGE_ROUTE,		"route" },
+	{ PLEDGE_WROUTE,	"wroute" },
 	{ PLEDGE_AUDIO,		"audio" },
-	{ PLEDGE_DPATH,		"dpath" },
-	{ PLEDGE_DRM,		"drm" },
-	{ PLEDGE_VMM,		"vmm" },
-	{ PLEDGE_CHOWNUID,	"chown" },
+	{ PLEDGE_VIDEO,		"video" },
 	{ PLEDGE_BPF,		"bpf" },
-	{ PLEDGE_ERROR,		"error" },
-	{ PLEDGE_WROUTE,	"wroute" },
 	{ PLEDGE_UNVEIL,	"unveil" },
-	{ PLEDGE_VIDEO,		"video" },
+	{ PLEDGE_ERROR,		"error" },
+	{ PLEDGE_DISKLABEL,	"disklabel" },
+	{ PLEDGE_DRM,		"drm" },
+	{ PLEDGE_VMM,		"vmm" },
 	{ 0, NULL },
 };
 #endif
@@ -137,10 +136,9 @@ int	pledge_ioctl_drm(struct proc *p, long com, dev_t device);
 int	pledge_ioctl_vmm(struct proc *p, long com);
 int	pledge_flock(struct proc *p);
 int	pledge_fcntl(struct proc *p, int cmd);
-int	pledge_swapctl(struct proc *p);
+int	pledge_swapctl(struct proc *p, int cmd);
 int	pledge_kill(struct proc *p, pid_t pid);
 int	pledge_protexec(struct proc *p, int prot);
-void	ppath_destroy(struct process *ps);
 
 #endif /* _KERNEL */
 
diff --git a/sys/sys/pool.h b/sys/sys/pool.h
index 7f68d50..3e64c3c 100644
--- a/sys/sys/pool.h
+++ b/sys/sys/pool.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pool.h,v 1.77 2019/07/19 09:03:03 bluhm Exp $	*/
+/*	$OpenBSD: pool.h,v 1.78 2021/01/02 03:23:59 cheloha Exp $	*/
 /*	$NetBSD: pool.h,v 1.27 2001/06/06 22:00:17 rafal Exp $	*/
 
 /*-
@@ -201,9 +201,9 @@ struct pool {
 	u_int		pr_cache_items;	/* target list length */
 	u_int		pr_cache_contention;
 	u_int		pr_cache_contention_prev;
-	int		pr_cache_tick;	/* time idle list was empty */
-	int		pr_cache_nout;
+	uint64_t	pr_cache_timestamp;	/* time idle list was empty */
 	uint64_t	pr_cache_ngc;	/* # of times the gc released a list */
+	int		pr_cache_nout;
 
 	u_int		pr_align;
 	u_int		pr_maxcolors;	/* Cache coloring */
diff --git a/sys/sys/proc.h b/sys/sys/proc.h
index 257175a..d014a55 100644
--- a/sys/sys/proc.h
+++ b/sys/sys/proc.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: proc.h,v 1.300 2020/09/16 08:01:15 mpi Exp $	*/
+/*	$OpenBSD: proc.h,v 1.339 2023/01/16 07:09:11 guenther Exp $	*/
 /*	$NetBSD: proc.h,v 1.44 1996/04/22 01:23:21 christos Exp $	*/
 
 /*-
@@ -85,37 +85,6 @@ struct	pgrp {
 	int	pg_jobc;	/* # procs qualifying pgrp for job control */
 };
 
-/*
- * One structure allocated per emulation.
- */
-struct exec_package;
-struct proc;
-struct ps_strings;
-struct uvm_object;
-union sigval;
-
-struct	emul {
-	char	e_name[8];		/* Symbolic name */
-	int	*e_errno;		/* Errno array */
-	int	e_nosys;		/* Offset of the nosys() syscall */
-	int	e_nsysent;		/* Number of system call entries */
-	struct sysent *e_sysent;	/* System call array */
-	char	**e_syscallnames;	/* System call name array */
-	int	e_arglen;		/* Extra argument size in words */
-					/* Copy arguments on the stack */
-	void	*(*e_copyargs)(struct exec_package *, struct ps_strings *,
-				    void *, void *);
-					/* Set registers before execution */
-	void	(*e_setregs)(struct proc *, struct exec_package *,
-				  u_long, register_t *);
-	int	(*e_fixup)(struct proc *, struct exec_package *);
-	int	(*e_coredump)(struct proc *, void *cookie);
-	char	*e_sigcode;		/* Start of sigcode */
-	char	*e_esigcode;		/* End of sigcode */
-	char	*e_esigret;		/* sigaction RET position */
-	struct uvm_object *e_sigobject;	/* shared sigcode object */
-};
-
 /*
  * time usage: accumulated times in ticks
  * Once a second, each thread's immediate counts (p_[usi]ticks) are
@@ -143,12 +112,14 @@ struct tusage {
 #ifdef __need_process
 struct futex;
 LIST_HEAD(futex_list, futex);
+struct proc;
 struct tslpentry;
 TAILQ_HEAD(tslpqueue, tslpentry);
 struct unveil;
 
 /*
  * Locks used to protect struct members in this file:
+ *	I	immutable after creation
  *	a	atomic operations
  *	K	kernel lock
  *	m	this process' `ps_mtx'
@@ -167,7 +138,7 @@ struct process {
 	struct	ucred *ps_ucred;	/* Process owner's identity. */
 
 	LIST_ENTRY(process) ps_list;	/* List of all processes. */
-	TAILQ_HEAD(,proc) ps_threads;	/* Threads in this process. */
+	TAILQ_HEAD(,proc) ps_threads;	/* [K|S] Threads in this process. */
 
 	LIST_ENTRY(process) ps_pglist;	/* List of processes in pgrp. */
 	struct	process *ps_pptr; 	/* Pointer to parent process. */
@@ -185,7 +156,7 @@ struct process {
 	LIST_HEAD(, process) ps_orphans;/* Pointer to list of orphans. */
 
 	struct	sigiolst ps_sigiolst;	/* List of sigio structures. */
-	struct	sigacts *ps_sigacts;	/* Signal actions, state */
+	struct	sigacts *ps_sigacts;	/* [I] Signal actions, state */
 	struct	vnode *ps_textvp;	/* Vnode of executable. */
 	struct	filedesc *ps_fd;	/* Ptr to open files structure */
 	struct	vmspace *ps_vmspace;	/* Address space */
@@ -212,14 +183,15 @@ struct process {
 	u_int	ps_xexit;		/* Exit status for wait */
 	int	ps_xsig;		/* Stopping or killing signal */
 
-	pid_t	ps_oppid;	 	/* Save parent pid during ptrace. */
+	pid_t	ps_ppid;		/* [a] Cached parent pid */
+	pid_t	ps_oppid;	 	/* [a] Save parent pid during ptrace. */
 	int	ps_ptmask;		/* Ptrace event mask */
 	struct	ptrace_state *ps_ptstat;/* Ptrace state */
 
 	struct	rusage *ps_ru;		/* sum of stats for dead threads. */
 	struct	tusage ps_tu;		/* accumulated times. */
 	struct	rusage ps_cru;		/* sum of stats for reaped children */
-	struct	itimerspec ps_timer[3];	/* [K] ITIMER_REAL timer */
+	struct	itimerspec ps_timer[3];	/* [m] ITIMER_REAL timer */
 					/* [T] ITIMER_{VIRTUAL,PROF} timers */
 	struct	timeout ps_rucheck_to;	/* [] resource limit check timer */
 	time_t	ps_nextxcpu;		/* when to send next SIGXCPU, */
@@ -228,11 +200,9 @@ struct process {
 	u_int64_t ps_wxcounter;
 
 	struct unveil *ps_uvpaths;	/* unveil vnodes and names */
-	struct unveil *ps_uvpcwd;	/* pointer to unveil of cwd, NULL if none */
-	ssize_t ps_uvvcount;		/* count of unveil vnodes held */
-	size_t ps_uvncount;		/* count of unveil names allocated */
-	int ps_uvshrink;		/* do we need to shrink vnode list */
-	int ps_uvdone;			/* no more unveil is permitted */
+	ssize_t	ps_uvvcount;		/* count of unveil vnodes held */
+	size_t	ps_uvncount;		/* count of unveil names allocated */
+	int	ps_uvdone;		/* no more unveil is permitted */
 
 /* End area that is zeroed on creation. */
 #define	ps_endzero	ps_startcopy
@@ -241,16 +211,16 @@ struct process {
 #define	ps_startcopy	ps_limit
 	struct	plimit *ps_limit;	/* [m,R] Process limits. */
 	struct	pgrp *ps_pgrp;		/* Pointer to process group. */
-	struct	emul *ps_emul;		/* Emulation information */
 
-	char	ps_comm[MAXCOMLEN+1];
+	char	ps_comm[_MAXCOMLEN];	/* command name, incl NUL */
 
 	vaddr_t	ps_strings;		/* User pointers to argv/env */
+	vaddr_t	ps_auxinfo;		/* User pointer to auxinfo */
 	vaddr_t ps_timekeep; 		/* User pointer to timekeep */
-	vaddr_t	ps_sigcode;		/* User pointer to the signal code */
-	vaddr_t ps_sigcoderet;		/* User pointer to sigreturn retPC */
-	u_long	ps_sigcookie;
-	u_int	ps_rtableid;		/* Process routing table/domain. */
+	vaddr_t	ps_sigcode;		/* [I] User pointer to signal code */
+	vaddr_t ps_sigcoderet;		/* [I] User ptr to sigreturn retPC */
+	u_long	ps_sigcookie;		/* [I] */
+	u_int	ps_rtableid;		/* [a] Process routing table/domain. */
 	char	ps_nice;		/* Process "nice" value. */
 
 	struct uprof {			/* profile arguments */
@@ -260,20 +230,22 @@ struct process {
 		u_int   pr_scale;	/* pc scaling */
 	} ps_prof;
 
-	u_short	ps_acflag;		/* Accounting flags. */
+	u_int32_t	ps_acflag;	/* Accounting flags. */
 
-	uint64_t ps_pledge;
-	uint64_t ps_execpledge;
+	uint64_t ps_pledge;		/* [m] pledge promises */
+	uint64_t ps_execpledge;		/* [m] execpledge promises */
 
-	int64_t ps_kbind_cookie;
-	u_long  ps_kbind_addr;
+	int64_t ps_kbind_cookie;	/* [m] */
+	u_long  ps_kbind_addr;		/* [m] */
+/* an address that can't be in userspace or kernelspace */
+#define	BOGO_PC	(u_long)-1
 
 /* End area that is copied on creation. */
 #define ps_endcopy	ps_refcnt
 	int	ps_refcnt;		/* Number of references. */
 
 	struct	timespec ps_start;	/* starting uptime. */
-	struct	timeout ps_realit_to;	/* [K] ITIMER_REAL timeout */
+	struct	timeout ps_realit_to;	/* [m] ITIMER_REAL timeout */
 };
 
 #define	ps_session	ps_pgrp->pg_session
@@ -305,9 +277,10 @@ struct process {
 #define	PS_ZOMBIE	0x00040000	/* Dead and ready to be waited for */
 #define	PS_NOBROADCASTKILL 0x00080000	/* Process excluded from kill -1. */
 #define	PS_PLEDGE	0x00100000	/* Has called pledge(2) */
-#define	PS_WXNEEDED	0x00200000	/* Process may violate W^X */
+#define	PS_WXNEEDED	0x00200000	/* Process allowed to violate W^X */
 #define	PS_EXECPLEDGE	0x00400000	/* Has exec pledges */
 #define	PS_ORPHAN	0x00800000	/* Process is on an orphan list */
+#define	PS_CHROOT	0x01000000	/* Process is chrooted */
 
 #define	PS_BITS \
     ("\20" "\01CONTROLT" "\02EXEC" "\03INEXEC" "\04EXITING" "\05SUGID" \
@@ -315,11 +288,12 @@ struct process {
      "\013WAITED" "\014COREDUMP" "\015SINGLEEXIT" "\016SINGLEUNWIND" \
      "\017NOZOMBIE" "\020STOPPED" "\021SYSTEM" "\022EMBRYO" "\023ZOMBIE" \
      "\024NOBROADCASTKILL" "\025PLEDGE" "\026WXNEEDED" "\027EXECPLEDGE" \
-     "\028ORPHAN")
+     "\030ORPHAN" "\031CHROOT")
 
 
 struct kcov_dev;
 struct lock_list_entry;
+struct kqueue;
 
 struct p_inentry {
 	u_long	 ie_serial;
@@ -331,6 +305,7 @@ struct p_inentry {
  *  Locks used to protect struct members in this file:
  *	I	immutable after creation
  *	S	scheduler lock
+ *	U	uidinfolk
  *	l	read only reference, see lim_read_enter()
  *	o	owned (read/modified only) by this thread
  */
@@ -382,6 +357,8 @@ struct proc {
 	struct	plimit	*p_limit;	/* [l] read ref. of p_p->ps_limit */
 	struct	kcov_dev *p_kd;		/* kcov device handle */
 	struct	lock_list_entry *p_sleeplocks;	/* WITNESS lock tracking */ 
+	struct	kqueue *p_kq;		/* [o] select/poll queue of evts */
+	unsigned long p_kq_serial;	/* [o] to check against enqueued evts */
 
 	int	 p_siglist;		/* [a] Signals arrived & not delivered*/
 
@@ -392,6 +369,7 @@ struct proc {
 #define	p_startcopy	p_sigmask
 	sigset_t p_sigmask;		/* [a] Current signal mask */
 
+	char	p_name[_MAXCOMLEN];	/* thread name, incl NUL */
 	u_char	p_slppri;		/* [S] Sleeping priority */
 	u_char	p_usrpri;	/* [S] Priority based on p_estcpu & ps_nice */
 	u_int	p_estcpu;		/* [S] Time averaged val of p_cpticks */
@@ -436,7 +414,6 @@ struct proc {
 #define	P_ALRMPEND	0x00000004	/* SIGVTALRM needs to be posted */
 #define	P_SIGSUSPEND	0x00000008	/* Need to restore before-suspend mask*/
 #define	P_CANTSLEEP	0x00000010	/* insomniac thread */
-#define	P_SELECT	0x00000040	/* Selecting; wakeup/waiting danger. */
 #define	P_SINTR		0x00000080	/* Sleep is interruptible. */
 #define	P_SYSTEM	0x00000200	/* No sigs, stats or swapping. */
 #define	P_TIMEOUT	0x00000400	/* Timing out during sleep. */
@@ -451,7 +428,7 @@ struct proc {
 
 #define	P_BITS \
     ("\20" "\01INKTR" "\02PROFPEND" "\03ALRMPEND" "\04SIGSUSPEND" \
-     "\05CANTSLEEP" "\07SELECT" "\010SINTR" "\012SYSTEM" "\013TIMEOUT" \
+     "\05CANTSLEEP" "\010SINTR" "\012SYSTEM" "\013TIMEOUT" \
      "\016WEXIT" "\020OWEUPC" "\024SUSPSINGLE" "\027XX" \
      "\030CONTINUED" "\033THREAD" "\034SUSPSIG" "\035SOFTDEP" "\037CPUPEG")
 
@@ -460,10 +437,10 @@ struct proc {
 #ifdef _KERNEL
 
 struct uidinfo {
-	LIST_ENTRY(uidinfo) ui_hash;
-	uid_t   ui_uid;
-	long    ui_proccnt;	/* proc structs */
-	long	ui_lockcnt;	/* lockf structs */
+	LIST_ENTRY(uidinfo) ui_hash;	/* [U] */
+	uid_t   ui_uid;			/* [I] */
+	long    ui_proccnt;		/* [U] proc structs */
+	long	ui_lockcnt;		/* [U] lockf structs */
 };
 
 struct uidinfo *uid_find(uid_t);
@@ -526,7 +503,6 @@ extern struct proc proc0;		/* Process slot for swapper. */
 extern struct process process0;		/* Process slot for kernel threads. */
 extern int nprocesses, maxprocess;	/* Cur and max number of processes. */
 extern int nthreads, maxthread;		/* Cur and max number of threads. */
-extern int randompid;			/* fork() should create random pid's */
 
 LIST_HEAD(proclist, proc);
 LIST_HEAD(processlist, process);
@@ -551,6 +527,8 @@ struct process *prfind(pid_t);	/* Find process by id. */
 struct process *zombiefind(pid_t); /* Find zombie process by id. */
 struct proc *tfind(pid_t);	/* Find thread by id. */
 struct pgrp *pgfind(pid_t);	/* Find process group by id. */
+struct proc *tfind_user(pid_t, struct process *);
+				/* Find thread by userspace id. */
 void	proc_printit(struct proc *p, const char *modif,
     int (*pr)(const char *, ...));
 
@@ -568,7 +546,7 @@ void	endtsleep(void *);
 int	wakeup_proc(struct proc *, const volatile void *);
 void	unsleep(struct proc *);
 void	reaper(void *);
-void	exit1(struct proc *, int, int, int);
+__dead void exit1(struct proc *, int, int, int);
 void	exit2(struct proc *);
 int	dowait4(struct proc *, pid_t, int *, int, struct rusage *,
 	    register_t *);
@@ -596,7 +574,6 @@ refreshcreds(struct proc *p)
 
 enum single_thread_mode {
 	SINGLE_SUSPEND,		/* other threads to stop wherever they are */
-	SINGLE_PTRACE,		/* other threads to stop but don't wait */
 	SINGLE_UNWIND,		/* other threads to unwind and stop */
 	SINGLE_EXIT		/* other threads to unwind and then exit */
 };
@@ -612,18 +589,14 @@ int	proc_cansugid(struct proc *);
 struct sleep_state {
 	int sls_s;
 	int sls_catch;
-	int sls_do_sleep;
-	int sls_locked;
-	int sls_sig;
-	int sls_unwind;
 	int sls_timeout;
 };
 
 struct cond {
-	int	c_wait;
+	unsigned int	c_wait;		/* [a] initialized and waiting */
 };
 
-#define COND_INITIALIZER()		{ 1 }
+#define COND_INITIALIZER()		{ .c_wait = 1 }
 
 #if defined(MULTIPROCESSOR)
 void	proc_trampoline_mp(void);	/* XXX */
diff --git a/sys/sys/protosw.h b/sys/sys/protosw.h
index 995a038..0109c07 100644
--- a/sys/sys/protosw.h
+++ b/sys/sys/protosw.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: protosw.h,v 1.31 2018/01/23 20:49:58 bluhm Exp $	*/
+/*	$OpenBSD: protosw.h,v 1.59 2022/11/26 17:52:35 mvs Exp $	*/
 /*	$NetBSD: protosw.h,v 1.10 1996/04/09 20:55:32 cgd Exp $	*/
 
 /*-
@@ -43,8 +43,8 @@
  * every 500ms through the pr_slowtimo for timer based actions.
  *
  * Protocols pass data between themselves as chains of mbufs using
- * the pr_input and pr_output hooks.  Pr_input passes data up (towards
- * UNIX) and pr_output passes it down (towards the imps); control
+ * the pr_input and pr_send hooks.  Pr_input passes data up (towards
+ * UNIX) and pr_send passes it down (towards the imps); control
  * information passes up and down on pr_ctlinput and pr_ctloutput.
  * The protocol is responsible for the space occupied by any the
  * arguments to these entries and must dispose it.
@@ -53,37 +53,60 @@
  * described below.
  */
 
+#ifndef _SYS_PROTOSW_H_
+#define _SYS_PROTOSW_H_
+
 struct mbuf;
 struct sockaddr;
 struct socket;
 struct domain;
 struct proc;
+struct stat;
+struct ifnet;
+
+struct pr_usrreqs {
+	int	(*pru_attach)(struct socket *, int, int);
+	int	(*pru_detach)(struct socket *);
+	void	(*pru_lock)(struct socket *);
+	void	(*pru_unlock)(struct socket *);
+	int	(*pru_bind)(struct socket *, struct mbuf *, struct proc *);
+	int	(*pru_listen)(struct socket *);
+	int	(*pru_connect)(struct socket *, struct mbuf *);
+	int	(*pru_accept)(struct socket *, struct mbuf *);
+	int	(*pru_disconnect)(struct socket *);
+	int	(*pru_shutdown)(struct socket *);
+	void	(*pru_rcvd)(struct socket *);
+	int	(*pru_send)(struct socket *, struct mbuf *, struct mbuf *,
+		    struct mbuf *);
+	void	(*pru_abort)(struct socket *);
+	int	(*pru_control)(struct socket *, u_long, caddr_t,
+		    struct ifnet *);
+	int	(*pru_sense)(struct socket *, struct stat *);
+	int	(*pru_rcvoob)(struct socket *, struct mbuf *, int);
+	int	(*pru_sendoob)(struct socket *, struct mbuf *, struct mbuf *,
+		    struct mbuf *);
+	int	(*pru_sockaddr)(struct socket *, struct mbuf *);
+	int	(*pru_peeraddr)(struct socket *, struct mbuf *);
+	int	(*pru_connect2)(struct socket *, struct socket *);
+};
 
 struct protosw {
 	short	pr_type;		/* socket type used for */
-	struct	domain *pr_domain;	/* domain protocol a member of */
+	const	struct domain *pr_domain; /* domain protocol a member of */
 	short	pr_protocol;		/* protocol number */
 	short	pr_flags;		/* see below */
 
 /* protocol-protocol hooks */
 					/* input to protocol (from below) */
 	int	(*pr_input)(struct mbuf **, int *, int, int);
-					/* output to protocol (from above) */
-	int	(*pr_output)(struct mbuf *, struct socket *, struct sockaddr *,
-		    struct mbuf *);
 					/* control input (from below) */
 	void	(*pr_ctlinput)(int, struct sockaddr *, u_int, void *);
 					/* control output (from above) */
 	int	(*pr_ctloutput)(int, struct socket *, int, int, struct mbuf *);
 
-/* user-protocol hook */
-					/* user request: see list below */
-	int	(*pr_usrreq)(struct socket *, int, struct mbuf *,
-		    struct mbuf *, struct mbuf *, struct proc *);
-
-	int	(*pr_attach)(struct socket *, int);
-	int	(*pr_detach)(struct socket *);
-
+/* user-protocol hooks */
+	const	struct pr_usrreqs *pr_usrreqs;
+	
 /* utility hooks */
 	void	(*pr_init)(void);	/* initialization hook */
 	void	(*pr_fasttimo)(void);	/* fast timeout (200ms) */
@@ -227,6 +250,12 @@ char	*prcorequests[] = {
 #endif
 
 #ifdef _KERNEL
+
+#include <sys/mbuf.h>
+#include <sys/socketvar.h>
+#include <sys/systm.h>
+
+struct ifnet;
 struct sockaddr;
 const struct protosw *pffindproto(int, int, int);
 const struct protosw *pffindtype(int, int);
@@ -234,4 +263,158 @@ void pfctlinput(int, struct sockaddr *);
 
 extern u_char ip_protox[];
 extern const struct protosw inetsw[];
+
+#ifdef INET6
+extern u_char ip6_protox[];
+extern const struct protosw inet6sw[];
+#endif /* INET6 */
+
+static inline int
+pru_attach(struct socket *so, int proto, int wait)
+{
+	return (*so->so_proto->pr_usrreqs->pru_attach)(so, proto, wait);
+}
+
+static inline int
+pru_detach(struct socket *so)
+{
+	return (*so->so_proto->pr_usrreqs->pru_detach)(so);
+}
+
+static inline void
+pru_lock(struct socket *so)
+{
+	(*so->so_proto->pr_usrreqs->pru_lock)(so);
+}
+
+static inline void
+pru_unlock(struct socket *so)
+{
+	(*so->so_proto->pr_usrreqs->pru_unlock)(so);
+}
+
+static inline int
+pru_bind(struct socket *so, struct mbuf *nam, struct proc *p)
+{
+	if (so->so_proto->pr_usrreqs->pru_bind)
+		return (*so->so_proto->pr_usrreqs->pru_bind)(so, nam, p);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_listen(struct socket *so)
+{
+	if (so->so_proto->pr_usrreqs->pru_listen)
+		return (*so->so_proto->pr_usrreqs->pru_listen)(so);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_connect(struct socket *so, struct mbuf *nam)
+{
+	if (so->so_proto->pr_usrreqs->pru_connect)
+		return (*so->so_proto->pr_usrreqs->pru_connect)(so, nam);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_accept(struct socket *so, struct mbuf *nam)
+{
+	if (so->so_proto->pr_usrreqs->pru_accept)
+		return (*so->so_proto->pr_usrreqs->pru_accept)(so, nam);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_disconnect(struct socket *so)
+{
+	if (so->so_proto->pr_usrreqs->pru_disconnect)
+		return (*so->so_proto->pr_usrreqs->pru_disconnect)(so);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_shutdown(struct socket *so)
+{
+	return (*so->so_proto->pr_usrreqs->pru_shutdown)(so);
+}
+
+static inline void
+pru_rcvd(struct socket *so)
+{
+	(*so->so_proto->pr_usrreqs->pru_rcvd)(so);
+}
+
+static inline int
+pru_send(struct socket *so, struct mbuf *top, struct mbuf *addr,
+    struct mbuf *control)
+{
+	return (*so->so_proto->pr_usrreqs->pru_send)(so, top, addr, control);
+}
+
+static inline void
+pru_abort(struct socket *so)
+{
+	(*so->so_proto->pr_usrreqs->pru_abort)(so);
+}
+
+static inline int
+pru_control(struct socket *so, u_long cmd, caddr_t data, struct ifnet *ifp)
+{
+	if (so->so_proto->pr_usrreqs->pru_control)
+		return (*so->so_proto->pr_usrreqs->pru_control)(so,
+		    cmd, data, ifp);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_sense(struct socket *so, struct stat *ub)
+{
+	if (so->so_proto->pr_usrreqs->pru_sense)
+		return (*so->so_proto->pr_usrreqs->pru_sense)(so, ub);
+	return (0);
+}
+
+static inline int
+pru_rcvoob(struct socket *so, struct mbuf *m, int flags)
+{
+	if (so->so_proto->pr_usrreqs->pru_rcvoob)
+		return (*so->so_proto->pr_usrreqs->pru_rcvoob)(so, m, flags);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_sendoob(struct socket *so, struct mbuf *top, struct mbuf *addr,
+    struct mbuf *control)
+{
+	if (so->so_proto->pr_usrreqs->pru_sendoob)
+		return (*so->so_proto->pr_usrreqs->pru_sendoob)(so,
+		    top, addr, control);
+	m_freem(top);
+	m_freem(control);
+	return (EOPNOTSUPP);
+}
+
+static inline int
+pru_sockaddr(struct socket *so, struct mbuf *addr)
+{
+	return (*so->so_proto->pr_usrreqs->pru_sockaddr)(so, addr);
+}
+
+static inline int
+pru_peeraddr(struct socket *so, struct mbuf *addr)
+{
+	return (*so->so_proto->pr_usrreqs->pru_peeraddr)(so, addr);
+}
+
+static inline int
+pru_connect2(struct socket *so1, struct socket *so2)
+{
+	if (so1->so_proto->pr_usrreqs->pru_connect2)
+		return (*so1->so_proto->pr_usrreqs->pru_connect2)(so1, so2);
+	return (EOPNOTSUPP);
+}
+
 #endif
+
+#endif /* _SYS_PROTOSW_H_ */
diff --git a/sys/sys/queue.h b/sys/sys/queue.h
index f28ba89..20b7887 100644
--- a/sys/sys/queue.h
+++ b/sys/sys/queue.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: queue.h,v 1.45 2018/07/12 14:22:54 sashan Exp $	*/
+/*	$OpenBSD: queue.h,v 1.46 2020/12/30 13:33:12 millert Exp $	*/
 /*	$NetBSD: queue.h,v 1.11 1996/05/16 05:17:14 mycroft Exp $	*/
 
 /*
@@ -533,4 +533,101 @@ struct {								\
 	}								\
 } while (0)
 
+/*
+ * Singly-linked Tail queue declarations.
+ */
+#define	STAILQ_HEAD(name, type)						\
+struct name {								\
+	struct type *stqh_first;	/* first element */		\
+	struct type **stqh_last;	/* addr of last next element */	\
+}
+
+#define	STAILQ_HEAD_INITIALIZER(head)					\
+	{ NULL, &(head).stqh_first }
+
+#define	STAILQ_ENTRY(type)						\
+struct {								\
+	struct type *stqe_next;	/* next element */			\
+}
+
+/*
+ * Singly-linked Tail queue access methods.
+ */
+#define	STAILQ_FIRST(head)	((head)->stqh_first)
+#define	STAILQ_END(head)	NULL
+#define	STAILQ_EMPTY(head)	(STAILQ_FIRST(head) == STAILQ_END(head))
+#define	STAILQ_NEXT(elm, field)	((elm)->field.stqe_next)
+
+#define STAILQ_FOREACH(var, head, field)				\
+	for ((var) = STAILQ_FIRST(head);				\
+	    (var) != STAILQ_END(head);					\
+	    (var) = STAILQ_NEXT(var, field))
+
+#define	STAILQ_FOREACH_SAFE(var, head, field, tvar)			\
+	for ((var) = STAILQ_FIRST(head);				\
+	    (var) && ((tvar) = STAILQ_NEXT(var, field), 1);		\
+	    (var) = (tvar))
+
+/*
+ * Singly-linked Tail queue functions.
+ */
+#define	STAILQ_INIT(head) do {						\
+	STAILQ_FIRST((head)) = NULL;					\
+	(head)->stqh_last = &STAILQ_FIRST((head));			\
+} while (0)
+
+#define	STAILQ_INSERT_HEAD(head, elm, field) do {			\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL)	\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_FIRST((head)) = (elm);					\
+} while (0)
+
+#define	STAILQ_INSERT_TAIL(head, elm, field) do {			\
+	STAILQ_NEXT((elm), field) = NULL;				\
+	*(head)->stqh_last = (elm);					\
+	(head)->stqh_last = &STAILQ_NEXT((elm), field);			\
+} while (0)
+
+#define	STAILQ_INSERT_AFTER(head, listelm, elm, field) do {		\
+	if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((elm), field)) == NULL)\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+	STAILQ_NEXT((elm), field) = (elm);				\
+} while (0)
+
+#define STAILQ_REMOVE_HEAD(head, field) do {                            \
+	if ((STAILQ_FIRST((head)) =					\
+	    STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL)		\
+		(head)->stqh_last = &STAILQ_FIRST((head));		\
+} while (0)
+
+#define STAILQ_REMOVE_AFTER(head, elm, field) do {                      \
+	if ((STAILQ_NEXT(elm, field) =					\
+	    STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL)	\
+		(head)->stqh_last = &STAILQ_NEXT((elm), field);		\
+} while (0)
+
+#define	STAILQ_REMOVE(head, elm, type, field) do {			\
+	if (STAILQ_FIRST((head)) == (elm)) {				\
+		STAILQ_REMOVE_HEAD((head), field);			\
+	} else {							\
+		struct type *curelm = (head)->stqh_first;		\
+		while (STAILQ_NEXT(curelm, field) != (elm))		\
+			curelm = STAILQ_NEXT(curelm, field);		\
+		STAILQ_REMOVE_AFTER(head, curelm, field);		\
+	}								\
+} while (0)
+
+#define	STAILQ_CONCAT(head1, head2) do {				\
+	if (!STAILQ_EMPTY((head2))) {					\
+		*(head1)->stqh_last = (head2)->stqh_first;		\
+		(head1)->stqh_last = (head2)->stqh_last;		\
+		STAILQ_INIT((head2));					\
+	}								\
+} while (0)
+
+#define	STAILQ_LAST(head, type, field)					\
+	(STAILQ_EMPTY((head)) ?	NULL :					\
+	        ((struct type *)(void *)				\
+		((char *)((head)->stqh_last) - offsetof(struct type, field))))
+
 #endif	/* !_SYS_QUEUE_H_ */
diff --git a/sys/sys/reboot.h b/sys/sys/reboot.h
index 805eab8..bf3e7f8 100644
--- a/sys/sys/reboot.h
+++ b/sys/sys/reboot.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: reboot.h,v 1.19 2020/05/23 00:40:53 deraadt Exp $	*/
+/*	$OpenBSD: reboot.h,v 1.20 2021/10/26 16:29:49 deraadt Exp $	*/
 /*	$NetBSD: reboot.h,v 1.9 1996/04/22 01:23:25 christos Exp $	*/
 
 /*
@@ -58,6 +58,7 @@
 #define	RB_USERREQ	0x04000	/* boot() called at user request (e.g. ddb) */
 #define	RB_RESET	0x08000	/* just reset, no cleanup  */
 #define	RB_GOODRANDOM	0x10000	/* excellent random seed loaded */
+#define	RB_UNHIBERNATE	0x20000	/* unhibernate */
 
 /*
  * Constants for converting boot-style device number to type,
diff --git a/sys/sys/refcnt.h b/sys/sys/refcnt.h
index 85e84cf..c6a44d6 100644
--- a/sys/sys/refcnt.h
+++ b/sys/sys/refcnt.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: refcnt.h,v 1.4 2016/06/07 07:53:33 mpi Exp $ */
+/*	$OpenBSD: refcnt.h,v 1.8 2022/08/29 07:51:45 bluhm Exp $ */
 
 /*
  * Copyright (c) 2015 David Gwynne <dlg@openbsd.org>
@@ -19,19 +19,34 @@
 #ifndef _SYS_REFCNT_H_
 #define _SYS_REFCNT_H_
 
+/*
+ * Locks used to protect struct members in this file:
+ *	I	immutable after creation
+ *	a	atomic operations
+ */
+
 struct refcnt {
-	unsigned int refs;
+	unsigned int	r_refs;		/* [a] reference counter */
+	int		r_traceidx;	/* [I] index for dt(4) tracing  */
 };
 
-#define REFCNT_INITIALIZER()	{ .refs = 1 }
+#define REFCNT_INITIALIZER()		{ .r_refs = 1, .r_traceidx = 0 }
 
 #ifdef _KERNEL
 
 void	refcnt_init(struct refcnt *);
+void	refcnt_init_trace(struct refcnt *, int id);
 void	refcnt_take(struct refcnt *);
 int	refcnt_rele(struct refcnt *);
 void	refcnt_rele_wake(struct refcnt *);
 void	refcnt_finalize(struct refcnt *, const char *);
+int	refcnt_shared(struct refcnt *);
+unsigned int	refcnt_read(struct refcnt *);
+
+/* sorted alphabetically, keep in sync with dev/dt/dt_prov_static.c */
+#define DT_REFCNT_IDX_IFADDR	1
+#define DT_REFCNT_IDX_INPCB	2
+#define DT_REFCNT_IDX_TDB	3
 
 #endif /* _KERNEL */
 
diff --git a/sys/sys/resourcevar.h b/sys/sys/resourcevar.h
index 4200758..74b994e 100644
--- a/sys/sys/resourcevar.h
+++ b/sys/sys/resourcevar.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: resourcevar.h,v 1.24 2019/06/21 09:39:48 visa Exp $	*/
+/*	$OpenBSD: resourcevar.h,v 1.25 2022/03/18 14:45:39 visa Exp $	*/
 /*	$NetBSD: resourcevar.h,v 1.12 1995/11/22 23:01:53 cgd Exp $	*/
 
 /*
@@ -35,6 +35,7 @@
 #ifndef	_SYS_RESOURCEVAR_H_
 #define	_SYS_RESOURCEVAR_H_
 
+#include <sys/refcnt.h>
 #include <sys/timeout.h>
 
 /*
@@ -44,7 +45,7 @@
  */
 struct plimit {
 	struct	rlimit pl_rlimit[RLIM_NLIMITS];
-	u_int	pl_refcnt;		/* number of references */
+	struct	refcnt pl_refcnt;
 };
 
 /* add user profiling from AST */
diff --git a/sys/sys/rwlock.h b/sys/sys/rwlock.h
index 4b32e38..f5a2504 100644
--- a/sys/sys/rwlock.h
+++ b/sys/sys/rwlock.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: rwlock.h,v 1.26 2019/07/16 01:40:49 jsg Exp $	*/
+/*	$OpenBSD: rwlock.h,v 1.28 2021/01/11 18:49:38 mpi Exp $	*/
 /*
  * Copyright (c) 2002 Artur Grabowski <art@openbsd.org>
  *
@@ -168,6 +168,29 @@ int	rw_enter(struct rwlock *, int);
 void	rw_exit(struct rwlock *);
 int	rw_status(struct rwlock *);
 
+static inline int
+rw_read_held(struct rwlock *rwl)
+{
+	return (rw_status(rwl) == RW_READ);
+}
+
+static inline int
+rw_write_held(struct rwlock *rwl)
+{
+	return (rw_status(rwl) == RW_WRITE);
+}
+
+static inline int
+rw_lock_held(struct rwlock *rwl)
+{
+	int status;
+
+	status = rw_status(rwl);
+
+	return (status == RW_READ || status == RW_WRITE);
+}
+
+
 void	_rrw_init_flags(struct rrwlock *, const char *, int,
 	    const struct lock_type *);
 int	rrw_enter(struct rrwlock *, int);
@@ -186,6 +209,28 @@ int	rrw_status(struct rrwlock *);
 #define rrw_init(rrwl, name)	_rrw_init_flags(rrwl, name, 0, NULL)
 #endif /* WITNESS */
 
+
+/*
+ * Allocated, reference-counted rwlocks
+ */
+
+#ifdef WITNESS
+#define rw_obj_alloc_flags(rwl, name, flags) do {			\
+	static struct lock_type __lock_type = { .lt_name = #rwl };	\
+	_rw_obj_alloc_flags(rwl, name, flags, &__lock_type);		\
+} while (0)
+#else
+#define rw_obj_alloc_flags(rwl, name, flags) \
+			_rw_obj_alloc_flags(rwl, name, flags, NULL)
+#endif
+#define rw_obj_alloc(rwl, name)		rw_obj_alloc_flags(rwl, name, 0)
+
+void	rw_obj_init(void);
+void	_rw_obj_alloc_flags(struct rwlock **, const char *, int,
+		struct lock_type *);
+void	rw_obj_hold(struct rwlock *);
+int	rw_obj_free(struct rwlock *);
+
 #endif /* _KERNEL */
 
 #endif /* _SYS_RWLOCK_H */
diff --git a/sys/sys/sched.h b/sys/sys/sched.h
index 279d50f..e5d461d 100644
--- a/sys/sys/sched.h
+++ b/sys/sys/sched.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: sched.h,v 1.56 2019/10/21 10:24:01 mpi Exp $	*/
+/*	$OpenBSD: sched.h,v 1.57 2020/12/25 12:49:31 visa Exp $	*/
 /* $NetBSD: sched.h,v 1.2 1999/02/28 18:14:58 ross Exp $ */
 
 /*-
@@ -119,6 +119,7 @@ struct schedstate_percpu {
 	u_int spc_smrdepth;		/* level of smr nesting */
 	u_char spc_smrexpedite;		/* if set, dispatch smr entries
 					 * without delay */
+	u_char spc_smrgp;		/* this CPU's view of grace period */
 };
 
 struct cpustats {
diff --git a/sys/sys/selinfo.h b/sys/sys/selinfo.h
index 1d9431b..cd5342c 100644
--- a/sys/sys/selinfo.h
+++ b/sys/sys/selinfo.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: selinfo.h,v 1.5 2017/07/18 19:20:26 sf Exp $	*/
+/*	$OpenBSD: selinfo.h,v 1.6 2022/07/05 15:06:16 visa Exp $	*/
 
 /*-
  * Copyright (c) 1992, 1993
@@ -42,15 +42,9 @@
  */
 struct selinfo {
 	struct	klist si_note;	/* kernel note list */
-	pid_t	si_seltid;	/* thread to be notified */
-	short	si_flags;	/* see below */
 };
-#define	SI_COLL	0x0001		/* collision occurred */
 
 #ifdef _KERNEL
-struct proc;
-
-void	selrecord(struct proc *selector, struct selinfo *);
 void	selwakeup(struct selinfo *);
 #endif
 
diff --git a/sys/sys/sem.h b/sys/sys/sem.h
index 184482d..9d09a95 100644
--- a/sys/sys/sem.h
+++ b/sys/sys/sem.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: sem.h,v 1.24 2016/09/01 08:33:40 tom Exp $	*/
+/*	$OpenBSD: sem.h,v 1.25 2022/09/16 15:57:23 mbuhl Exp $	*/
 /*	$NetBSD: sem.h,v 1.8 1996/02/09 18:25:29 christos Exp $	*/
 
 /*
@@ -180,10 +180,6 @@ struct proc;
 void	seminit(void);
 void	semexit(struct process *);
 int	sysctl_sysvsem(int *, u_int, void *, size_t *, void *, size_t);
-int	semctl1(struct proc *, int, int, int, union semun *, register_t *,
-	    int (*)(const void *, void *, size_t),
-	    int (*)(const void *, void *, size_t));
-
 #endif /* _KERNEL */
 
 #ifndef _KERNEL
diff --git a/sys/sys/shm.h b/sys/sys/shm.h
index d46cbbe..4b65fe7 100644
--- a/sys/sys/shm.h
+++ b/sys/sys/shm.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: shm.h,v 1.29 2019/11/03 20:16:01 guenther Exp $	*/
+/*	$OpenBSD: shm.h,v 1.30 2021/03/10 10:21:47 jsg Exp $	*/
 /*	$NetBSD: shm.h,v 1.20 1996/04/09 20:55:35 cgd Exp $	*/
 
 /*
@@ -85,7 +85,7 @@
 #define	SHM_UNLOCK	4	/* Unlock a segment locked by SHM_LOCK. */
 
 /*
- * Segment low boundry address multiple
+ * Segment low boundary address multiple
  */
 #define	SHMLBA		(1U << _MAX_PAGE_SHIFT)
 
diff --git a/sys/sys/siginfo.h b/sys/sys/siginfo.h
index dd6b32f..c534ab1 100644
--- a/sys/sys/siginfo.h
+++ b/sys/sys/siginfo.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: siginfo.h,v 1.12 2017/04/07 04:48:44 guenther Exp $	*/
+/*	$OpenBSD: siginfo.h,v 1.13 2022/10/25 16:08:26 kettenis Exp $	*/
 
 /*
  * Copyright (c) 1997 Theo de Raadt
@@ -137,9 +137,9 @@ typedef struct {
 		int	_pad[SI_PAD];		/* for future growth */
 		struct {			/* kill(), SIGCHLD */
 			pid_t	_pid;		/* process ID */
+			uid_t	_uid;
 			union {
 				struct {
-					uid_t	_uid;
 					union sigval	_value;
 				} _kill;
 				struct {
@@ -173,11 +173,11 @@ typedef struct {
 } siginfo_t;
 
 #define si_pid		_data._proc._pid
+#define si_uid		_data._proc._uid
 
 #define si_status	_data._proc._pdata._cld._status
 #define si_stime	_data._proc._pdata._cld._stime
 #define si_utime	_data._proc._pdata._cld._utime
-#define si_uid		_data._proc._pdata._kill._uid
 #define si_value	_data._proc._pdata._kill._value
 #define si_addr		_data._fault._addr
 #define si_trapno	_data._fault._trapno
diff --git a/sys/sys/signalvar.h b/sys/sys/signalvar.h
index c8c71da..3912d92 100644
--- a/sys/sys/signalvar.h
+++ b/sys/sys/signalvar.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: signalvar.h,v 1.44 2020/09/16 13:50:42 mpi Exp $	*/
+/*	$OpenBSD: signalvar.h,v 1.54 2022/05/13 15:32:00 claudio Exp $	*/
 /*	$NetBSD: signalvar.h,v 1.17 1996/04/22 01:23:31 christos Exp $	*/
 
 /*
@@ -43,17 +43,21 @@
 /*
  * Process signal actions and state, needed only within the process
  * (not necessarily resident).
+ *
+ * Locks used to protect struct members in struct sigacts:
+ *	a	atomic operations
+ *	m	this process' `ps_mtx'
  */
 struct	sigacts {
-	sig_t	ps_sigact[NSIG];	/* disposition of signals */
-	sigset_t ps_catchmask[NSIG];	/* signals to be blocked */
-	sigset_t ps_sigonstack;		/* signals to take on sigstack */
-	sigset_t ps_sigintr;		/* signals that interrupt syscalls */
-	sigset_t ps_sigreset;		/* signals that reset when caught */
-	sigset_t ps_siginfo;		/* signals that provide siginfo */
-	sigset_t ps_sigignore;		/* signals being ignored */
-	sigset_t ps_sigcatch;		/* signals being caught by user */
-	int	ps_sigflags;		/* signal flags, below */
+	sig_t	ps_sigact[NSIG];	/* [m] disposition of signals */
+	sigset_t ps_catchmask[NSIG];	/* [m] signals to be blocked */
+	sigset_t ps_sigonstack;		/* [m] signals to take on sigstack */
+	sigset_t ps_sigintr;		/* [m] signals interrupt syscalls */
+	sigset_t ps_sigreset;		/* [m] signals that reset when caught */
+	sigset_t ps_siginfo;		/* [m] signals that provide siginfo */
+	sigset_t ps_sigignore;		/* [m] signals being ignored */
+	sigset_t ps_sigcatch;		/* [m] signals being caught by user */
+	int	ps_sigflags;		/* [a] signal flags, below */
 };
 
 /* signal flags */
@@ -71,30 +75,8 @@ struct	sigacts {
 #define SIGPENDING(p)							\
 	(((p)->p_siglist | (p)->p_p->ps_siglist) & ~(p)->p_sigmask)
 
-/*
- * Determine signal that should be delivered to process p, the current
- * process, 0 if none.  If there is a pending stop signal with default
- * action, the process stops in issignal().
- */
-#define CURSIG(p)							\
-	((((p)->p_siglist | (p)->p_p->ps_siglist) == 0 ||		\
-	    (((p)->p_p->ps_flags & PS_TRACED) == 0 &&			\
-	    SIGPENDING(p) == 0)) ?					\
-	    0 : issignal(p))
-
-/*
- * Clear a pending signal from a process.
- */
-#define CLRSIG(p, sig)	do {						\
-	int __mask = sigmask(sig);					\
-	atomic_clearbits_int(&(p)->p_siglist, __mask);			\
-	atomic_clearbits_int(&(p)->p_p->ps_siglist, __mask);		\
-} while (0)
-
 /*
  * Signal properties and actions.
- * The array below categorizes the signals and their default actions
- * according to the following properties:
  */
 #define	SA_KILL		0x01		/* terminates process by default */
 #define	SA_CORE		0x02		/* ditto and coredumps */
@@ -111,21 +93,31 @@ enum signal_type { SPROCESS, STHREAD, SPROPAGATED };
 
 struct sigio_ref;
 
+struct sigctx {
+	sig_t		sig_action;
+	sigset_t	sig_catchmask;
+	int		sig_onstack;
+	int		sig_intr;
+	int		sig_reset;
+	int		sig_info;
+	int		sig_ignore;
+	int		sig_catch;
+};
+
 /*
  * Machine-independent functions:
  */
 int	coredump(struct proc *p);
 void	execsigs(struct proc *p);
-int	issignal(struct proc *p);
+int	cursig(struct proc *p, struct sigctx *);
 void	pgsigio(struct sigio_ref *sir, int sig, int checkctty);
 void	pgsignal(struct pgrp *pgrp, int sig, int checkctty);
 void	psignal(struct proc *p, int sig);
 void	ptsignal(struct proc *p, int sig, enum signal_type type);
 #define prsignal(pr,sig)	ptsignal((pr)->ps_mainproc, (sig), SPROCESS)
-void	siginit(struct sigacts *);
 void	trapsignal(struct proc *p, int sig, u_long code, int type,
 	    union sigval val);
-void	sigexit(struct proc *, int);
+__dead void sigexit(struct proc *, int);
 void	sigabort(struct proc *);
 int	sigismasked(struct proc *, int);
 int	sigonstack(size_t);
@@ -133,13 +125,15 @@ int	killpg1(struct proc *, int, int, int);
 
 void	signal_init(void);
 
-struct sigacts *sigactsinit(struct process *);
 void	sigstkinit(struct sigaltstack *);
-void	sigactsfree(struct process *);
+struct sigacts	*sigactsinit(struct process *);
+void	sigactsfree(struct sigacts *);
+void	siginit(struct sigacts *);
 
 /*
  * Machine-dependent functions:
  */
-void	sendsig(sig_t _catcher, int _sig, sigset_t _mask, const siginfo_t *_si);
+int	sendsig(sig_t _catcher, int _sig, sigset_t _mask, const siginfo_t *_si,
+	    int _info, int _onstack);
 #endif	/* _KERNEL */
 #endif	/* !_SYS_SIGNALVAR_H_ */
diff --git a/sys/sys/smr.h b/sys/sys/smr.h
index b15689a..aebd6d7 100644
--- a/sys/sys/smr.h
+++ b/sys/sys/smr.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: smr.h,v 1.7 2020/06/17 14:12:19 visa Exp $	*/
+/*	$OpenBSD: smr.h,v 1.9 2022/07/25 08:06:44 visa Exp $	*/
 
 /*
  * Copyright (c) 2019 Visa Hankala
@@ -288,7 +288,7 @@ struct {								\
  * List functions.
  */
 #define	SMR_LIST_INIT(head) do {					\
-	(head)->smr_lh_first = LIST_END(head);				\
+	(head)->smr_lh_first = SMR_LIST_END(head);			\
 } while (0)
 
 #define	SMR_LIST_INSERT_AFTER_LOCKED(listelm, elm, field) do {		\
@@ -334,7 +334,7 @@ struct {								\
 #define	SMR_TAILQ_HEAD(name, type)					\
 struct name {								\
 	struct type *smr_tqh_first;	/* first element, SMR-protected */\
-	struct type **smr_tqh_last;	/* last element, SMR-protected */\
+	struct type **smr_tqh_last;	/* last element */		\
 }
 
 #define	SMR_TAILQ_HEAD_INITIALIZER(head)				\
@@ -382,7 +382,7 @@ struct {								\
  * Tail queue functions.
  */
 #define	SMR_TAILQ_INIT(head) do {					\
-	(head)->smr_tqh_first = TAILQ_END(head);			\
+	(head)->smr_tqh_first = SMR_TAILQ_END(head);			\
 	(head)->smr_tqh_last = &(head)->smr_tqh_first;			\
 } while (0)
 
diff --git a/sys/sys/socket.h b/sys/sys/socket.h
index 927fd26..26c2a7b 100644
--- a/sys/sys/socket.h
+++ b/sys/sys/socket.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: socket.h,v 1.98 2019/07/22 15:34:07 robert Exp $	*/
+/*	$OpenBSD: socket.h,v 1.105 2022/09/03 21:13:48 mbuhl Exp $	*/
 /*	$NetBSD: socket.h,v 1.14 1996/02/09 18:25:36 christos Exp $	*/
 
 /*
@@ -322,7 +322,7 @@ struct sockpeercred {
 	{ "chaos", CTLTYPE_NODE }, \
 	{ "xerox_ns", CTLTYPE_NODE }, \
 	{ "iso", CTLTYPE_NODE }, \
-	{ "emca", CTLTYPE_NODE }, \
+	{ "ecma", CTLTYPE_NODE }, \
 	{ "datakit", CTLTYPE_NODE }, \
 	{ "ccitt", CTLTYPE_NODE }, \
 	{ "ibm_sna", CTLTYPE_NODE }, \
@@ -368,7 +368,8 @@ struct sockpeercred {
 #define	NET_RT_STATS	4		/* routing table statistics */
 #define	NET_RT_TABLE	5
 #define	NET_RT_IFNAMES	6
-#define	NET_RT_MAXID	7
+#define	NET_RT_SOURCE	7
+#define	NET_RT_MAXID	8
 
 #define CTL_NET_RT_NAMES { \
 	{ 0, 0 }, \
@@ -378,6 +379,35 @@ struct sockpeercred {
 	{ "stats", CTLTYPE_STRUCT }, \
 	{ "table", CTLTYPE_STRUCT }, \
 	{ "ifnames", CTLTYPE_STRUCT }, \
+	{ "source", CTLTYPE_STRUCT }, \
+}
+
+/*
+ * PF_UNIX - unix socket tunables
+ */
+#define NET_UNIX_INFLIGHT	6
+#define NET_UNIX_DEFERRED	7
+#define NET_UNIX_MAXID		8
+
+#define CTL_NET_UNIX_NAMES { \
+	{ 0, 0 }, \
+	{ "stream", CTLTYPE_NODE }, \
+	{ "dgram", CTLTYPE_NODE }, \
+	{ 0, 0 }, \
+	{ 0, 0 }, \
+	{ "seqpacket", CTLTYPE_NODE }, \
+	{ "inflight", CTLTYPE_INT }, \
+	{ "deferred", CTLTYPE_INT }, \
+}
+
+#define UNPCTL_RECVSPACE	1
+#define UNPCTL_SENDSPACE	2
+#define NET_UNIX_PROTO_MAXID	3
+
+#define CTL_NET_UNIX_PROTO_NAMES { \
+	{ 0, 0 }, \
+	{ "recvspace", CTLTYPE_INT }, \
+	{ "sendspace", CTLTYPE_INT }, \
 }
 
 /*
@@ -460,6 +490,13 @@ struct msghdr {
 	int		msg_flags;	/* flags on received message */
 };
 
+struct mmsghdr {
+	struct msghdr msg_hdr;
+	unsigned int msg_len;
+};
+
+struct timespec;
+
 #define	MSG_OOB			0x1	/* process out-of-band data */
 #define	MSG_PEEK		0x2	/* peek at incoming message */
 #define	MSG_DONTROUTE		0x4	/* send without using routing tables */
@@ -472,6 +509,7 @@ struct msghdr {
 #define	MSG_MCAST		0x200	/* this message rec'd as multicast */
 #define	MSG_NOSIGNAL		0x400	/* do not send SIGPIPE */
 #define	MSG_CMSG_CLOEXEC	0x800	/* set FD_CLOEXEC on received fds */
+#define	MSG_WAITFORONE		0x1000	/* nonblocking but wait for one msg */
 
 /*
  * Header for ancillary data objects in msg_control buffer.
@@ -535,10 +573,12 @@ int	listen(int, int);
 ssize_t	recv(int, void *, size_t, int);
 ssize_t	recvfrom(int, void *, size_t, int, struct sockaddr *, socklen_t *);
 ssize_t	recvmsg(int, struct msghdr *, int);
+int	recvmmsg(int, struct mmsghdr *, unsigned int, int, struct timespec *);
 ssize_t	send(int, const void *, size_t, int);
 ssize_t	sendto(int, const void *,
 	    size_t, int, const struct sockaddr *, socklen_t);
 ssize_t	sendmsg(int, const struct msghdr *, int);
+int	sendmmsg(int, struct mmsghdr *, unsigned int, int);
 int	setsockopt(int, int, int, const void *, socklen_t);
 int	shutdown(int, int);
 int	sockatmark(int);
@@ -559,8 +599,6 @@ __END_DECLS
 
 #else
 
-void	pfctlinput(int, struct sockaddr *);
-
 static inline struct sockaddr *
 sstosa(struct sockaddr_storage *ss)
 {
diff --git a/sys/sys/socketvar.h b/sys/sys/socketvar.h
index abcf20e..834a2b5 100644
--- a/sys/sys/socketvar.h
+++ b/sys/sys/socketvar.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: socketvar.h,v 1.91 2020/01/15 13:17:35 mpi Exp $	*/
+/*	$OpenBSD: socketvar.h,v 1.119 2023/01/27 18:46:34 mvs Exp $	*/
 /*	$NetBSD: socketvar.h,v 1.18 1996/02/09 18:25:38 christos Exp $	*/
 
 /*-
@@ -32,11 +32,16 @@
  *	@(#)socketvar.h	8.1 (Berkeley) 6/2/93
  */
 
-#include <sys/selinfo.h>			/* for struct selinfo */
+#ifndef _SYS_SOCKETVAR_H_
+#define _SYS_SOCKETVAR_H_
+
+#include <sys/event.h>
 #include <sys/queue.h>
 #include <sys/sigio.h>				/* for struct sigio_ref */
 #include <sys/task.h>
 #include <sys/timeout.h>
+#include <sys/rwlock.h>
+#include <sys/refcnt.h>
 
 #ifndef	_SOCKLEN_T_DEFINED_
 #define	_SOCKLEN_T_DEFINED_
@@ -53,6 +58,8 @@ TAILQ_HEAD(soqhead, socket);
  */
 struct socket {
 	const struct protosw *so_proto;	/* protocol handle */
+	struct rwlock so_lock;		/* this socket lock */
+	struct refcnt so_refcnt;	/* references to this socket */
 	void	*so_pcb;		/* protocol control block */
 	u_int	so_state;		/* internal state flags SS_*, below */
 	short	so_type;		/* generic type, see socket.h */
@@ -78,6 +85,7 @@ struct socket {
 	short	so_q0len;		/* partials on so_q0 */
 	short	so_qlen;		/* number of connections on so_q */
 	short	so_qlimit;		/* max number queued connections */
+	u_long	so_newconn;		/* # of pending sonewconn() threads */
 	short	so_timeo;		/* connection timeout */
 	u_long	so_oobmark;		/* chars to oob mark */
 	u_int	so_error;		/* error affecting connection */
@@ -113,19 +121,17 @@ struct socket {
 		short	sb_flags;	/* flags, see below */
 /* End area that is zeroed on flush. */
 #define	sb_endzero	sb_flags
-		int	sb_flagsintr;	/* flags, changed atomically */
+		short	sb_state;	/* socket state on sockbuf */
 		uint64_t sb_timeo_nsecs;/* timeout for read/write */
-		struct	selinfo sb_sel;	/* process selecting read/write */
+		struct klist sb_klist;	/* process selecting read/write */
 	} so_rcv, so_snd;
 #define	SB_MAX		(2*1024*1024)	/* default for max chars in sockbuf */
 #define	SB_LOCK		0x01		/* lock on data queue */
 #define	SB_WANT		0x02		/* someone is waiting to lock */
 #define	SB_WAIT		0x04		/* someone is waiting for data/space */
-#define	SB_SEL		0x08		/* someone is selecting */
 #define	SB_ASYNC	0x10		/* ASYNC I/O, need signals */
 #define	SB_SPLICE	0x20		/* buffer is splice source or drain */
 #define	SB_NOINTR	0x40		/* operations not interruptible */
-#define	SB_KNOTE	0x80		/* kernel note attached */
 
 	void	(*so_upcall)(struct socket *so, caddr_t arg, int waitf);
 	caddr_t	so_upcallarg;		/* Arg for above */
@@ -136,7 +142,16 @@ struct socket {
 
 /*
  * Socket state bits.
+ *
+ * NOTE: The following states should be used with corresponding socket's
+ * buffer `sb_state' only:
+ *
+ *	SS_CANTSENDMORE		with `so_snd'
+ *	SS_ISSENDING		with `so_snd'
+ *	SS_CANTRCVMORE		with `so_rcv'
+ *	SS_RCVATMARK		with `so_rcv'
  */
+
 #define	SS_NOFDREF		0x001	/* no file table ref any more */
 #define	SS_ISCONNECTED		0x002	/* socket connected to a peer */
 #define	SS_ISCONNECTING		0x004	/* in process of connecting to peer */
@@ -147,23 +162,31 @@ struct socket {
 #define	SS_ISDISCONNECTED	0x800	/* socket disconnected from peer */
 
 #define	SS_PRIV			0x080	/* privileged for broadcast, raw... */
-#define	SS_ASYNC		0x200	/* async i/o notify */
 #define	SS_CONNECTOUT		0x1000	/* connect, not accept, at this end */
 #define	SS_ISSENDING		0x2000	/* hint for lower layer */
 #define	SS_DNS			0x4000	/* created using SOCK_DNS socket(2) */
+#define	SS_NEWCONN_WAIT		0x8000	/* waiting sonewconn() relock */
+#define	SS_YP			0x10000	/* created using ypconnect(2) */
 
 #ifdef _KERNEL
 
+#include <sys/protosw.h>
 #include <lib/libkern/libkern.h>
 
-/*
- * Values for sounlock()/sofree().
- */
-#define SL_NOUNLOCK	0x00
-#define SL_LOCKED	0x42
-
 void	soassertlocked(struct socket *);
 
+static inline void
+soref(struct socket *so)
+{
+	refcnt_take(&so->so_refcnt);
+}
+
+static inline void
+sorele(struct socket *so)
+{
+	refcnt_rele_wake(&so->so_refcnt);
+}
+
 /*
  * Macros for sockets and socket buffering.
  */
@@ -177,11 +200,9 @@ void	soassertlocked(struct socket *);
 static inline int
 sb_notify(struct socket *so, struct sockbuf *sb)
 {
-	int flags = (sb->sb_flags | sb->sb_flagsintr);
-
-	KASSERT(sb == &so->so_rcv || sb == &so->so_snd);
 	soassertlocked(so);
-	return ((flags & (SB_WAIT|SB_SEL|SB_ASYNC|SB_SPLICE|SB_KNOTE)) != 0);
+	return ((sb->sb_flags & (SB_WAIT|SB_ASYNC|SB_SPLICE)) != 0 ||
+	    !klist_empty(&sb->sb_klist));
 }
 
 /*
@@ -193,7 +214,6 @@ sb_notify(struct socket *so, struct sockbuf *sb)
 static inline long
 sbspace(struct socket *so, struct sockbuf *sb)
 {
-	KASSERT(sb == &so->so_rcv || sb == &so->so_snd);
 	soassertlocked(so);
 	return lmin(sb->sb_hiwat - sb->sb_cc, sb->sb_mbmax - sb->sb_mbcnt);
 }
@@ -204,7 +224,7 @@ sbspace(struct socket *so, struct sockbuf *sb)
 
 /* are we sending on this socket? */
 #define	soissending(so) \
-    ((so)->so_state & SS_ISSENDING)
+    ((so)->so_snd.sb_state & SS_ISSENDING)
 
 /* can we read something from so? */
 static inline int
@@ -213,36 +233,44 @@ soreadable(struct socket *so)
 	soassertlocked(so);
 	if (isspliced(so))
 		return 0;
-	return (so->so_state & SS_CANTRCVMORE) || so->so_qlen || so->so_error ||
-	    so->so_rcv.sb_cc >= so->so_rcv.sb_lowat;
+	return (so->so_rcv.sb_state & SS_CANTRCVMORE) || so->so_qlen ||
+	    so->so_error || so->so_rcv.sb_cc >= so->so_rcv.sb_lowat;
 }
 
 /* can we write something to so? */
-#define	sowriteable(so) \
-    ((sbspace((so), &(so)->so_snd) >= (so)->so_snd.sb_lowat && \
-	(((so)->so_state & SS_ISCONNECTED) || \
-	  ((so)->so_proto->pr_flags & PR_CONNREQUIRED)==0)) || \
-    ((so)->so_state & SS_CANTSENDMORE) || (so)->so_error)
+static inline int
+sowriteable(struct socket *so)
+{
+	soassertlocked(so);
+	return ((sbspace(so, &so->so_snd) >= so->so_snd.sb_lowat &&
+	    ((so->so_state & SS_ISCONNECTED) ||
+	    (so->so_proto->pr_flags & PR_CONNREQUIRED)==0)) ||
+	    (so->so_snd.sb_state & SS_CANTSENDMORE) || so->so_error);
+}
 
 /* adjust counters in sb reflecting allocation of m */
-#define	sballoc(sb, m) do {						\
-	(sb)->sb_cc += (m)->m_len;					\
-	if ((m)->m_type != MT_CONTROL && (m)->m_type != MT_SONAME)	\
-		(sb)->sb_datacc += (m)->m_len;				\
-	(sb)->sb_mbcnt += MSIZE;					\
-	if ((m)->m_flags & M_EXT)					\
-		(sb)->sb_mbcnt += (m)->m_ext.ext_size;			\
-} while (/* CONSTCOND */ 0)
+static inline void
+sballoc(struct socket *so, struct sockbuf *sb, struct mbuf *m)
+{
+	sb->sb_cc += m->m_len;
+	if (m->m_type != MT_CONTROL && m->m_type != MT_SONAME)
+		sb->sb_datacc += m->m_len;
+	sb->sb_mbcnt += MSIZE;
+	if (m->m_flags & M_EXT)
+		sb->sb_mbcnt += m->m_ext.ext_size;
+}
 
 /* adjust counters in sb reflecting freeing of m */
-#define	sbfree(sb, m) do {						\
-	(sb)->sb_cc -= (m)->m_len;					\
-	if ((m)->m_type != MT_CONTROL && (m)->m_type != MT_SONAME)	\
-		(sb)->sb_datacc -= (m)->m_len;				\
-	(sb)->sb_mbcnt -= MSIZE;					\
-	if ((m)->m_flags & M_EXT)					\
-		(sb)->sb_mbcnt -= (m)->m_ext.ext_size;			\
-} while (/* CONSTCOND */ 0)
+static inline void
+sbfree(struct socket *so, struct sockbuf *sb, struct mbuf *m)
+{
+	sb->sb_cc -= m->m_len;
+	if (m->m_type != MT_CONTROL && m->m_type != MT_SONAME)
+		sb->sb_datacc -= m->m_len;
+	sb->sb_mbcnt -= MSIZE;
+	if (m->m_flags & M_EXT)
+		sb->sb_mbcnt -= m->m_ext.ext_size;
+}
 
 /*
  * Set lock on sockbuf sb; sleep if lock is already held.
@@ -278,7 +306,6 @@ struct knote;
 int	soo_read(struct file *, struct uio *, int);
 int	soo_write(struct file *, struct uio *, int);
 int	soo_ioctl(struct file *, u_long, caddr_t, struct proc *);
-int	soo_poll(struct file *, int events, struct proc *);
 int	soo_kqfilter(struct file *, struct knote *);
 int 	soo_close(struct file *, struct proc *);
 int	soo_stat(struct file *, struct stat *, struct proc *);
@@ -289,62 +316,63 @@ int	sbappendaddr(struct socket *, struct sockbuf *,
 int	sbappendcontrol(struct socket *, struct sockbuf *, struct mbuf *,
 	    struct mbuf *);
 void	sbappendrecord(struct socket *, struct sockbuf *, struct mbuf *);
-void	sbcompress(struct sockbuf *sb, struct mbuf *m, struct mbuf *n);
+void	sbcompress(struct socket *, struct sockbuf *, struct mbuf *,
+	    struct mbuf *);
 struct mbuf *
-	sbcreatecontrol(const void *, size_t, int type, int level);
+	sbcreatecontrol(const void *, size_t, int, int);
 void	sbdrop(struct socket *, struct sockbuf *, int);
-void	sbdroprecord(struct sockbuf *sb);
+void	sbdroprecord(struct socket *, struct sockbuf *);
 void	sbflush(struct socket *, struct sockbuf *);
-void	sbinsertoob(struct sockbuf *sb, struct mbuf *m0);
 void	sbrelease(struct socket *, struct sockbuf *);
-int	sbcheckreserve(u_long cnt, u_long defcnt);
+int	sbcheckreserve(u_long, u_long);
 int	sbchecklowmem(void);
 int	sbreserve(struct socket *, struct sockbuf *, u_long);
-int	sbwait(struct socket *, struct sockbuf *sb);
-int	sb_lock(struct sockbuf *sb);
+int	sbwait(struct socket *, struct sockbuf *);
 void	soinit(void);
-int	soabort(struct socket *so);
-int	soaccept(struct socket *so, struct mbuf *nam);
-int	sobind(struct socket *so, struct mbuf *nam, struct proc *p);
-void	socantrcvmore(struct socket *so);
-void	socantsendmore(struct socket *so);
+void	soabort(struct socket *);
+int	soaccept(struct socket *, struct mbuf *);
+int	sobind(struct socket *, struct mbuf *, struct proc *);
+void	socantrcvmore(struct socket *);
+void	socantsendmore(struct socket *);
 int	soclose(struct socket *, int);
-int	soconnect(struct socket *so, struct mbuf *nam);
-int	soconnect2(struct socket *so1, struct socket *so2);
-int	socreate(int dom, struct socket **aso, int type, int proto);
-int	sodisconnect(struct socket *so);
-void	sofree(struct socket *so, int);
-int	sogetopt(struct socket *so, int level, int optname, struct mbuf *m);
-void	sohasoutofband(struct socket *so);
-void	soisconnected(struct socket *so);
-void	soisconnecting(struct socket *so);
-void	soisdisconnected(struct socket *so);
-void	soisdisconnecting(struct socket *so);
-int	solisten(struct socket *so, int backlog);
-struct socket *sonewconn(struct socket *head, int connstatus);
-void	soqinsque(struct socket *head, struct socket *so, int q);
-int	soqremque(struct socket *so, int q);
-int	soreceive(struct socket *so, struct mbuf **paddr, struct uio *uio,
-	    struct mbuf **mp0, struct mbuf **controlp, int *flagsp,
-	    socklen_t controllen);
-int	soreserve(struct socket *so, u_long sndcc, u_long rcvcc);
-void	sorflush(struct socket *so);
-int	sosend(struct socket *so, struct mbuf *addr, struct uio *uio,
-	    struct mbuf *top, struct mbuf *control, int flags);
-int	sosetopt(struct socket *so, int level, int optname, struct mbuf *m);
-int	soshutdown(struct socket *so, int how);
-void	sowakeup(struct socket *so, struct sockbuf *sb);
+int	soconnect(struct socket *, struct mbuf *);
+int	soconnect2(struct socket *, struct socket *);
+int	socreate(int, struct socket **, int, int);
+int	sodisconnect(struct socket *);
+struct socket *soalloc(int);
+void	sofree(struct socket *, int);
+int	sogetopt(struct socket *, int, int, struct mbuf *);
+void	sohasoutofband(struct socket *);
+void	soisconnected(struct socket *);
+void	soisconnecting(struct socket *);
+void	soisdisconnected(struct socket *);
+void	soisdisconnecting(struct socket *);
+int	solisten(struct socket *, int);
+struct socket *sonewconn(struct socket *, int, int);
+void	soqinsque(struct socket *, struct socket *, int);
+int	soqremque(struct socket *, int);
+int	soreceive(struct socket *, struct mbuf **, struct uio *,
+	    struct mbuf **, struct mbuf **, int *, socklen_t);
+int	soreserve(struct socket *, u_long, u_long);
+int	sosend(struct socket *, struct mbuf *, struct uio *,
+	    struct mbuf *, struct mbuf *, int);
+int	sosetopt(struct socket *, int, int, struct mbuf *);
+int	soshutdown(struct socket *, int);
+void	sowakeup(struct socket *, struct sockbuf *);
 void	sorwakeup(struct socket *);
 void	sowwakeup(struct socket *);
 int	sockargs(struct mbuf **, const void *, size_t, int);
 
 int	sosleep_nsec(struct socket *, void *, int, const char *, uint64_t);
-int	solock(struct socket *);
-void	sounlock(struct socket *, int);
+void	solock(struct socket *);
+void	solock_shared(struct socket *);
+int	solock_persocket(struct socket *);
+void	solock_pair(struct socket *, struct socket *);
+void	sounlock(struct socket *);
+void	sounlock_shared(struct socket *);
 
 int	sendit(struct proc *, int, struct msghdr *, int, register_t *);
-int	recvit(struct proc *, int, struct msghdr *, caddr_t,
-		    register_t *);
+int	recvit(struct proc *, int, struct msghdr *, caddr_t, register_t *);
 int	doaccept(struct proc *, int, struct sockaddr *, socklen_t *, int,
 	    register_t *);
 
@@ -354,12 +382,14 @@ void	sblastrecordchk(struct sockbuf *, const char *);
 
 void	sblastmbufchk(struct sockbuf *, const char *);
 #define	SBLASTMBUFCHK(sb, where)	sblastmbufchk((sb), (where))
-void	sbcheck(struct sockbuf *sb);
-#define	SBCHECK(sb)			sbcheck(sb)
+void	sbcheck(struct socket *, struct sockbuf *);
+#define	SBCHECK(so, sb)			sbcheck((so), (sb))
 #else
 #define	SBLASTRECORDCHK(sb, where)	/* nothing */
 #define	SBLASTMBUFCHK(sb, where)	/* nothing */
-#define	SBCHECK(sb)			/* nothing */
+#define	SBCHECK(so, sb)			/* nothing */
 #endif /* SOCKBUF_DEBUG */
 
 #endif /* _KERNEL */
+
+#endif /* _SYS_SOCKETVAR_H_ */
diff --git a/sys/sys/sockio.h b/sys/sys/sockio.h
index 1198dd8..e876572 100644
--- a/sys/sys/sockio.h
+++ b/sys/sys/sockio.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: sockio.h,v 1.83 2019/11/13 11:54:01 tobhe Exp $	*/
+/*	$OpenBSD: sockio.h,v 1.84 2021/11/11 10:03:10 claudio Exp $	*/
 /*	$NetBSD: sockio.h,v 1.5 1995/08/23 00:40:47 thorpej Exp $	*/
 
 /*-
@@ -109,13 +109,6 @@
 #define SIOCBRDGGPARAM  _IOWR('i', 88, struct ifbropreq)/* get brdg STP parms */
 #define SIOCBRDGSTXHC    _IOW('i', 89, struct ifbrparam)/* set tx hold count */
 #define SIOCBRDGSPROTO	 _IOW('i', 90, struct ifbrparam)/* set protocol */
-#define SIOCBRDGS
-
-#define	SIOCSWGDPID	_IOWR('i', 91, struct ifbrparam)/* get datapath id */
-#define	SIOCSWSDPID	 _IOW('i', 92, struct ifbrparam)/* set datapath id */
-#define	SIOCSWGMAXGROUP	_IOWR('i', 93, struct ifbrparam)/* get max groups */
-#define	SIOCSWSPORTNO	_IOWR('i', 95, struct ifbreq)	/* set port number */
-#define	SIOCSWGMAXFLOW	_IOWR('i', 96, struct ifbrparam)/* get max flow per table */
 
 #define	SIOCSIFMTU	 _IOW('i', 127, struct ifreq)	/* set ifnet mtu */
 #define	SIOCGIFMTU	_IOWR('i', 126, struct ifreq)	/* get ifnet mtu */
diff --git a/sys/sys/specdev.h b/sys/sys/specdev.h
index 2570b20..107c2c9 100644
--- a/sys/sys/specdev.h
+++ b/sys/sys/specdev.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: specdev.h,v 1.39 2019/12/27 22:17:01 bluhm Exp $	*/
+/*	$OpenBSD: specdev.h,v 1.41 2022/06/26 05:20:42 visa Exp $	*/
 /*	$NetBSD: specdev.h,v 1.12 1996/02/13 13:13:01 mycroft Exp $	*/
 
 /*
@@ -92,7 +92,6 @@ extern struct vnodechain speclisth[SPECHSZ];
 /*
  * Prototypes for special file operations on vnodes.
  */
-int	spec_badop(void *);
 int	spec_getattr(void *);
 int	spec_setattr(void *);
 int	spec_access(void *);
@@ -101,7 +100,6 @@ int	spec_close(void *);
 int	spec_read(void *);
 int	spec_write(void *);
 int	spec_ioctl(void *);
-int	spec_poll(void *);
 int	spec_kqfilter(void *);
 int	spec_fsync(void *);
 int	spec_inactive(void *);
diff --git a/sys/sys/stat.h b/sys/sys/stat.h
index 564548f..ce1040f 100644
--- a/sys/sys/stat.h
+++ b/sys/sys/stat.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: stat.h,v 1.28 2015/04/04 18:06:08 jca Exp $	*/
+/*	$OpenBSD: stat.h,v 1.29 2022/01/11 23:59:55 jsg Exp $	*/
 /*	$NetBSD: stat.h,v 1.20 1996/05/16 22:17:49 cgd Exp $	*/
 
 /*-
@@ -141,7 +141,7 @@ struct stat {
 #endif
 
 #if __POSIX_VISIBLE >= 200809
-/* manadated to be present, but permitted to always return zero */
+/* mandated to be present, but permitted to always return zero */
 #define	S_TYPEISMQ(m)	0
 #define	S_TYPEISSEM(m)	0
 #define	S_TYPEISSHM(m)	0
diff --git a/sys/sys/statvfs.h b/sys/sys/statvfs.h
index 7c6492b..5381ed9 100644
--- a/sys/sys/statvfs.h
+++ b/sys/sys/statvfs.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: statvfs.h,v 1.3 2013/03/24 17:45:50 deraadt Exp $	*/
+/*	$OpenBSD: statvfs.h,v 1.4 2022/02/11 15:11:35 millert Exp $	*/
 
 /*
  * Copyright (c) 2008 Otto Moerbeek <otto@drijf.net>
@@ -29,7 +29,7 @@ struct statvfs {
 	fsblkcnt_t	f_bavail;	/* free blocks for non-root */
 	fsfilcnt_t	f_files;	/* total file inodes */
 	fsfilcnt_t	f_ffree;	/* free file inodes */
-	fsfilcnt_t	f_favail;	/* free file inodes for to non-root */
+	fsfilcnt_t	f_favail;	/* free file inodes for non-root */
 	unsigned long	f_fsid;		/* file system id */
 	unsigned long	f_flag;		/* bit mask of f_flag values */
 	unsigned long	f_namemax;	/* maximum filename length */
diff --git a/sys/sys/syscall.h b/sys/sys/syscall.h
index 3500f7f..377de29 100644
--- a/sys/sys/syscall.h
+++ b/sys/sys/syscall.h
@@ -1,10 +1,10 @@
-/*	$OpenBSD: syscall.h,v 1.215 2020/03/18 19:35:00 anton Exp $	*/
+/*	$OpenBSD: syscall.h,v 1.261 2023/02/27 00:58:38 deraadt Exp $	*/
 
 /*
  * System call numbers.
  *
  * DO NOT EDIT-- this file is automatically generated.
- * created from;	OpenBSD: syscalls.master,v 1.207 2020/03/18 19:33:36 anton Exp 
+ * created from;	OpenBSD: syscalls.master,v 1.246 2023/02/25 09:55:46 mvs Exp 
  */
 
 /* syscall: "syscall" ret: "int" args: "int" "..." */
@@ -22,7 +22,7 @@
 /* syscall: "write" ret: "ssize_t" args: "int" "const void *" "size_t" */
 #define	SYS_write	4
 
-/* syscall: "open" ret: "int" args: "const char *" "int" "..." */
+/* syscall: "open" ret: "int" args: "const char *" "int" "..." "mode_t" */
 #define	SYS_open	5
 
 /* syscall: "close" ret: "int" args: "int" */
@@ -154,7 +154,9 @@
 /* syscall: "sigprocmask" ret: "int" args: "int" "sigset_t" */
 #define	SYS_sigprocmask	48
 
-				/* 49 is obsolete ogetlogin */
+/* syscall: "mmap" ret: "void *" args: "void *" "size_t" "int" "int" "int" "off_t" */
+#define	SYS_mmap	49
+
 /* syscall: "setlogin" ret: "int" args: "const char *" */
 #define	SYS_setlogin	50
 
@@ -167,7 +169,7 @@
 /* syscall: "fstat" ret: "int" args: "int" "struct stat *" */
 #define	SYS_fstat	53
 
-/* syscall: "ioctl" ret: "int" args: "int" "u_long" "..." */
+/* syscall: "ioctl" ret: "int" args: "int" "u_long" "..." "void *" */
 #define	SYS_ioctl	54
 
 /* syscall: "reboot" ret: "int" args: "int" */
@@ -239,6 +241,9 @@
 /* syscall: "futimes" ret: "int" args: "int" "const struct timeval *" */
 #define	SYS_futimes	77
 
+/* syscall: "mquery" ret: "void *" args: "void *" "size_t" "int" "int" "int" "off_t" */
+#define	SYS_mquery	78
+
 /* syscall: "getgroups" ret: "int" args: "int" "gid_t *" */
 #define	SYS_getgroups	79
 
@@ -278,7 +283,7 @@
 /* syscall: "nanosleep" ret: "int" args: "const struct timespec *" "struct timespec *" */
 #define	SYS_nanosleep	91
 
-/* syscall: "fcntl" ret: "int" args: "int" "int" "..." */
+/* syscall: "fcntl" ret: "int" args: "int" "int" "..." "void *" */
 #define	SYS_fcntl	92
 
 /* syscall: "accept4" ret: "int" args: "int" "struct sockaddr *" "socklen_t *" "int" */
@@ -347,8 +352,12 @@
 /* syscall: "__realpath" ret: "int" args: "const char *" "char *" */
 #define	SYS___realpath	115
 
-				/* 116 is obsolete t32_gettimeofday */
-				/* 117 is obsolete t32_getrusage */
+/* syscall: "recvmmsg" ret: "int" args: "int" "struct mmsghdr *" "unsigned int" "int" "struct timespec *" */
+#define	SYS_recvmmsg	116
+
+/* syscall: "sendmmsg" ret: "int" args: "int" "struct mmsghdr *" "unsigned int" "int" */
+#define	SYS_sendmmsg	117
+
 /* syscall: "getsockopt" ret: "int" args: "int" "int" "int" "void *" "socklen_t *" */
 #define	SYS_getsockopt	118
 
@@ -411,11 +420,17 @@
 /* syscall: "getlogin_r" ret: "int" args: "char *" "u_int" */
 #define	SYS_getlogin_r	141
 
-				/* 142 is obsolete ogethostid */
-				/* 143 is obsolete osethostid */
+/* syscall: "getthrname" ret: "int" args: "pid_t" "char *" "size_t" */
+#define	SYS_getthrname	142
+
+/* syscall: "setthrname" ret: "int" args: "pid_t" "const char *" */
+#define	SYS_setthrname	143
+
 				/* 144 is obsolete ogetrlimit */
 				/* 145 is obsolete osetrlimit */
-				/* 146 is obsolete okillpg */
+/* syscall: "pinsyscall" ret: "int" args: "int" "void *" "size_t" */
+#define	SYS_pinsyscall	146
+
 /* syscall: "setsid" ret: "int" args: */
 #define	SYS_setsid	147
 
@@ -423,13 +438,21 @@
 #define	SYS_quotactl	148
 
 				/* 149 is obsolete oquota */
-				/* 150 is obsolete ogetsockname */
+/* syscall: "ypconnect" ret: "int" args: "int" */
+#define	SYS_ypconnect	150
+
 /* syscall: "nfssvc" ret: "int" args: "int" "void *" */
 #define	SYS_nfssvc	155
 
 				/* 156 is obsolete ogetdirentries */
 				/* 157 is obsolete statfs25 */
 				/* 158 is obsolete fstatfs25 */
+/* syscall: "mimmutable" ret: "int" args: "void *" "size_t" */
+#define	SYS_mimmutable	159
+
+/* syscall: "waitid" ret: "int" args: "int" "id_t" "siginfo_t *" "int" */
+#define	SYS_waitid	160
+
 /* syscall: "getfh" ret: "int" args: "const char *" "fhandle_t *" */
 #define	SYS_getfh	161
 
@@ -441,15 +464,29 @@
 /* syscall: "sysarch" ret: "int" args: "int" "void *" */
 #define	SYS_sysarch	165
 
-				/* 169 is obsolete semsys10 */
-				/* 170 is obsolete msgsys10 */
-				/* 171 is obsolete shmsys10 */
-/* syscall: "pread" ret: "ssize_t" args: "int" "void *" "size_t" "int" "off_t" */
-#define	SYS_pread	173
+/* syscall: "lseek" ret: "off_t" args: "int" "off_t" "int" */
+#define	SYS_lseek	166
+
+/* syscall: "truncate" ret: "int" args: "const char *" "off_t" */
+#define	SYS_truncate	167
+
+/* syscall: "ftruncate" ret: "int" args: "int" "off_t" */
+#define	SYS_ftruncate	168
 
-/* syscall: "pwrite" ret: "ssize_t" args: "int" "const void *" "size_t" "int" "off_t" */
-#define	SYS_pwrite	174
+/* syscall: "pread" ret: "ssize_t" args: "int" "void *" "size_t" "off_t" */
+#define	SYS_pread	169
 
+/* syscall: "pwrite" ret: "ssize_t" args: "int" "const void *" "size_t" "off_t" */
+#define	SYS_pwrite	170
+
+/* syscall: "preadv" ret: "ssize_t" args: "int" "const struct iovec *" "int" "off_t" */
+#define	SYS_preadv	171
+
+/* syscall: "pwritev" ret: "ssize_t" args: "int" "const struct iovec *" "int" "off_t" */
+#define	SYS_pwritev	172
+
+				/* 173 is obsolete pad_pread */
+				/* 174 is obsolete pad_pwrite */
 /* syscall: "setgid" ret: "int" args: "gid_t" */
 #define	SYS_setgid	181
 
@@ -482,21 +519,11 @@
 #define	SYS_setrlimit	195
 
 				/* 196 is obsolete ogetdirentries48 */
-/* syscall: "mmap" ret: "void *" args: "void *" "size_t" "int" "int" "int" "long" "off_t" */
-#define	SYS_mmap	197
-
-/* syscall: "__syscall" ret: "quad_t" args: "quad_t" "..." */
-#define	SYS___syscall	198
-
-/* syscall: "lseek" ret: "off_t" args: "int" "int" "off_t" "int" */
-#define	SYS_lseek	199
-
-/* syscall: "truncate" ret: "int" args: "const char *" "int" "off_t" */
-#define	SYS_truncate	200
-
-/* syscall: "ftruncate" ret: "int" args: "int" "int" "off_t" */
-#define	SYS_ftruncate	201
-
+				/* 197 is obsolete pad_mmap */
+				/* 198 is obsolete __syscall */
+				/* 199 is obsolete pad_lseek */
+				/* 200 is obsolete pad_truncate */
+				/* 201 is obsolete pad_ftruncate */
 /* syscall: "sysctl" ret: "int" args: "const int *" "u_int" "void *" "size_t *" "void *" "size_t" */
 #define	SYS_sysctl	202
 
@@ -567,12 +594,8 @@
 /* syscall: "fhopen" ret: "int" args: "const fhandle_t *" "int" */
 #define	SYS_fhopen	264
 
-/* syscall: "preadv" ret: "ssize_t" args: "int" "const struct iovec *" "int" "int" "off_t" */
-#define	SYS_preadv	267
-
-/* syscall: "pwritev" ret: "ssize_t" args: "int" "const struct iovec *" "int" "int" "off_t" */
-#define	SYS_pwritev	268
-
+				/* 267 is obsolete pad_preadv */
+				/* 268 is obsolete pad_pwritev */
 /* syscall: "kqueue" ret: "int" args: */
 #define	SYS_kqueue	269
 
@@ -596,9 +619,7 @@
 #define	SYS_setresgid	284
 
 				/* 285 is obsolete sys_omquery */
-/* syscall: "mquery" ret: "void *" args: "void *" "size_t" "int" "int" "int" "long" "off_t" */
-#define	SYS_mquery	286
-
+				/* 286 is obsolete pad_mquery */
 /* syscall: "closefrom" ret: "int" args: "int" */
 #define	SYS_closefrom	287
 
@@ -681,7 +702,7 @@
 /* syscall: "mknodat" ret: "int" args: "int" "const char *" "mode_t" "dev_t" */
 #define	SYS_mknodat	320
 
-/* syscall: "openat" ret: "int" args: "int" "const char *" "int" "..." */
+/* syscall: "openat" ret: "int" args: "int" "const char *" "int" "..." "mode_t" */
 #define	SYS_openat	321
 
 /* syscall: "readlinkat" ret: "ssize_t" args: "int" "const char *" "char *" "size_t" */
diff --git a/sys/sys/syscall_mi.h b/sys/sys/syscall_mi.h
index 76f34e0..7f88ce7 100644
--- a/sys/sys/syscall_mi.h
+++ b/sys/sys/syscall_mi.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: syscall_mi.h,v 1.25 2020/01/21 16:16:23 mpi Exp $	*/
+/*	$OpenBSD: syscall_mi.h,v 1.28 2023/02/11 23:07:23 deraadt Exp $	*/
 
 /*
  * Copyright (c) 1982, 1986, 1989, 1993
@@ -34,6 +34,7 @@
 #include <sys/param.h>
 #include <sys/pledge.h>
 #include <sys/tracepoint.h>
+#include <sys/syscall.h>
 #include <uvm/uvm_extern.h>
 
 #ifdef KTRACE
@@ -50,8 +51,8 @@
  * The MD setup for a system call has been done; here's the MI part.
  */
 static inline int
-mi_syscall(struct proc *p, register_t code, const struct sysent *callp,
-    register_t *argp, register_t retval[2])
+mi_syscall(struct proc *p, register_t code, int indirect,
+    const struct sysent *callp, register_t *argp, register_t retval[2])
 {
 	uint64_t tval;
 	int lock = !(callp->sy_flags & SY_NOLOCK);
@@ -71,8 +72,16 @@ mi_syscall(struct proc *p, register_t code, const struct sysent *callp,
 #endif
 #ifdef KTRACE
 	if (KTRPOINT(p, KTR_SYSCALL)) {
+		/* convert to mask, then include with code */
+		switch (indirect) {
+		case SYS_syscall:
+			indirect = KTRC_CODE_SYSCALL;
+			break;
+		default:
+			indirect = 0;
+		}
 		KERNEL_LOCK();
-		ktrsyscall(p, code, callp->sy_argsize, argp);
+		ktrsyscall(p, code | indirect, callp->sy_argsize, argp);
 		KERNEL_UNLOCK();
 	}
 #endif
@@ -89,16 +98,15 @@ mi_syscall(struct proc *p, register_t code, const struct sysent *callp,
 	    uvm_map_inentry_pc, p->p_vmspace->vm_map.wserial))
 		return (EPERM);
 
-	if (lock)
-		KERNEL_LOCK();
 	pledged = (p->p_p->ps_flags & PS_PLEDGE);
 	if (pledged && (error = pledge_syscall(p, code, &tval))) {
-		if (!lock)
-			KERNEL_LOCK();
+		KERNEL_LOCK();
 		error = pledge_fail(p, error, tval);
 		KERNEL_UNLOCK();
 		return (error);
 	}
+	if (lock)
+		KERNEL_LOCK();
 	error = (*callp->sy_call)(p, argp, retval);
 	if (lock)
 		KERNEL_UNLOCK();
diff --git a/sys/sys/syscallargs.h b/sys/sys/syscallargs.h
index 2209606..567f0cd 100644
--- a/sys/sys/syscallargs.h
+++ b/sys/sys/syscallargs.h
@@ -1,10 +1,10 @@
-/*	$OpenBSD: syscallargs.h,v 1.218 2020/03/18 19:35:00 anton Exp $	*/
+/*	$OpenBSD: syscallargs.h,v 1.264 2023/02/27 00:58:38 deraadt Exp $	*/
 
 /*
  * System call argument lists.
  *
  * DO NOT EDIT-- this file is automatically generated.
- * created from;	OpenBSD: syscalls.master,v 1.207 2020/03/18 19:33:36 anton Exp 
+ * created from;	OpenBSD: syscalls.master,v 1.246 2023/02/25 09:55:46 mvs Exp 
  */
 
 #ifdef	syscallarg
@@ -237,6 +237,15 @@ struct sys_sigprocmask_args {
 	syscallarg(sigset_t) mask;
 };
 
+struct sys_mmap_args {
+	syscallarg(void *) addr;
+	syscallarg(size_t) len;
+	syscallarg(int) prot;
+	syscallarg(int) flags;
+	syscallarg(int) fd;
+	syscallarg(off_t) pos;
+};
+
 struct sys_setlogin_args {
 	syscallarg(const char *) namebuf;
 };
@@ -375,6 +384,15 @@ struct sys_futimes_args {
 	syscallarg(const struct timeval *) tptr;
 };
 
+struct sys_mquery_args {
+	syscallarg(void *) addr;
+	syscallarg(size_t) len;
+	syscallarg(int) prot;
+	syscallarg(int) flags;
+	syscallarg(int) fd;
+	syscallarg(off_t) pos;
+};
+
 struct sys_getgroups_args {
 	syscallarg(int) gidsetsize;
 	syscallarg(gid_t *) gidset;
@@ -577,6 +595,21 @@ struct sys___realpath_args {
 	syscallarg(char *) resolved;
 };
 
+struct sys_recvmmsg_args {
+	syscallarg(int) s;
+	syscallarg(struct mmsghdr *) mmsg;
+	syscallarg(unsigned int) vlen;
+	syscallarg(int) flags;
+	syscallarg(struct timespec *) timeout;
+};
+
+struct sys_sendmmsg_args {
+	syscallarg(int) s;
+	syscallarg(struct mmsghdr *) mmsg;
+	syscallarg(unsigned int) vlen;
+	syscallarg(int) flags;
+};
+
 struct sys_getsockopt_args {
 	syscallarg(int) s;
 	syscallarg(int) level;
@@ -684,6 +717,23 @@ struct sys_getlogin_r_args {
 	syscallarg(u_int) namelen;
 };
 
+struct sys_getthrname_args {
+	syscallarg(pid_t) tid;
+	syscallarg(char *) name;
+	syscallarg(size_t) len;
+};
+
+struct sys_setthrname_args {
+	syscallarg(pid_t) tid;
+	syscallarg(const char *) name;
+};
+
+struct sys_pinsyscall_args {
+	syscallarg(int) syscall;
+	syscallarg(void *) addr;
+	syscallarg(size_t) len;
+};
+
 struct sys_quotactl_args {
 	syscallarg(const char *) path;
 	syscallarg(int) cmd;
@@ -691,11 +741,27 @@ struct sys_quotactl_args {
 	syscallarg(char *) arg;
 };
 
+struct sys_ypconnect_args {
+	syscallarg(int) type;
+};
+
 struct sys_nfssvc_args {
 	syscallarg(int) flag;
 	syscallarg(void *) argp;
 };
 
+struct sys_mimmutable_args {
+	syscallarg(void *) addr;
+	syscallarg(size_t) len;
+};
+
+struct sys_waitid_args {
+	syscallarg(int) idtype;
+	syscallarg(id_t) id;
+	syscallarg(siginfo_t *) info;
+	syscallarg(int) options;
+};
+
 struct sys_getfh_args {
 	syscallarg(const char *) fname;
 	syscallarg(fhandle_t *) fhp;
@@ -710,11 +776,26 @@ struct sys_sysarch_args {
 	syscallarg(void *) parms;
 };
 
+struct sys_lseek_args {
+	syscallarg(int) fd;
+	syscallarg(off_t) offset;
+	syscallarg(int) whence;
+};
+
+struct sys_truncate_args {
+	syscallarg(const char *) path;
+	syscallarg(off_t) length;
+};
+
+struct sys_ftruncate_args {
+	syscallarg(int) fd;
+	syscallarg(off_t) length;
+};
+
 struct sys_pread_args {
 	syscallarg(int) fd;
 	syscallarg(void *) buf;
 	syscallarg(size_t) nbyte;
-	syscallarg(int) pad;
 	syscallarg(off_t) offset;
 };
 
@@ -722,7 +803,20 @@ struct sys_pwrite_args {
 	syscallarg(int) fd;
 	syscallarg(const void *) buf;
 	syscallarg(size_t) nbyte;
-	syscallarg(int) pad;
+	syscallarg(off_t) offset;
+};
+
+struct sys_preadv_args {
+	syscallarg(int) fd;
+	syscallarg(const struct iovec *) iovp;
+	syscallarg(int) iovcnt;
+	syscallarg(off_t) offset;
+};
+
+struct sys_pwritev_args {
+	syscallarg(int) fd;
+	syscallarg(const struct iovec *) iovp;
+	syscallarg(int) iovcnt;
 	syscallarg(off_t) offset;
 };
 
@@ -764,35 +858,6 @@ struct sys_setrlimit_args {
 	syscallarg(const struct rlimit *) rlp;
 };
 
-struct sys_mmap_args {
-	syscallarg(void *) addr;
-	syscallarg(size_t) len;
-	syscallarg(int) prot;
-	syscallarg(int) flags;
-	syscallarg(int) fd;
-	syscallarg(long) pad;
-	syscallarg(off_t) pos;
-};
-
-struct sys_lseek_args {
-	syscallarg(int) fd;
-	syscallarg(int) pad;
-	syscallarg(off_t) offset;
-	syscallarg(int) whence;
-};
-
-struct sys_truncate_args {
-	syscallarg(const char *) path;
-	syscallarg(int) pad;
-	syscallarg(off_t) length;
-};
-
-struct sys_ftruncate_args {
-	syscallarg(int) fd;
-	syscallarg(int) pad;
-	syscallarg(off_t) length;
-};
-
 struct sys_sysctl_args {
 	syscallarg(const int *) name;
 	syscallarg(u_int) namelen;
@@ -895,22 +960,6 @@ struct sys_fhopen_args {
 	syscallarg(int) flags;
 };
 
-struct sys_preadv_args {
-	syscallarg(int) fd;
-	syscallarg(const struct iovec *) iovp;
-	syscallarg(int) iovcnt;
-	syscallarg(int) pad;
-	syscallarg(off_t) offset;
-};
-
-struct sys_pwritev_args {
-	syscallarg(int) fd;
-	syscallarg(const struct iovec *) iovp;
-	syscallarg(int) iovcnt;
-	syscallarg(int) pad;
-	syscallarg(off_t) offset;
-};
-
 struct sys_mlockall_args {
 	syscallarg(int) flags;
 };
@@ -939,16 +988,6 @@ struct sys_setresgid_args {
 	syscallarg(gid_t) sgid;
 };
 
-struct sys_mquery_args {
-	syscallarg(void *) addr;
-	syscallarg(size_t) len;
-	syscallarg(int) prot;
-	syscallarg(int) flags;
-	syscallarg(int) fd;
-	syscallarg(long) pad;
-	syscallarg(off_t) pos;
-};
-
 struct sys_closefrom_args {
 	syscallarg(int) fd;
 };
@@ -1167,6 +1206,7 @@ int	sys_ktrace(struct proc *, void *, register_t *);
 int	sys_sigaction(struct proc *, void *, register_t *);
 int	sys_getgid(struct proc *, void *, register_t *);
 int	sys_sigprocmask(struct proc *, void *, register_t *);
+int	sys_mmap(struct proc *, void *, register_t *);
 int	sys_setlogin(struct proc *, void *, register_t *);
 #ifdef ACCOUNTING
 int	sys_acct(struct proc *, void *, register_t *);
@@ -1198,6 +1238,7 @@ int	sys_mprotect(struct proc *, void *, register_t *);
 int	sys_madvise(struct proc *, void *, register_t *);
 int	sys_utimes(struct proc *, void *, register_t *);
 int	sys_futimes(struct proc *, void *, register_t *);
+int	sys_mquery(struct proc *, void *, register_t *);
 int	sys_getgroups(struct proc *, void *, register_t *);
 int	sys_setgroups(struct proc *, void *, register_t *);
 int	sys_getpgrp(struct proc *, void *, register_t *);
@@ -1234,6 +1275,8 @@ int	sys_sigsuspend(struct proc *, void *, register_t *);
 int	sys_sendsyslog(struct proc *, void *, register_t *);
 int	sys_unveil(struct proc *, void *, register_t *);
 int	sys___realpath(struct proc *, void *, register_t *);
+int	sys_recvmmsg(struct proc *, void *, register_t *);
+int	sys_sendmmsg(struct proc *, void *, register_t *);
 int	sys_getsockopt(struct proc *, void *, register_t *);
 int	sys_thrkill(struct proc *, void *, register_t *);
 int	sys_readv(struct proc *, void *, register_t *);
@@ -1253,17 +1296,28 @@ int	sys_mkdir(struct proc *, void *, register_t *);
 int	sys_rmdir(struct proc *, void *, register_t *);
 int	sys_adjtime(struct proc *, void *, register_t *);
 int	sys_getlogin_r(struct proc *, void *, register_t *);
+int	sys_getthrname(struct proc *, void *, register_t *);
+int	sys_setthrname(struct proc *, void *, register_t *);
+int	sys_pinsyscall(struct proc *, void *, register_t *);
 int	sys_setsid(struct proc *, void *, register_t *);
 int	sys_quotactl(struct proc *, void *, register_t *);
+int	sys_ypconnect(struct proc *, void *, register_t *);
 #if defined(NFSCLIENT) || defined(NFSSERVER)
 int	sys_nfssvc(struct proc *, void *, register_t *);
 #else
 #endif
+int	sys_mimmutable(struct proc *, void *, register_t *);
+int	sys_waitid(struct proc *, void *, register_t *);
 int	sys_getfh(struct proc *, void *, register_t *);
 int	sys___tmpfd(struct proc *, void *, register_t *);
 int	sys_sysarch(struct proc *, void *, register_t *);
+int	sys_lseek(struct proc *, void *, register_t *);
+int	sys_truncate(struct proc *, void *, register_t *);
+int	sys_ftruncate(struct proc *, void *, register_t *);
 int	sys_pread(struct proc *, void *, register_t *);
 int	sys_pwrite(struct proc *, void *, register_t *);
+int	sys_preadv(struct proc *, void *, register_t *);
+int	sys_pwritev(struct proc *, void *, register_t *);
 int	sys_setgid(struct proc *, void *, register_t *);
 int	sys_setegid(struct proc *, void *, register_t *);
 int	sys_seteuid(struct proc *, void *, register_t *);
@@ -1272,10 +1326,6 @@ int	sys_fpathconf(struct proc *, void *, register_t *);
 int	sys_swapctl(struct proc *, void *, register_t *);
 int	sys_getrlimit(struct proc *, void *, register_t *);
 int	sys_setrlimit(struct proc *, void *, register_t *);
-int	sys_mmap(struct proc *, void *, register_t *);
-int	sys_lseek(struct proc *, void *, register_t *);
-int	sys_truncate(struct proc *, void *, register_t *);
-int	sys_ftruncate(struct proc *, void *, register_t *);
 int	sys_sysctl(struct proc *, void *, register_t *);
 int	sys_mlock(struct proc *, void *, register_t *);
 int	sys_munlock(struct proc *, void *, register_t *);
@@ -1304,8 +1354,6 @@ int	sys_getsid(struct proc *, void *, register_t *);
 int	sys_msync(struct proc *, void *, register_t *);
 int	sys_pipe(struct proc *, void *, register_t *);
 int	sys_fhopen(struct proc *, void *, register_t *);
-int	sys_preadv(struct proc *, void *, register_t *);
-int	sys_pwritev(struct proc *, void *, register_t *);
 int	sys_kqueue(struct proc *, void *, register_t *);
 int	sys_mlockall(struct proc *, void *, register_t *);
 int	sys_munlockall(struct proc *, void *, register_t *);
@@ -1313,7 +1361,6 @@ int	sys_getresuid(struct proc *, void *, register_t *);
 int	sys_setresuid(struct proc *, void *, register_t *);
 int	sys_getresgid(struct proc *, void *, register_t *);
 int	sys_setresgid(struct proc *, void *, register_t *);
-int	sys_mquery(struct proc *, void *, register_t *);
 int	sys_closefrom(struct proc *, void *, register_t *);
 int	sys_sigaltstack(struct proc *, void *, register_t *);
 #ifdef SYSVSHM
diff --git a/sys/sys/sysctl.h b/sys/sys/sysctl.h
index 5e5115d..ee79387 100644
--- a/sys/sys/sysctl.h
+++ b/sys/sys/sysctl.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: sysctl.h,v 1.211 2020/09/01 01:53:50 gnezdo Exp $	*/
+/*	$OpenBSD: sysctl.h,v 1.232 2023/01/07 05:24:58 guenther Exp $	*/
 /*	$NetBSD: sysctl.h,v 1.16 1996/04/09 20:55:36 cgd Exp $	*/
 
 /*
@@ -38,6 +38,7 @@
 #ifndef _SYS_SYSCTL_H_
 #define	_SYS_SYSCTL_H_
 
+#include <sys/syslimits.h>
 #include <uvm/uvmexp.h>
 
 /*
@@ -134,7 +135,7 @@ struct ctlname {
 /* was KERN_RND	31			*/
 #define	KERN_NOSUIDCOREDUMP	32	/* int: no setuid coredumps ever */ 
 #define	KERN_FSYNC		33	/* int: file synchronization support */
-#define	KERN_SYSVMSG		34	/* int: SysV message queue suppoprt */
+#define	KERN_SYSVMSG		34	/* int: SysV message queue support */
 #define	KERN_SYSVSEM		35	/* int: SysV semaphore support */
 #define	KERN_SYSVSHM		36	/* int: SysV shared memory support */
 /* was KERN_ARND		37	*/
@@ -143,7 +144,7 @@ struct ctlname {
 #define KERN_CPTIME		40	/* array: cp_time */
 #define KERN_NCHSTATS		41	/* struct: vfs cache statistics */
 #define KERN_FORKSTAT		42	/* struct: fork statistics */
-#define KERN_NSELCOLL		43	/* int: select(2) collisions */
+/* was KERN_NSELCOLL		43	*/
 #define KERN_TTY		44	/* node: tty information */
 #define	KERN_CCPU		45	/* int: ccpu */
 #define	KERN_FSCALE		46	/* int: fscale */
@@ -189,7 +190,10 @@ struct ctlname {
 #define	KERN_PFSTATUS		86	/* struct: pf status and stats */
 #define	KERN_TIMEOUT_STATS	87	/* struct: timeout status and stats */
 #define	KERN_UTC_OFFSET		88	/* int: adjust RTC time to UTC */
-#define	KERN_MAXID		89	/* number of valid kern ids */
+#define	KERN_VIDEO		89	/* struct: video properties */
+#define	KERN_CLOCKINTR		90	/* node: clockintr */
+#define	KERN_AUTOCONF_SERIAL	91	/* int: kernel device tree state serial */
+#define	KERN_MAXID		92	/* number of valid kern ids */
 
 #define	CTL_KERN_NAMES { \
 	{ 0, 0 }, \
@@ -235,7 +239,7 @@ struct ctlname {
 	{ "cp_time", CTLTYPE_STRUCT }, \
 	{ "nchstats", CTLTYPE_STRUCT }, \
 	{ "forkstat", CTLTYPE_STRUCT }, \
-	{ "nselcoll", CTLTYPE_INT }, \
+	{ "gap", 0 }, \
 	{ "tty", CTLTYPE_NODE }, \
 	{ "ccpu", CTLTYPE_INT }, \
 	{ "fscale", CTLTYPE_INT }, \
@@ -281,6 +285,9 @@ struct ctlname {
 	{ "pfstatus", CTLTYPE_STRUCT }, \
 	{ "timeout_stats", CTLTYPE_STRUCT }, \
 	{ "utc_offset", CTLTYPE_INT }, \
+	{ "video", CTLTYPE_STRUCT }, \
+ 	{ "clockintr", CTLTYPE_NODE }, \
+	{ "autoconf_serial", CTLTYPE_INT }, \
 }
 
 /*
@@ -322,6 +329,17 @@ struct ctlname {
 	{ "record", CTLTYPE_INT }, \
 }
 
+/*
+ * KERN_VIDEO
+ */
+#define KERN_VIDEO_RECORD	1
+#define KERN_VIDEO_MAXID	2
+
+#define CTL_KERN_VIDEO_NAMES { \
+	{ 0, 0 }, \
+	{ "record", CTLTYPE_INT }, \
+}
+
 /*
  * KERN_WITNESS
  */
@@ -342,7 +360,7 @@ struct ctlname {
  * binary compatibility can be preserved.
  */
 #define	KI_NGROUPS	16
-#define	KI_MAXCOMLEN	24	/* extra for 8 byte alignment */
+#define	KI_MAXCOMLEN	_MAXCOMLEN	/* includes NUL */
 #define	KI_WMESGLEN	8
 #define	KI_MAXLOGNAME	32
 #define	KI_EMULNAMELEN	8
@@ -419,7 +437,7 @@ struct kinfo_proc {
 	u_int8_t p_nice;		/* U_CHAR: Process "nice" value. */
 
 	u_int16_t p_xstat;		/* U_SHORT: Exit status for wait; also stop signal. */
-	u_int16_t p_acflag;		/* U_SHORT: Accounting flags. */
+	u_int16_t p_spare;		/* U_SHORT: unused */
 
 	char	p_comm[KI_MAXCOMLEN];
 
@@ -461,7 +479,7 @@ struct kinfo_proc {
 	u_int32_t p_uctime_sec;		/* STRUCT TIMEVAL: child u+s time. */
 	u_int32_t p_uctime_usec;	/* STRUCT TIMEVAL: child u+s time. */
 	u_int32_t p_psflags;		/* UINT: PS_* flags on the process. */
-	int32_t p_spare;		/* INT: unused. */
+	u_int32_t p_acflag;		/* UINT: Accounting flags. */
 	u_int32_t p_svuid;		/* UID_T: saved user id */
 	u_int32_t p_svgid;		/* GID_T: saved group id */
 	char    p_emul[KI_EMULNAMELEN];	/* syscall emulation name */
@@ -472,6 +490,7 @@ struct kinfo_proc {
 	u_int32_t p_rtableid;		/* U_INT: Routing table identifier. */
 
 	u_int64_t p_pledge;		/* U_INT64_T: Pledge flags. */
+	char	p_name[KI_MAXCOMLEN];	/* thread name */
 };
 
 /*
@@ -567,6 +586,8 @@ struct kinfo_vmentry {
 
 #define PTRTOINT64(_x)	((u_int64_t)(u_long)(_x))
 
+#define	_FILL_KPROC_MIN(a,b) (((a)<(b))?(a):(b))
+
 #define FILL_KPROC(kp, copy_str, p, pr, uc, pg, paddr, \
     praddr, sess, vm, lim, sa, isthread, show_addresses) \
 do {									\
@@ -597,7 +618,7 @@ do {									\
 	(kp)->p_svgid = (uc)->cr_svgid;					\
 									\
 	memcpy((kp)->p_groups, (uc)->cr_groups,				\
-	    MIN(sizeof((kp)->p_groups), sizeof((uc)->cr_groups)));	\
+	    _FILL_KPROC_MIN(sizeof((kp)->p_groups), sizeof((uc)->cr_groups))); \
 	(kp)->p_ngroups = (uc)->cr_ngroups;				\
 									\
 	(kp)->p_jobc = (pg)->pg_jobc;					\
@@ -610,6 +631,7 @@ do {									\
 		(kp)->p_uticks = (p)->p_tu.tu_uticks;			\
 		(kp)->p_sticks = (p)->p_tu.tu_sticks;			\
 		(kp)->p_iticks = (p)->p_tu.tu_iticks;			\
+		strlcpy((kp)->p_name, (p)->p_name, sizeof((kp)->p_name)); \
 	} else {							\
 		(kp)->p_rtime_sec = (pr)->ps_tu.tu_runtime.tv_sec;	\
 		(kp)->p_rtime_usec = (pr)->ps_tu.tu_runtime.tv_nsec/1000; \
@@ -626,9 +648,16 @@ do {									\
 									\
 	(kp)->p_siglist = (p)->p_siglist | (pr)->ps_siglist;		\
 	(kp)->p_sigmask = (p)->p_sigmask;				\
+									\
+	PR_LOCK(pr);							\
 	(kp)->p_sigignore = (sa) ? (sa)->ps_sigignore : 0;		\
 	(kp)->p_sigcatch = (sa) ? (sa)->ps_sigcatch : 0;		\
 									\
+	if (lim)							\
+		(kp)->p_rlim_rss_cur =					\
+		    (lim)->pl_rlimit[RLIMIT_RSS].rlim_cur;		\
+	PR_UNLOCK(pr);							\
+									\
 	(kp)->p_stat = (p)->p_stat;					\
 	(kp)->p_nice = (pr)->ps_nice;					\
 									\
@@ -636,12 +665,10 @@ do {									\
 	(kp)->p_acflag = (pr)->ps_acflag;				\
 	(kp)->p_pledge = (pr)->ps_pledge;				\
 									\
-	/* XXX depends on e_name being an array and not a pointer */	\
-	copy_str((kp)->p_emul, (char *)(pr)->ps_emul +			\
-	    offsetof(struct emul, e_name), sizeof((kp)->p_emul));	\
+	strlcpy((kp)->p_emul, "native", sizeof((kp)->p_emul));		\
 	strlcpy((kp)->p_comm, (pr)->ps_comm, sizeof((kp)->p_comm));	\
-	strlcpy((kp)->p_login, (sess)->s_login,			\
-	    MIN(sizeof((kp)->p_login), sizeof((sess)->s_login)));	\
+	strlcpy((kp)->p_login, (sess)->s_login,				\
+	    _FILL_KPROC_MIN(sizeof((kp)->p_login), sizeof((sess)->s_login))); \
 									\
 	if ((sess)->s_ttyvp)						\
 		(kp)->p_eflag |= EPROC_CTTY;				\
@@ -672,12 +699,6 @@ do {									\
 			(kp)->p_wchan = PTRTOINT64((p)->p_wchan);	\
 	}								\
 									\
-	PR_LOCK(pr);							\
-	if (lim)							\
-		(kp)->p_rlim_rss_cur =					\
-		    (lim)->pl_rlimit[RLIMIT_RSS].rlim_cur;		\
-	PR_UNLOCK(pr);							\
-									\
 	if (((pr)->ps_flags & PS_ZOMBIE) == 0) {			\
 		struct timeval __tv;					\
 									\
@@ -865,6 +886,17 @@ struct kinfo_file {
 	{ "choice", CTLTYPE_STRING }, \
 }
 
+/*
+ * KERN_CLOCKINTR
+ */
+#define KERN_CLOCKINTR_STATS		1	/* struct: stats */
+#define KERN_CLOCKINTR_MAXID		2
+
+#define CTL_KERN_CLOCKINTR_NAMES { \
+	{ 0, 0 }, \
+	{ "stats", CTLTYPE_STRUCT }, \
+}
+
 /*
  * CTL_FS identifiers
  */
@@ -915,7 +947,8 @@ struct kinfo_file {
 #define	HW_PERFPOLICY		23	/* set performance policy */
 #define	HW_SMT			24	/* int: enable SMT/HT/CMT */
 #define	HW_NCPUONLINE		25	/* int: number of cpus being used */
-#define	HW_MAXID		26	/* number of valid hw ids */
+#define	HW_POWER		26	/* int: machine has wall-power */
+#define	HW_MAXID		27	/* number of valid hw ids */
 
 #define	CTL_HW_NAMES { \
 	{ 0, 0 }, \
@@ -944,6 +977,7 @@ struct kinfo_file {
 	{ "perfpolicy", CTLTYPE_STRING }, \
 	{ "smt", CTLTYPE_INT }, \
 	{ "ncpuonline", CTLTYPE_INT }, \
+	{ "power", CTLTYPE_INT }, \
 }
 
 /*
@@ -966,7 +1000,7 @@ struct kinfo_file {
  * variable. The loader prevents multiple use by issuing errors
  * if a variable is initialized in more than one place. They are
  * aggregated into an array in debug_sysctl(), so that it can
- * conveniently locate them when querried. If more debugging
+ * conveniently locate them when queried. If more debugging
  * variables are added, they must also be declared here and also
  * entered into the array.
  */
@@ -984,9 +1018,12 @@ struct sysctl_bounded_args {
 	int mib;     /* identifier shared with userspace as a CTL_ #define */
 	int *var;    /* never NULL */
 	int minimum; /* checking is disabled if minimum == maximum  */
-	int maximum;
+	int maximum; /* read-only variable if minimum > maximum */
 };
 
+/* Special case minimum,maximum marker for sysctl_bounded_args. */
+#define SYSCTL_INT_READONLY	1,0
+
 /*
  * Internal sysctl function calling convention:
  *
@@ -998,10 +1035,11 @@ struct sysctl_bounded_args {
  */
 typedef int (sysctlfn)(int *, u_int, void *, size_t *, void *, size_t, struct proc *);
 
-int sysctl_int(void *, size_t *, void *, size_t, int *);
-int sysctl_int_bounded(void *, size_t *, void *, size_t, int *, int, int);
 int sysctl_int_lower(void *, size_t *, void *, size_t, int *);
+int sysctl_int(void *, size_t *, void *, size_t, int *);
 int sysctl_rdint(void *, size_t *, void *, int);
+int sysctl_securelevel_int(void *, size_t *, void *, size_t, int *);
+int sysctl_int_bounded(void *, size_t *, void *, size_t, int *, int, int);
 int sysctl_bounded_arr(const struct sysctl_bounded_args *, u_int,
     int *, u_int, void *, size_t *, void *, size_t);
 int sysctl_quad(void *, size_t *, void *, size_t, int64_t *);
@@ -1060,6 +1098,7 @@ int pflow_sysctl(int *, u_int, void *, size_t *, void *, size_t);
 int pipex_sysctl(int *, u_int, void *, size_t *, void *, size_t);
 int mpls_sysctl(int *, u_int, void *, size_t *, void *, size_t);
 int pf_sysctl(void *, size_t *, void *, size_t);
+int uipc_sysctl(int *, u_int, void *, size_t *, void *, size_t);
 
 #else	/* !_KERNEL */
 
diff --git a/sys/sys/syslimits.h b/sys/sys/syslimits.h
index 891c9b4..4ebc656 100644
--- a/sys/sys/syslimits.h
+++ b/sys/sys/syslimits.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: syslimits.h,v 1.14 2020/04/02 18:00:00 deraadt Exp $	*/
+/*	$OpenBSD: syslimits.h,v 1.15 2022/02/22 16:58:08 deraadt Exp $	*/
 /*	$NetBSD: syslimits.h,v 1.12 1995/10/05 05:26:19 thorpej Exp $	*/
 
 /*
@@ -75,3 +75,5 @@
 #if __POSIX_VISIBLE >= 200112
 #define HOST_NAME_MAX		255	/* max hostname length w/o NUL */
 #endif
+
+#define _MAXCOMLEN		24	/* includes NUL */
diff --git a/sys/sys/systm.h b/sys/sys/systm.h
index c982038..31a5622 100644
--- a/sys/sys/systm.h
+++ b/sys/sys/systm.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: systm.h,v 1.148 2020/08/26 03:29:07 visa Exp $	*/
+/*	$OpenBSD: systm.h,v 1.161 2023/01/31 15:18:56 deraadt Exp $	*/
 /*	$NetBSD: systm.h,v 1.50 1996/06/09 04:55:09 briggs Exp $	*/
 
 /*-
@@ -72,7 +72,6 @@
  */
 extern int securelevel;		/* system security level */
 extern const char *panicstr;	/* panic message */
-extern const char *faultstr;	/* fault message */
 extern const char version[];		/* system version */
 extern const char copyright[];	/* system copyright */
 extern const char ostype[];
@@ -92,7 +91,6 @@ extern int ncpusfound;		/* number of CPUs found */
 extern int nblkdev;		/* number of entries in bdevsw */
 extern int nchrdev;		/* number of entries in cdevsw */
 
-extern int selwait;		/* select timeout address */
 extern int maxmem;		/* max memory per process */
 extern int physmem;		/* physical memory */
 
@@ -103,17 +101,20 @@ extern dev_t rootdev;		/* root device */
 extern u_char bootduid[8];	/* boot device disklabel uid */
 extern u_char rootduid[8];	/* root device disklabel uid */
 extern struct vnode *rootvp;	/* vnode equivalent to above */
+extern struct device *rootdv;	/* device equivalent to above */
 
 extern dev_t swapdev;		/* swapping device */
 extern struct vnode *swapdev_vp;/* vnode equivalent to above */
 
+extern int nowake;		/* dead wakeup(9) channel */
+
 struct proc;
 struct process;
 #define curproc curcpu()->ci_curproc
 
 typedef int	sy_call_t(struct proc *, void *, register_t *);
 
-extern struct sysent {		/* system call table */
+extern const struct sysent {	/* system call table */
 	short	sy_narg;	/* number of args */
 	short	sy_argsize;	/* total size of arguments */
 	int	sy_flags;
@@ -150,13 +151,6 @@ int	enoioctl(void);
 int	enxio(void);
 int	eopnotsupp(void *);
 
-struct vnodeopv_desc;
-void vfs_opv_init_explicit(struct vnodeopv_desc *);
-void vfs_opv_init_default(struct vnodeopv_desc *);
-void vfs_op_init(void);
-
-int	seltrue(dev_t dev, int which, struct proc *);
-int	selfalse(dev_t dev, int which, struct proc *);
 void	*hashinit(int, int, int, u_long *);
 void	 hashfree(void *, int, int);
 int	sys_nosys(struct proc *, void *, register_t *);
@@ -207,13 +201,15 @@ void	*memmove(void *, const void *, size_t)
 void	*memset(void *, int, size_t)
 		__attribute__ ((__bounded__(__buffer__,1,3)));
 
-int	copystr(const void *, void *, size_t, size_t *)
-		__attribute__ ((__bounded__(__string__,2,3)));
 int	copyinstr(const void *, void *, size_t, size_t *)
 		__attribute__ ((__bounded__(__string__,2,3)));
+int	_copyinstr(const void *, void *, size_t, size_t *)
+		__attribute__ ((__bounded__(__string__,2,3)));
 int	copyoutstr(const void *, void *, size_t, size_t *);
 int	copyin(const void *, void *, size_t)
 		__attribute__ ((__bounded__(__buffer__,2,3)));
+int	_copyin(const void *, void *, size_t)
+		__attribute__ ((__bounded__(__buffer__,2,3)));
 int	copyout(const void *, void *, size_t);
 int	copyin32(const uint32_t *, uint32_t *);
 
@@ -255,13 +251,8 @@ void	stop_periodic_resettodr(void);
 
 struct sleep_state;
 void	sleep_setup(struct sleep_state *, const volatile void *, int,
-	    const char *);
-void	sleep_setup_timeout(struct sleep_state *, int);
-void	sleep_setup_signal(struct sleep_state *);
-void	sleep_finish(struct sleep_state *, int);
-int	sleep_finish_timeout(struct sleep_state *);
-int	sleep_finish_signal(struct sleep_state *);
-int	sleep_finish_all(struct sleep_state *, int);
+	    const char *, int);
+int	sleep_finish(struct sleep_state *, int);
 void	sleep_queue_init(void);
 
 struct cond;
@@ -335,23 +326,19 @@ extern struct rwlock netlock;
 #define	NET_UNLOCK()	do { rw_exit_write(&netlock); } while (0)
 
 /*
- * Reader version of NET_LOCK() to be used in "softnet" thread only.
-
+ * Reader version of NET_LOCK().
  * The "softnet" thread should be the only thread processing packets
  * without holding an exclusive lock.  This is done to allow read-only
  * ioctl(2) to not block.
- */
-#define	NET_RLOCK_IN_SOFTNET()	do { rw_enter_read(&netlock); } while (0)
-#define	NET_RUNLOCK_IN_SOFTNET()do { rw_exit_read(&netlock); } while (0)
-
-/*
- * Reader version of NET_LOCK() to be used in ioctl/sysctl path only.
- *
- * Can be grabbed instead of the exclusive version when no field
+ * Shared lock can be grabbed instead of the exclusive version if no field
  * protected by the NET_LOCK() is modified by the ioctl/sysctl.
+ * Socket system call can use shared netlock if it has additional locks
+ * to protect socket and pcb data structures.
  */
-#define	NET_RLOCK_IN_IOCTL()	do { rw_enter_read(&netlock); } while (0)
-#define	NET_RUNLOCK_IN_IOCTL()	do { rw_exit_read(&netlock); } while (0)
+#define	NET_LOCK_SHARED()	do { rw_enter_read(&netlock); } while (0)
+#define	NET_UNLOCK_SHARED()	do { rw_exit_read(&netlock); } while (0)
+
+#ifdef DIAGNOSTIC
 
 #define	NET_ASSERT_UNLOCKED()						\
 do {									\
@@ -367,6 +354,19 @@ do {									\
 		splassert_fail(RW_READ, _s, __func__);			\
 } while (0)
 
+#define	NET_ASSERT_LOCKED_EXCLUSIVE()					\
+do {									\
+	int _s = rw_status(&netlock);					\
+	if ((splassert_ctl > 0) && (_s != RW_WRITE))			\
+		splassert_fail(RW_WRITE, _s, __func__);			\
+} while (0)
+
+#else /* DIAGNOSTIC */
+#define	NET_ASSERT_UNLOCKED()		do {} while (0)
+#define	NET_ASSERT_LOCKED()		do {} while (0)
+#define	NET_ASSERT_LOCKED_EXCLUSIVE()	do {} while (0)
+#endif /* !DIAGNOSTIC */
+
 __returns_twice int	setjmp(label_t *);
 __dead void	longjmp(label_t *);
 #endif
@@ -398,6 +398,7 @@ extern int (*mountroot)(void);
 #if defined(DDB)
 /* debugger entry points */
 void	db_enter(void);	/* in DDB only */
+int	db_rint(int);
 #endif
 
 #ifdef BOOT_CONFIG
diff --git a/sys/sys/termios.h b/sys/sys/termios.h
index af21a97..681c294 100644
--- a/sys/sys/termios.h
+++ b/sys/sys/termios.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: termios.h,v 1.13 2016/09/20 21:10:22 fcambus Exp $	*/
+/*	$OpenBSD: termios.h,v 1.14 2022/12/30 23:41:45 millert Exp $	*/
 /*	$NetBSD: termios.h,v 1.14 1996/04/09 20:55:41 cgd Exp $	*/
 
 /*
@@ -111,10 +111,15 @@
 #if __XPG_VISIBLE
 #define ONLCR		0x00000002	/* map NL to CR-NL (ala CRMOD) */
 #endif
+#if __BSD_VISIBLE || __XPG_VISIBLE
+#define TABDLY		0x00000004	/* horizontal tab delay mask */
+#define TAB0		0x00000000	/* no tab delay or expansion */
+#define TAB3		0x00000004	/* expand tabs to spaces */
 #if __BSD_VISIBLE
-#define OXTABS		0x00000004	/* expand tabs to spaces */
+#define OXTABS		TAB3		/* BSD name for TAB3 */
 #define ONOEOT		0x00000008	/* discard EOT's (^D) on output */
 #endif
+#endif
 #if __XPG_VISIBLE
 #define OCRNL		0x00000010	/* map CR to NL */
 #define OLCUC		0x00000020	/* translate lower case to upper case */
diff --git a/sys/sys/time.h b/sys/sys/time.h
index 69e58e9..20bfba4 100644
--- a/sys/sys/time.h
+++ b/sys/sys/time.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: time.h,v 1.55 2020/07/06 13:33:09 pirofti Exp $	*/
+/*	$OpenBSD: time.h,v 1.63 2022/12/13 17:30:36 cheloha Exp $	*/
 /*	$NetBSD: time.h,v 1.18 1996/04/23 10:29:33 mycroft Exp $	*/
 
 /*
@@ -157,7 +157,6 @@ struct	itimerval {
 struct clockinfo {
 	int	hz;		/* clock frequency */
 	int	tick;		/* micro-seconds per hz tick */
-	int	tickadj;	/* clock skew rate for adjtime() */
 	int	stathz;		/* statistics clock frequency */
 	int	profhz;		/* profiling clock frequency */
 };
@@ -209,6 +208,17 @@ bintimesub(const struct bintime *bt, const struct bintime *ct,
 	dt->frac = bt->frac - ct->frac;
 }
 
+static inline void
+TIMECOUNT_TO_BINTIME(u_int count, uint64_t scale, struct bintime *bt)
+{
+	uint64_t hi64;
+
+	hi64 = count * (scale >> 32);
+	bt->sec = hi64 >> 32;
+	bt->frac = hi64 << 32;
+	bintimeaddfrac(bt, count * (scale & 0xffffffff), bt);
+}
+
 /*-
  * Background information:
  *
@@ -223,11 +233,17 @@ bintimesub(const struct bintime *bt, const struct bintime *ct,
  *   time_second ticks after N.999999999 not after N.4999999999
  */
 
+static inline uint32_t
+FRAC_TO_NSEC(uint64_t frac)
+{
+	return ((frac >> 32) * 1000000000ULL) >> 32;
+}
+
 static inline void
 BINTIME_TO_TIMESPEC(const struct bintime *bt, struct timespec *ts)
 {
 	ts->tv_sec = bt->sec;
-	ts->tv_nsec = (long)(((uint64_t)1000000000 * (uint32_t)(bt->frac >> 32)) >> 32);
+	ts->tv_nsec = FRAC_TO_NSEC(bt->frac);
 }
 
 static inline void
@@ -291,6 +307,7 @@ void	binuptime(struct bintime *);
 void	nanouptime(struct timespec *);
 void	microuptime(struct timeval *);
 
+void	getbinuptime(struct bintime *);
 void	getnanouptime(struct timespec *);
 void	getmicrouptime(struct timeval *);
 
@@ -301,13 +318,19 @@ void	nanoboottime(struct timespec *);
 void	binruntime(struct bintime *);
 void	nanoruntime(struct timespec *);
 
+void getbinruntime(struct bintime *);
+uint64_t getnsecruntime(void);
+
 time_t	gettime(void);
 time_t	getuptime(void);
 
+uint64_t	nsecuptime(void);
+uint64_t	getnsecuptime(void);
+
 struct proc;
 int	clock_gettime(struct proc *, clockid_t, struct timespec *);
 
-int	itimerfix(struct timeval *);
+void	cancel_all_itimers(void);
 int	itimerdecr(struct itimerspec *, long);
 int	settime(const struct timespec *);
 int	ratecheck(struct timeval *, const struct timeval *);
@@ -409,6 +432,12 @@ TIMESPEC_TO_NSEC(const struct timespec *ts)
 	return ts->tv_sec * 1000000000ULL + ts->tv_nsec;
 }
 
+static inline uint64_t
+BINTIME_TO_NSEC(const struct bintime *bt)
+{
+	return bt->sec * 1000000000ULL + FRAC_TO_NSEC(bt->frac);
+}
+
 #else /* !_KERNEL */
 #include <time.h>
 
diff --git a/sys/sys/timeout.h b/sys/sys/timeout.h
index 4c6ac5a..56fb0dd 100644
--- a/sys/sys/timeout.h
+++ b/sys/sys/timeout.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: timeout.h,v 1.39 2020/08/07 00:45:25 cheloha Exp $	*/
+/*	$OpenBSD: timeout.h,v 1.47 2022/12/31 16:06:24 cheloha Exp $	*/
 /*
  * Copyright (c) 2000-2001 Artur Grabowski <art@openbsd.org>
  * All rights reserved. 
@@ -27,29 +27,7 @@
 #ifndef _SYS_TIMEOUT_H_
 #define _SYS_TIMEOUT_H_
 
-/*
- * Interface for handling time driven events in the kernel.
- *
- * The basic component of this API is the struct timeout. The user should not
- * touch the internals of this structure, but it's the users responsibility
- * to allocate and deallocate timeouts.
- *
- * The functions used to manipulate timeouts are:
- *  - timeout_set(timeout, function, argument)
- *      Initializes a timeout struct to call the function with the argument.
- *      A timeout only needs to be initialized once.
- *  - timeout_add(timeout, ticks)
- *      Schedule this timeout to run in "ticks" ticks (there are hz ticks in
- *      one second). You may not touch the timeout with timeout_set once the
- *      timeout is scheduled. A second call to timeout_add with an already
- *      scheduled timeout will cause the old timeout to be canceled and the
- *      new will be scheduled.
- *  - timeout_del(timeout)
- *      Remove the timeout from the timeout queue. It's legal to remove
- *      a timeout that has already happened.
- *
- * These functions may be called in interrupt context (anything below splhigh).
- */
+#include <sys/time.h>
 
 struct circq {
 	struct circq *next;		/* next element */
@@ -58,13 +36,15 @@ struct circq {
 
 struct timeout {
 	struct circq to_list;			/* timeout queue, don't move */
+	struct timespec to_abstime;		/* absolute time to run at */
 	void (*to_func)(void *);		/* function to call */
 	void *to_arg;				/* function argument */
-	int to_time;				/* ticks on event */
-	int to_flags;				/* misc flags */
 #if 1 /* NKCOV > 0 */
 	struct process *to_process;		/* kcov identifier */
 #endif
+	int to_time;				/* ticks on event */
+	int to_flags;				/* misc flags */
+	int to_kclock;				/* abstime's kernel clock */
 };
 
 /*
@@ -103,25 +83,36 @@ int timeout_sysctl(void *, size_t *, void *, size_t);
 #define timeout_initialized(to) ((to)->to_flags & TIMEOUT_INITIALIZED)
 #define timeout_triggered(to) ((to)->to_flags & TIMEOUT_TRIGGERED)
 
-#define TIMEOUT_INITIALIZER_FLAGS(fn, arg, flags) {			\
+#define KCLOCK_NONE	(-1)		/* dummy clock for sanity checks */
+#define KCLOCK_UPTIME	0		/* uptime clock; time since boot */
+#define KCLOCK_MAX	1
+
+#define TIMEOUT_INITIALIZER_FLAGS(_fn, _arg, _kclock, _flags) {		\
 	.to_list = { NULL, NULL },					\
-	.to_func = (fn),						\
-	.to_arg = (arg),						\
+	.to_abstime = { .tv_sec = 0, .tv_nsec = 0 },			\
+	.to_func = (_fn),						\
+	.to_arg = (_arg),						\
 	.to_time = 0,							\
-	.to_flags = (flags) | TIMEOUT_INITIALIZED			\
+	.to_flags = (_flags) | TIMEOUT_INITIALIZED,			\
+	.to_kclock = (_kclock)						\
 }
 
-#define TIMEOUT_INITIALIZER(_f, _a) TIMEOUT_INITIALIZER_FLAGS((_f), (_a), 0)
+#define TIMEOUT_INITIALIZER(_f, _a)					\
+    TIMEOUT_INITIALIZER_FLAGS((_f), (_a), KCLOCK_NONE, 0)
 
 void timeout_set(struct timeout *, void (*)(void *), void *);
-void timeout_set_flags(struct timeout *, void (*)(void *), void *, int);
+void timeout_set_flags(struct timeout *, void (*)(void *), void *, int, int);
 void timeout_set_proc(struct timeout *, void (*)(void *), void *);
+
 int timeout_add(struct timeout *, int);
 int timeout_add_tv(struct timeout *, const struct timeval *);
 int timeout_add_sec(struct timeout *, int);
 int timeout_add_msec(struct timeout *, int);
 int timeout_add_usec(struct timeout *, int);
 int timeout_add_nsec(struct timeout *, int);
+
+int timeout_abs_ts(struct timeout *, const struct timespec *);
+
 int timeout_del(struct timeout *);
 int timeout_del_barrier(struct timeout *);
 void timeout_barrier(struct timeout *);
diff --git a/sys/sys/timetc.h b/sys/sys/timetc.h
index dccee13..f2ad324 100644
--- a/sys/sys/timetc.h
+++ b/sys/sys/timetc.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: timetc.h,v 1.12 2020/07/06 13:33:09 pirofti Exp $ */
+/*	$OpenBSD: timetc.h,v 1.14 2023/02/04 19:19:35 cheloha Exp $ */
 
 /*
  * Copyright (c) 2000 Poul-Henning Kamp <phk@FreeBSD.org>
@@ -44,7 +44,6 @@
 
 struct timecounter;
 typedef u_int timecounter_get_t(struct timecounter *);
-typedef void timecounter_pps_t(struct timecounter *);
 
 /*
  * Locks used to protect struct members in this file:
@@ -60,13 +59,6 @@ struct timecounter {
 		 * mask any unimplemented bits out, as long as they are
 		 * constant.
 		 */
-	timecounter_pps_t	*tc_poll_pps;		/* [I] */
-		/*
-		 * This function is optional.  It will be called whenever the
-		 * timecounter is rewound, and is intended to check for PPS
-		 * events.  Normal hardware does not need it but timecounters
-		 * which latch PPS in hardware (like sys/pci/xrpu.c) do.
-		 */
 	u_int 			tc_counter_mask;	/* [I] */
 		/* This mask should mask off any unimplemented bits. */
 	u_int64_t		tc_frequency;		/* [I] */
@@ -120,6 +112,7 @@ extern struct timekeep *timekeep;
 u_int64_t tc_getfrequency(void);
 u_int64_t tc_getprecision(void);
 void	tc_init(struct timecounter *tc);
+void	tc_reset_quality(struct timecounter *, int);
 void	tc_setclock(const struct timespec *ts);
 void	tc_setrealtimeclock(const struct timespec *ts);
 void	tc_ticktock(void);
diff --git a/sys/sys/tracepoint.h b/sys/sys/tracepoint.h
index d9a674a..9395148 100644
--- a/sys/sys/tracepoint.h
+++ b/sys/sys/tracepoint.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: tracepoint.h,v 1.1 2020/01/21 16:16:23 mpi Exp $ */
+/*	$OpenBSD: tracepoint.h,v 1.2 2022/06/28 09:32:28 bluhm Exp $ */
 
 /*
  * Copyright (c) 2019 Martin Pieuchot <mpi@openbsd.org>
@@ -25,11 +25,13 @@
 #if NDT > 0
 #include <dev/dt/dtvar.h>
 
-#define	TRACEPOINT(func, name, args...)	DT_STATIC_ENTER(func, name, args)
+#define TRACEPOINT(func, name, args...)	DT_STATIC_ENTER(func, name, args)
+#define TRACEINDEX(func, index, args...) DT_INDEX_ENTER(func, index, args)
 
 #else /* NDT > 0 */
 
-#define	TRACEPOINT(func, name, args...)
+#define TRACEPOINT(func, name, args...)
+#define TRACEINDEX(func, index, args...)
 
 #endif /* NDT > 0 */
 #endif /* _KERNEL */
diff --git a/sys/sys/tree.h b/sys/sys/tree.h
index ffcac90..5ef8777 100644
--- a/sys/sys/tree.h
+++ b/sys/sys/tree.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: tree.h,v 1.29 2017/07/30 19:27:20 deraadt Exp $	*/
+/*	$OpenBSD: tree.h,v 1.31 2023/03/08 04:43:09 guenther Exp $	*/
 /*
  * Copyright 2002 Niels Provos <provos@citi.umich.edu>
  * All rights reserved.
@@ -656,7 +656,6 @@ name##_RB_NFIND(struct name *head, struct type *elm)			\
 	return (res);							\
 }									\
 									\
-/* ARGSUSED */								\
 attr struct type *							\
 name##_RB_NEXT(struct type *elm)					\
 {									\
@@ -678,7 +677,6 @@ name##_RB_NEXT(struct type *elm)					\
 	return (elm);							\
 }									\
 									\
-/* ARGSUSED */								\
 attr struct type *							\
 name##_RB_PREV(struct type *elm)					\
 {									\
@@ -910,25 +908,25 @@ _name##_RBT_PARENT(struct _type *elm)					\
 __unused static inline void						\
 _name##_RBT_SET_LEFT(struct _type *elm, struct _type *left)		\
 {									\
-	return _rb_set_left(_name##_RBT_TYPE, elm, left);		\
+	_rb_set_left(_name##_RBT_TYPE, elm, left);			\
 }									\
 									\
 __unused static inline void						\
 _name##_RBT_SET_RIGHT(struct _type *elm, struct _type *right)		\
 {									\
-	return _rb_set_right(_name##_RBT_TYPE, elm, right);		\
+	_rb_set_right(_name##_RBT_TYPE, elm, right);			\
 }									\
 									\
 __unused static inline void						\
 _name##_RBT_SET_PARENT(struct _type *elm, struct _type *parent)		\
 {									\
-	return _rb_set_parent(_name##_RBT_TYPE, elm, parent);		\
+	_rb_set_parent(_name##_RBT_TYPE, elm, parent);			\
 }									\
 									\
 __unused static inline void						\
 _name##_RBT_POISON(struct _type *elm, unsigned long poison)		\
 {									\
-	return _rb_poison(_name##_RBT_TYPE, elm, poison);		\
+	_rb_poison(_name##_RBT_TYPE, elm, poison);			\
 }									\
 									\
 __unused static inline int						\
diff --git a/sys/sys/tty.h b/sys/sys/tty.h
index cce1581..0841e64 100644
--- a/sys/sys/tty.h
+++ b/sys/sys/tty.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: tty.h,v 1.39 2020/07/14 14:33:06 deraadt Exp $	*/
+/*	$OpenBSD: tty.h,v 1.41 2022/07/02 08:50:42 visa Exp $	*/
 /*	$NetBSD: tty.h,v 1.30.4.1 1996/06/02 09:08:13 mrg Exp $	*/
 
 /*-
@@ -260,7 +260,8 @@ void	 clist_init(void);
 int	 getc(struct clist *q);
 void	 ndflush(struct clist *q, int cc);
 int	 ndqb(struct clist *q, int flag);
-u_char	*nextc(struct clist *q, u_char *cp, int *c);
+u_char	*firstc(struct clist *clp, int *c, int *cc);
+u_char	*nextc(struct clist *q, u_char *cp, int *c, int *cc);
 int	 putc(int c, struct clist *q);
 int	 q_to_b(struct clist *q, u_char *cp, int cc);
 int	 unputc(struct clist *q);
@@ -271,7 +272,6 @@ int	 ttioctl(struct tty *tp, u_long com, caddr_t data, int flag,
 	    struct proc *p);
 int	 ttread(struct tty *tp, struct uio *uio, int flag);
 void	 ttrstrt(void *tp);
-int	 ttpoll(dev_t device, int events, struct proc *p);
 int	 ttkqfilter(dev_t dev, struct knote *kn);
 void	 ttsetwater(struct tty *tp);
 int	 ttspeedtab(int speed, const struct speedtab *table);
@@ -300,13 +300,11 @@ void	 ttytstamp(struct tty *tp, int octs, int ncts, int odcd, int ndcd);
 void	tty_init(void);
 struct tty *ttymalloc(int);
 void	 ttyfree(struct tty *);
-u_char	*firstc(struct clist *clp, int *c);
 
 int	cttyopen(dev_t, int, int, struct proc *);
 int	cttyread(dev_t, struct uio *, int);
 int	cttywrite(dev_t, struct uio *, int);
 int	cttyioctl(dev_t, u_long, caddr_t, int, struct proc *);
-int	cttypoll(dev_t, int, struct proc *);
 
 void	clalloc(struct clist *, int, int);
 void	clfree(struct clist *);
diff --git a/sys/sys/types.h b/sys/sys/types.h
index dbbde58..2207da9 100644
--- a/sys/sys/types.h
+++ b/sys/sys/types.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: types.h,v 1.48 2019/02/09 04:54:11 guenther Exp $	*/
+/*	$OpenBSD: types.h,v 1.49 2022/08/06 13:31:13 semarie Exp $	*/
 /*	$NetBSD: types.h,v 1.29 1996/11/15 22:48:25 jtc Exp $	*/
 
 /*-
@@ -144,7 +144,6 @@ typedef	__mode_t	mode_t;		/* permissions */
 typedef	__nlink_t	nlink_t;	/* link count */
 typedef	__rlim_t	rlim_t;		/* resource limit */
 typedef	__segsz_t	segsz_t;	/* segment size */
-typedef	__swblk_t	swblk_t;	/* swap offset */
 typedef	__uid_t		uid_t;		/* user id */
 typedef	__useconds_t	useconds_t;	/* microseconds */
 typedef	__suseconds_t	suseconds_t;	/* microseconds (signed) */
diff --git a/sys/sys/ucred.h b/sys/sys/ucred.h
index 7ce0fd6..1398124 100644
--- a/sys/sys/ucred.h
+++ b/sys/sys/ucred.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: ucred.h,v 1.13 2018/06/21 13:58:21 visa Exp $	*/
+/*	$OpenBSD: ucred.h,v 1.14 2022/03/17 14:23:34 visa Exp $	*/
 /*	$NetBSD: ucred.h,v 1.12 1995/06/01 22:44:50 jtc Exp $	*/
 
 /*
@@ -35,13 +35,14 @@
 #ifndef _SYS_UCRED_H_
 #define	_SYS_UCRED_H_
 
+#include <sys/refcnt.h>
 #include <sys/syslimits.h>
 
 /*
  * Credentials.
  */
 struct ucred {
-	u_int	cr_ref;			/* reference count */
+	struct refcnt	cr_refcnt;	/* reference count */
 
 /* The following fields are all copied by crset() */
 #define	cr_startcopy	cr_uid
diff --git a/sys/sys/unpcb.h b/sys/sys/unpcb.h
index daa22a1..f1ff78c 100644
--- a/sys/sys/unpcb.h
+++ b/sys/sys/unpcb.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: unpcb.h,v 1.17 2019/07/15 12:28:06 bluhm Exp $	*/
+/*	$OpenBSD: unpcb.h,v 1.45 2022/11/26 17:51:18 mvs Exp $	*/
 /*	$NetBSD: unpcb.h,v 1.6 1994/06/29 06:46:08 cgd Exp $	*/
 
 /*
@@ -32,6 +32,8 @@
  *	@(#)unpcb.h	8.1 (Berkeley) 6/2/93
  */
 
+#include <sys/refcnt.h>
+
 /*
  * Protocol control block for an active
  * instance of a UNIX internal protocol.
@@ -56,22 +58,32 @@
  * Stream sockets keep copies of receive sockbuf sb_cc and sb_mbcnt
  * so that changes in the sockbuf may be computed to modify
  * back pressure on the sender accordingly.
+ *
+ * Locks used to protect struct members:
+ *      I       immutable after creation
+ *      G       unp_gc_lock
+ *      s       socket lock
  */
 
+
 struct	unpcb {
-	struct	socket *unp_socket;	/* pointer back to socket */
-	struct	vnode *unp_vnode;	/* if associated with file */
-	struct	file *unp_file;		/* backpointer for unp_gc() */
-	struct	unpcb *unp_conn;	/* control block of connected socket */
-	ino_t	unp_ino;		/* fake inode number */
-	SLIST_HEAD(,unpcb) unp_refs;	/* referencing socket linked list */
-	SLIST_ENTRY(unpcb) unp_nextref;	/* link in unp_refs list */
-	struct	mbuf *unp_addr;		/* bound address of socket */
-	long	unp_msgcount;		/* references from socket rcv buf */
-	int	unp_flags;		/* this unpcb contains peer eids */
-	struct	sockpeercred unp_connid;/* id of peer process */
-	struct	timespec unp_ctime;	/* holds creation time */
-	LIST_ENTRY(unpcb) unp_link;	/* link in per-AF list of sockets */
+	struct  refcnt unp_refcnt;      /* references to this pcb */
+	struct	socket *unp_socket;	/* [I] pointer back to socket */
+	struct	vnode *unp_vnode;	/* [s] if associated with file */
+	struct	file *unp_file;		/* [G] backpointer for unp_gc() */
+	struct	unpcb *unp_conn;	/* [s] control block of connected
+						socket */
+	ino_t	unp_ino;		/* [s] fake inode number */
+	SLIST_HEAD(,unpcb) unp_refs;	/* [s] referencing socket linked list */
+	SLIST_ENTRY(unpcb) unp_nextref;	/* [s] link in unp_refs list */
+	struct	mbuf *unp_addr;		/* [s] bound address of socket */
+	long	unp_msgcount;		/* [G] references from socket rcv buf */
+	long	unp_gcrefs;		/* [G] references from gc */
+	int	unp_flags;		/* [s] this unpcb contains peer eids */
+	int	unp_gcflags;		/* [G] garbage collector flags */
+	struct	sockpeercred unp_connid;/* [s] id of peer process */
+	struct	timespec unp_ctime;	/* [I] holds creation time */
+	LIST_ENTRY(unpcb) unp_link;	/* [G] link in per-AF list of sockets */
 };
 
 /*
@@ -79,32 +91,54 @@ struct	unpcb {
  */
 #define UNP_FEIDS	0x01		/* unp_connid contains information */
 #define UNP_FEIDSBIND	0x02		/* unp_connid was set by a bind */
-#define UNP_GCMARK	0x04		/* mark during unp_gc() */
-#define UNP_GCDEFER	0x08		/* ref'd, but not marked in this pass */
-#define UNP_GCDEAD	0x10		/* unref'd in this pass */
+#define UNP_BINDING	0x04		/* unp is binding now */
+#define UNP_CONNECTING	0x08		/* unp is connecting now */
+
+/*
+ * flag bits in unp_gcflags
+ */
+#define UNP_GCDEAD	0x01		/* unp could be dead */
 
 #define	sotounpcb(so)	((struct unpcb *)((so)->so_pcb))
 
 #ifdef _KERNEL
+
+struct stat;
+
 struct fdpass {
 	struct file	*fp;
 	int		 flags;
 };
 
-int	uipc_usrreq(struct socket *, int , struct mbuf *,
-			 struct mbuf *, struct mbuf *, struct proc *);
-int	uipc_attach(struct socket *, int);
+extern const struct pr_usrreqs uipc_usrreqs;
+extern const struct pr_usrreqs uipc_dgram_usrreqs;
+
+int	uipc_attach(struct socket *, int, int);
 int	uipc_detach(struct socket *);
+int	uipc_bind(struct socket *, struct mbuf *, struct proc *);
+int	uipc_listen(struct socket *);
+int	uipc_connect(struct socket *, struct mbuf *);
+int	uipc_accept(struct socket *, struct mbuf *);
+int	uipc_disconnect(struct socket *);
+int	uipc_shutdown(struct socket *);
+int	uipc_dgram_shutdown(struct socket *);
+void	uipc_rcvd(struct socket *);
+int	uipc_send(struct socket *, struct mbuf *, struct mbuf *,
+	    struct mbuf *);
+int	uipc_dgram_send(struct socket *, struct mbuf *, struct mbuf *,
+	    struct mbuf *);
+void	uipc_abort(struct socket *);
+int	uipc_sense(struct socket *, struct stat *);
+int	uipc_sockaddr(struct socket *, struct mbuf *);
+int	uipc_peeraddr(struct socket *, struct mbuf *);
+int	uipc_connect2(struct socket *, struct socket *);
 
 void	unp_init(void);
-int	unp_bind(struct unpcb *, struct mbuf *, struct proc *);
 int	unp_connect(struct socket *, struct mbuf *, struct proc *);
 int	unp_connect2(struct socket *, struct socket *);
 void	unp_detach(struct unpcb *);
 void	unp_disconnect(struct unpcb *);
-void	unp_drop(struct unpcb *, int);
 void	unp_gc(void *);
-void	unp_shutdown(struct unpcb *);
 int 	unp_externalize(struct mbuf *, socklen_t, int);
 int	unp_internalize(struct mbuf *, struct proc *);
 void 	unp_dispose(struct mbuf *);
diff --git a/sys/sys/videoio.h b/sys/sys/videoio.h
index d9533b3..a2b69bb 100644
--- a/sys/sys/videoio.h
+++ b/sys/sys/videoio.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: videoio.h,v 1.16 2017/02/17 06:48:33 feinerer Exp $	*/
+/*	$OpenBSD: videoio.h,v 1.17 2020/11/20 05:27:29 mglocker Exp $	*/
 /*
  *  Video for Linux Two header file
  *
@@ -3369,4 +3369,4 @@ struct v4l2_create_buffers {
 
 #define BASE_VIDIOC_PRIVATE	192		/* 192-255 are private */
 
-#endif /* _SYS_VIDEOIO_H */
+#endif /* _SYS_VIDEOIO_H_ */
diff --git a/sys/sys/vnode.h b/sys/sys/vnode.h
index 0899340..30787af 100644
--- a/sys/sys/vnode.h
+++ b/sys/sys/vnode.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: vnode.h,v 1.156 2020/04/08 08:07:52 mpi Exp $	*/
+/*	$OpenBSD: vnode.h,v 1.168 2023/02/10 14:34:17 visa Exp $	*/
 /*	$NetBSD: vnode.h,v 1.38 1996/02/29 20:59:05 cgd Exp $	*/
 
 /*
@@ -85,31 +85,36 @@ RBT_HEAD(buf_rb_bufs, buf);
 struct namecache;
 RBT_HEAD(namecache_rb_cache, namecache);
 
+/*
+ * Locks used to protect struct members in struct vnode:
+ *	a	atomic
+ *	V	vnode_mtx
+ *	B	IPL_BIO
+ */
 struct uvm_vnode;
 struct vnode {
-	struct uvm_vnode *v_uvm;		/* uvm data */
-	const struct vops *v_op;		/* vnode operations vector */
-	enum	vtype v_type;			/* vnode type */
-	enum	vtagtype v_tag;			/* type of underlying data */
-	u_int	v_flag;				/* vnode flags (see below) */
-	u_int   v_usecount;			/* reference count of users */
-	u_int   v_uvcount;			/* unveil references */
-	/* reference count of writers */
-	u_int   v_writecount;
-	u_int	v_lockcount;			/* # threads waiting on lock */
-	/* Flags that can be read/written in interrupts */
-	u_int   v_bioflag;
-	u_int   v_holdcnt;			/* buffer references */
+	struct uvm_vnode *v_uvm;	/* uvm data */
+	const struct vops *v_op;	/* vnode operations vector */
+	enum	vtype v_type;		/* vnode type */
+	enum	vtagtype v_tag;		/* type of underlying data */
+	u_int	v_flag;			/* vnode flags (see below) */
+	u_int	v_lflag;		/* [V] lock vnode flags */
+	u_int   v_usecount;		/* reference count of users */
+	u_int   v_uvcount;		/* unveil references */
+	u_int   v_writecount;		/* reference count of writers */
+	u_int	v_lockcount;		/* [V] # threads waiting on lock */
+
+	u_int   v_bioflag;		/* [B] flags accessed in interrupts */
+	u_int   v_holdcnt;		/* [B] buffer references */
 	u_int   v_id;				/* capability identifier */
-	u_int	v_inflight;
 	struct	mount *v_mount;			/* ptr to vfs we are in */
-	TAILQ_ENTRY(vnode) v_freelist;		/* vnode freelist */
+	TAILQ_ENTRY(vnode) v_freelist;	/* [B] vnode freelist */
 	TAILQ_ENTRY(vnode) v_mntvnodes;		/* vnodes for mount point */
-	struct	buf_rb_bufs v_bufs_tree;	/* lookup of all bufs */
-	struct	buflists v_cleanblkhd;		/* clean blocklist head */
-	struct	buflists v_dirtyblkhd;		/* dirty blocklist head */
-	u_int   v_numoutput;			/* num of writes in progress */
-	LIST_ENTRY(vnode) v_synclist;		/* vnode with dirty buffers */
+	struct	buf_rb_bufs v_bufs_tree;/* [B] lookup of all bufs */
+	struct	buflists v_cleanblkhd;	/* [B] clean blocklist head */
+	struct	buflists v_dirtyblkhd;	/* [B] dirty blocklist head */
+	u_int   v_numoutput;		/* [B] num of writes in progress */
+	LIST_ENTRY(vnode) v_synclist;	/* [B] vnode with dirty buffers */
 	union {
 		struct mount	*vu_mountedhere;/* ptr to mounted vfs (VDIR) */
 		struct socket	*vu_socket;	/* unix ipc (VSOCK) */
@@ -238,14 +243,10 @@ extern int		vttoif_tab[];
 #define REVOKEALL	0x0001		/* vop_revoke: revoke all aliases */
 
 
-TAILQ_HEAD(freelst, vnode);
-extern struct freelst vnode_hold_list;	/* free vnodes referencing buffers */
-extern struct freelst vnode_free_list;	/* vnode free list */
-
 #define	VATTR_NULL(vap)	vattr_null(vap)
 #define	NULLVP	((struct vnode *)NULL)
 #define	VN_KNOTE(vp, b)					\
-	KNOTE(&vp->v_selectinfo.si_note, (b))
+	knote_locked(&vp->v_selectinfo.si_note, (b))
 
 /*
  * Global vnode data.
@@ -255,6 +256,7 @@ extern	int initialvnodes;		/* XXX number of vnodes to start */
 extern	int maxvnodes;			/* XXX number of vnodes to allocate */
 extern	int syncdelay;			/* seconds to delay syncing vnodes */
 extern	int rushjob;			/* # of slots syncer should run ASAP */
+extern	struct mutex vnode_mtx;
 extern void    vhold(struct vnode *);
 extern void    vdrop(struct vnode *);
 
@@ -279,7 +281,6 @@ struct vops {
 	int	(*vop_mknod)(void *);
 	int	(*vop_open)(void *);
 	int	(*vop_pathconf)(void *);
-	int	(*vop_poll)(void *);
 	int	(*vop_print)(void *);
 	int	(*vop_read)(void *);
 	int	(*vop_readdir)(void *);
@@ -402,14 +403,6 @@ struct vop_ioctl_args {
 int VOP_IOCTL(struct vnode *, u_long, void *, int, struct ucred *,
     struct proc *);
 
-struct vop_poll_args {
-	struct vnode *a_vp;
-	int a_fflag;
-	int a_events;
-	struct proc *a_p;
-};
-int VOP_POLL(struct vnode *, int, int, struct proc *);
-
 struct vop_kqfilter_args {
 	struct vnode *a_vp;
 	int a_fflag;
@@ -556,12 +549,13 @@ struct vop_advlock_args {
 };
 int VOP_ADVLOCK(struct vnode *, void *, int, struct flock *, int);
 
-/* Special cases: */
 struct vop_strategy_args {
+	struct vnode *a_vp;
 	struct buf *a_bp;
 };
-int VOP_STRATEGY(struct buf *);
+int VOP_STRATEGY(struct vnode *, struct buf *);
 
+/* Special cases: */
 struct vop_bwrite_args {
 	struct buf *a_bp;
 };
@@ -621,11 +615,9 @@ int vfs_getcwd_getcache(struct vnode **, struct vnode **, char **, char *);
 
 /* vfs_default.c */
 int	vop_generic_abortop(void *);
+int	vop_generic_badop(void *);
 int	vop_generic_bmap(void *);
 int	vop_generic_bwrite(void *);
-int	vop_generic_islocked(void *);
-int	vop_generic_lock(void *);
-int	vop_generic_unlock(void *);
 int	vop_generic_revoke(void *);
 int	vop_generic_kqfilter(void *);
 int	vop_generic_lookup(void *);
diff --git a/sys/sys/wait.h b/sys/sys/wait.h
index 0e85f40..d838c1b 100644
--- a/sys/sys/wait.h
+++ b/sys/sys/wait.h
@@ -1,4 +1,4 @@
-/*	$OpenBSD: wait.h,v 1.17 2014/06/13 22:40:31 matthew Exp $	*/
+/*	$OpenBSD: wait.h,v 1.20 2022/12/19 00:22:11 guenther Exp $	*/
 /*	$NetBSD: wait.h,v 1.11 1996/04/09 20:55:51 cgd Exp $	*/
 
 /*
@@ -36,9 +36,10 @@
 #define _SYS_WAIT_H_
 
 #include <sys/cdefs.h>
+#include <sys/siginfo.h>
 
 /*
- * This file holds definitions relevent to the wait4 system call
+ * This file holds definitions relevant to the wait4 system call
  * and the alternate interfaces that use it (wait, wait3, waitpid).
  */
 
@@ -71,11 +72,24 @@
  * indicates that the caller should receive status about untraced children
  * which stop due to signals.  If children are stopped and a wait without
  * this option is done, it is as though they were still running... nothing
- * about them is returned.
+ * about them is returned. WNOWAIT only requests information about zombie,
+ * leaving the proc around, available for later waits.
  */
-#define WNOHANG		1	/* don't hang in wait */
-#define WUNTRACED	2	/* tell about stopped, untraced children */
-#define	WCONTINUED	8	/* report a job control continued process */
+#define WNOHANG		0x01	/* don't hang in wait */
+#define WUNTRACED	0x02	/* report stopped-by-signal processes */
+#define WCONTINUED	0x08	/* report job control continued processes */
+#if __POSIX_VISIBLE >= 200809 || __XPG_VISIBLE >= 420
+#define WEXITED		0x04	/* report exited processes */
+#define WSTOPPED	WUNTRACED
+#define WNOWAIT		0x10	/* poll only */
+#define WTRAPPED	0x20	/* report stopped-by-tracing processes */
+
+typedef enum {
+	P_ALL,
+	P_PGID,
+	P_PID
+} idtype_t;
+#endif
 
 #if __BSD_VISIBLE
 /*
@@ -93,6 +107,9 @@ struct rusage;	/* forward declaration */
 
 pid_t	wait(int *);
 pid_t	waitpid(pid_t, int *, int);
+#if __POSIX_VISIBLE >= 200809 || __XPG_VISIBLE >= 420
+int	waitid(idtype_t, id_t, siginfo_t *, int);
+#endif
 #if __BSD_VISIBLE
 pid_t	wait3(int *, int, struct rusage *);
 pid_t	wait4(pid_t, int *, int, struct rusage *);
diff --git a/usr.bin/diff/Makefile b/usr.bin/diff/Makefile
index 4f1c9d5..1f97fd5 100644
--- a/usr.bin/diff/Makefile
+++ b/usr.bin/diff/Makefile
@@ -1,7 +1,23 @@
-#	$OpenBSD: Makefile,v 1.3 2007/05/29 18:24:56 ray Exp $
+# baseutils diff Makefile
 
-PROG=	diff
-SRCS=	diff.c diffdir.c diffreg.c xmalloc.c
-COPTS+= -Wall
+CC ?=		cc
+CFLAGS ?=	-O2 -pipe
+CFLAGS +=	-I../libopenbsd -include openbsd.h -D_GNU_SOURCE
 
-.include <bsd.prog.mk>
+LIBS =	../libopenbsd/libopenbsd.a
+
+PREFIX ?=	/usr/local
+MANDIR ?=	/usr/local/share/man
+
+PROG =	diff
+OBJS =	diff.o diffdir.o diffreg.o xmalloc.o
+
+all: ${OBJS}
+	${CC} ${LDFLAGS} -o ${PROG} ${OBJS} ${LIBS}
+
+install:
+	install -c -s -m 555 ${PROG} ${PREFIX}/bin/${PROG}
+	install -c -m 444 ${PROG}.1 ${MANDIR}/man1
+
+clean:
+	rm -f ${PROG} ${OBJS}
diff --git a/usr.bin/diff/diff.1 b/usr.bin/diff/diff.1
index 85a168d..abf65c7 100644
--- a/usr.bin/diff/diff.1
+++ b/usr.bin/diff/diff.1
@@ -1,4 +1,4 @@
-.\" $OpenBSD: diff.1,v 1.50 2021/03/08 02:47:27 jsg Exp $
+.\" $OpenBSD: diff.1,v 1.51 2023/01/05 00:00:44 millert Exp $
 .\"
 .\" Copyright (c) 1980, 1990, 1993
 .\"	The Regents of the University of California.  All rights reserved.
@@ -29,7 +29,7 @@
 .\"
 .\"     @(#)diff.1	8.1 (Berkeley) 6/30/93
 .\"
-.Dd $Mdocdate: March 8 2021 $
+.Dd $Mdocdate: January 5 2023 $
 .Dt DIFF 1
 .Os
 .Sh NAME
@@ -46,24 +46,24 @@
 .Op Fl L Ar label
 .Ar file1 file2
 .Nm diff
-.Op Fl abdilpTtw
+.Op Fl abdipTtw
 .Op Fl I Ar pattern
 .Op Fl L Ar label
 .Fl C Ar number
 .Ar file1 file2
 .Nm diff
-.Op Fl abdiltw
+.Op Fl abditw
 .Op Fl I Ar pattern
 .Fl D Ar string
 .Ar file1 file2
 .Nm diff
-.Op Fl abdilpTtw
+.Op Fl abdipTtw
 .Op Fl I Ar pattern
 .Op Fl L Ar label
 .Fl U Ar number
 .Ar file1 file2
 .Nm diff
-.Op Fl abdilNPprsTtw
+.Op Fl abdiNPprsTtw
 .Oo
 .Fl c | e | f |
 .Fl n | q | u
@@ -466,7 +466,7 @@ utility is compliant with the
 specification.
 .Pp
 The flags
-.Op Fl aDdIiLlNnPpqSsTtwXx
+.Op Fl aDdIiLNnPpqSsTtwXx
 are extensions to that specification.
 .Sh HISTORY
 A
diff --git a/usr.bin/diff/diff.c b/usr.bin/diff/diff.c
index 64cdd45..025fce5 100644
--- a/usr.bin/diff/diff.c
+++ b/usr.bin/diff/diff.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: diff.c,v 1.67 2019/06/28 13:35:00 deraadt Exp $	*/
+/*	$OpenBSD: diff.c,v 1.68 2023/01/05 00:00:44 millert Exp $	*/
 
 /*
  * Copyright (c) 2003 Todd C. Miller <millert@openbsd.org>
@@ -44,7 +44,7 @@ struct stat stb1, stb2;
 struct excludes *excludes_list;
 regex_t	 ignore_re;
 
-#define	OPTIONS	"0123456789abC:cdD:efhI:iL:lnNPpqrS:sTtU:uwX:x:"
+#define	OPTIONS	"0123456789abC:cdD:efhI:iL:nNPpqrS:sTtU:uwX:x:"
 static struct option longopts[] = {
 	{ "text",			no_argument,		0,	'a' },
 	{ "ignore-space-change",	no_argument,		0,	'b' },
diff --git a/usr.bin/diff/diffreg.c b/usr.bin/diff/diffreg.c
index fc0029d..3470f54 100644
--- a/usr.bin/diff/diffreg.c
+++ b/usr.bin/diff/diffreg.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: diffreg.c,v 1.93 2019/06/28 13:35:00 deraadt Exp $	*/
+/*	$OpenBSD: diffreg.c,v 1.95 2021/10/24 21:24:16 deraadt Exp $	*/
 
 /*
  * Copyright (C) Caldera International Inc.  2001-2002.
@@ -430,6 +430,10 @@ files_differ(FILE *f1, FILE *f2, int flags)
 	if ((flags & (D_EMPTY1|D_EMPTY2)) || stb1.st_size != stb2.st_size ||
 	    (stb1.st_mode & S_IFMT) != (stb2.st_mode & S_IFMT))
 		return (1);
+
+	if (stb1.st_dev == stb2.st_dev && stb1.st_ino == stb2.st_ino)
+		return (0);
+
 	for (;;) {
 		i = fread(buf1, 1, sizeof(buf1), f1);
 		j = fread(buf2, 1, sizeof(buf2), f2);
@@ -453,7 +457,7 @@ opentemp(const char *file)
 
 	if (strcmp(file, "-") == 0)
 		ifd = STDIN_FILENO;
-	else if ((ifd = open(file, O_RDONLY, 0644)) == -1)
+	else if ((ifd = open(file, O_RDONLY)) == -1)
 		return (NULL);
 
 	(void)strlcpy(tempfile, _PATH_TMP "/diff.XXXXXXXX", sizeof(tempfile));
diff --git a/usr.bin/patch/Makefile b/usr.bin/patch/Makefile
index 7ff9ec2..4f81dce 100644
--- a/usr.bin/patch/Makefile
+++ b/usr.bin/patch/Makefile
@@ -1,6 +1,23 @@
-#	$OpenBSD: Makefile,v 1.5 2015/10/16 07:33:47 tobias Exp $
+# baseutils patch Makefile
 
-PROG=	patch
-SRCS=	patch.c pch.c inp.c util.c backupfile.c mkpath.c ed.c
+CC ?=		cc
+CFLAGS ?=	-O2 -pipe
+CFLAGS +=	-I../libopenbsd -include openbsd.h -D_GNU_SOURCE
 
-.include <bsd.prog.mk>
+LIBS =	../libopenbsd/libopenbsd.a
+
+PREFIX ?=	/usr/local
+MANDIR ?=	/usr/local/share/man
+
+PROG =	patch
+OBJS =	patch.o pch.o inp.o util.o backupfile.o mkpath.o ed.o
+
+all: ${OBJS}
+	${CC} ${LDFLAGS} -o ${PROG} ${OBJS} ${LIBS}
+
+install:
+	install -c -s -m 555 ${PROG} ${PREFIX}/bin/${PROG}
+	install -c -m 444 ${PROG}.1 ${MANDIR}/man1
+
+clean:
+	rm -f ${PROG} ${OBJS}
diff --git a/usr.bin/patch/patch.1 b/usr.bin/patch/patch.1
index 8d915b8..f88192f 100644
--- a/usr.bin/patch/patch.1
+++ b/usr.bin/patch/patch.1
@@ -1,4 +1,4 @@
-.\"	$OpenBSD: patch.1,v 1.32 2018/06/22 15:37:15 zhuk Exp $
+.\"	$OpenBSD: patch.1,v 1.36 2022/03/31 17:27:26 naddy Exp $
 .\" Copyright 1986, Larry Wall
 .\"
 .\" Redistribution and use in source and binary forms, with or without
@@ -19,7 +19,7 @@
 .\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 .\" SUCH DAMAGE.
 .\"
-.Dd $Mdocdate: June 22 2018 $
+.Dd $Mdocdate: March 31 2022 $
 .Dt PATCH 1
 .Os
 .Sh NAME
@@ -47,10 +47,12 @@
 .Pf \*(Lt Ar patchfile
 .Sh DESCRIPTION
 .Nm
-will take a patch file containing any of the four forms of difference
+takes the text file
+.Ar patchfile
+containing any of the four forms of difference
 listing produced by the
 .Xr diff 1
-program and apply those differences to an original file,
+program and applies those differences to an original text file,
 producing a patched version.
 If
 .Ar patchfile
@@ -151,7 +153,7 @@ the number of lines of context in the context diff, ordinarily 3.
 .It Fl f , Fl Fl force
 Forces
 .Nm
-to assume that the user knows exactly what he or she is doing, and to not
+to assume that the user knows exactly what they are doing, and to not
 ask any questions.
 It assumes the following:
 skip patches for which a file to patch can't be found;
@@ -168,7 +170,6 @@ for that.
 .Xc
 Causes the next argument to be interpreted as the input file name
 (i.e. a patchfile).
-This option may be specified multiple times.
 .It Fl l , Fl Fl ignore-whitespace
 Causes the pattern matching to be done loosely, in case the tabs and
 spaces have been munged in your input file.
@@ -602,7 +603,7 @@ One or more lines were written to a reject file.
 An error occurred.
 .El
 .Pp
-When applying a set of patches in a loop it behooves you to check this
+When applying a set of patches in a loop, it behooves you to check this
 exit status so you don't apply a later patch to a partially patched file.
 .Sh DIAGNOSTICS
 Too many to list here, but generally indicative that
diff --git a/usr.bin/patch/patch.c b/usr.bin/patch/patch.c
index 088ea1f..239d2db 100644
--- a/usr.bin/patch/patch.c
+++ b/usr.bin/patch/patch.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: patch.c,v 1.69 2019/12/02 22:17:32 jca Exp $	*/
+/*	$OpenBSD: patch.c,v 1.71 2022/08/03 07:30:37 op Exp $	*/
 
 /*
  * patch - a program to apply diffs to original files
@@ -261,7 +261,8 @@ main(int argc, char *argv[])
 			if (!skip_rest_of_patch) {
 				do {
 					where = locate_hunk(fuzz);
-					if (hunk == 1 && where == 0 && !force) {
+					if ((hunk == 1 && where == 0 && !force) ||
+					    (where == 1 && pch_ptrn_lines() == 0 && !force)) {
 						/* dwim for reversed patch? */
 						if (!pch_swap()) {
 							if (fuzz == 0)
@@ -277,6 +278,10 @@ main(int argc, char *argv[])
 								/* put it back to normal */
 								fatal("lost hunk on alloc error!\n");
 							reverse = !reverse;
+
+							/* restore position if this patch creates a file */
+							if (pch_ptrn_lines() == 0)
+								where = 1;
 						} else if (noreverse) {
 							if (!pch_swap())
 								/* put it back to normal */
@@ -647,6 +652,8 @@ locate_hunk(LINENUM fuzz)
 		    || diff_type == UNI_DIFF)) {
 			say("Empty context always matches.\n");
 		}
+		if (first_guess == 0)
+			return 1;
 		return (first_guess);
 	}
 	if (max_neg_offset >= first_guess)	/* do not try lines < 0 */
diff --git a/usr.bin/patch/pch.c b/usr.bin/patch/pch.c
index 89db753..23b0b57 100644
--- a/usr.bin/patch/pch.c
+++ b/usr.bin/patch/pch.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: pch.c,v 1.62 2019/12/02 22:23:19 jca Exp $	*/
+/*	$OpenBSD: pch.c,v 1.63 2022/12/26 19:16:02 jmc Exp $	*/
 
 /*
  * patch - a program to apply diffs to original files
@@ -495,7 +495,7 @@ another_hunk(void)
 	LINENUM	fillcnt;			/* #lines of missing ptrn or repl */
 	LINENUM	fillsrc;			/* index of first line to copy */
 	LINENUM	filldst;			/* index of first missing line */
-	bool	ptrn_spaces_eaten;		/* ptrn was slightly misformed */
+	bool	ptrn_spaces_eaten;		/* ptrn was slightly malformed */
 	bool	repl_could_be_missing;		/* no + or ! lines in this hunk */
 	bool	repl_missing;			/* we are now backtracking */
 	off_t	repl_backtrack_position;	/* file pos of first repl line */
diff --git a/usr.bin/patch/util.c b/usr.bin/patch/util.c
index f079b51..c94a3f2 100644
--- a/usr.bin/patch/util.c
+++ b/usr.bin/patch/util.c
@@ -1,4 +1,4 @@
-/*	$OpenBSD: util.c,v 1.45 2019/12/02 22:17:32 jca Exp $	*/
+/*	$OpenBSD: util.c,v 1.46 2021/10/24 21:24:17 deraadt Exp $	*/
 
 /*
  * patch - a program to apply diffs to original files
@@ -157,7 +157,7 @@ copy_file(const char *from, const char *to)
 	tofd = open(to, O_CREAT|O_TRUNC|O_WRONLY, 0666);
 	if (tofd == -1)
 		return -1;
-	fromfd = open(from, O_RDONLY, 0);
+	fromfd = open(from, O_RDONLY);
 	if (fromfd == -1)
 		pfatal("internal error, can't reopen %s", from);
 	while ((i = read(fromfd, buf, bufsz)) > 0)
-- 
2.42.0

